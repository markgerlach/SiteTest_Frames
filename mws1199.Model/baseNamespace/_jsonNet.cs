#region License
// Copyright (c) 2007 James Newton-King
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
#endregion

#region Using Block
using System;
using System.Globalization;
using System.IO;
using System.Text;
using Newtonsoft.Json.Utilities;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using System.Collections;
using System.Data.SqlTypes;
using Newtonsoft.Json.Bson;
using System.Data;
using Newtonsoft.Json.Serialization;
using System.Dynamic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Linq;
using System.Collections.Specialized;
using System.Threading;
using System.ComponentModel;
using System.Collections.ObjectModel;
using System.Linq.Expressions;
using System.Diagnostics;
using System.Collections.Concurrent;
using System.Security.Permissions;
using System.Xml.Serialization;
using Newtonsoft.Json.Converters;
using System.Runtime.CompilerServices;
using DiagnosticsTrace = System.Diagnostics.Trace;
using System.Security;
using System.Net;
using System.Runtime.Serialization.Formatters;
using System.Reflection.Emit;
using System.Resources;
using System.Threading.Tasks;
using Newtonsoft.Json.Schema;
using ErrorEventArgs=Newtonsoft.Json.Serialization.ErrorEventArgs;
#endregion Using Block

/// ********   File: \Bson\BsonBinaryType.cs
#region Bson_BsonBinaryType.cs

namespace Newtonsoft.Json.Bson
{
  internal enum BsonBinaryType : byte
  {
    Binary = 0x00,
    Function = 0x01,
    [Obsolete("This type has been deprecated in the BSON specification. Use Binary instead.")]
    Data = 0x02,
    Uuid = 0x03,
    Md5 = 0x05,
    UserDefined = 0x80
  }
}
#endregion Bson_BsonBinaryType.cs

/// ********   File: \Bson\BsonBinaryWriter.cs
#region Bson_BsonBinaryWriter.cs

namespace Newtonsoft.Json.Bson
{
  internal class BsonBinaryWriter
  {
    private static readonly Encoding Encoding = new UTF8Encoding(false);

    private readonly BinaryWriter _writer;

    private byte[] _largeByteBuffer;

    public DateTimeKind DateTimeKindHandling { get; set; }

    public BsonBinaryWriter(BinaryWriter writer)
    {
      DateTimeKindHandling = DateTimeKind.Utc;
      _writer = writer;
    }

    public void Flush()
    {
      _writer.Flush();
    }

    public void Close()
    {
#if !(NETFX_CORE || PORTABLE)
      _writer.Close();
#else
      _writer.Dispose();
#endif
    }

    public void WriteToken(BsonToken t)
    {
      CalculateSize(t);
      WriteTokenInternal(t);
    }

    private void WriteTokenInternal(BsonToken t)
    {
      switch (t.Type)
      {
        case BsonType.Object:
          {
            BsonObject value = (BsonObject)t;
            _writer.Write(value.CalculatedSize);
            foreach (BsonProperty property in value)
            {
              _writer.Write((sbyte)property.Value.Type);
              WriteString((string)property.Name.Value, property.Name.ByteCount, null);
              WriteTokenInternal(property.Value);
            }
            _writer.Write((byte)0);
          }
          break;
        case BsonType.Array:
          {
            BsonArray value = (BsonArray)t;
            _writer.Write(value.CalculatedSize);
            int index = 0;
            foreach (BsonToken c in value)
            {
              _writer.Write((sbyte)c.Type);
              WriteString(index.ToString(CultureInfo.InvariantCulture), MathUtils.IntLength(index), null);
              WriteTokenInternal(c);
              index++;
            }
            _writer.Write((byte)0);
          }
          break;
        case BsonType.Integer:
          {
            BsonValue value = (BsonValue)t;
            _writer.Write(Convert.ToInt32(value.Value, CultureInfo.InvariantCulture));
          }
          break;
        case BsonType.Long:
          {
            BsonValue value = (BsonValue)t;
            _writer.Write(Convert.ToInt64(value.Value, CultureInfo.InvariantCulture));
          }
          break;
        case BsonType.Number:
          {
            BsonValue value = (BsonValue)t;
            _writer.Write(Convert.ToDouble(value.Value, CultureInfo.InvariantCulture));
          }
          break;
        case BsonType.String:
          {
            BsonString value = (BsonString)t;
            WriteString((string)value.Value, value.ByteCount, value.CalculatedSize - 4);
          }
          break;
        case BsonType.Boolean:
          {
            BsonValue value = (BsonValue)t;
            _writer.Write((bool)value.Value);
          }
          break;
        case BsonType.Null:
        case BsonType.Undefined:
          break;
        case BsonType.Date:
          {
            BsonValue value = (BsonValue)t;

            long ticks = 0;

            if (value.Value is DateTime)
            {
              DateTime dateTime = (DateTime)value.Value;
              if (DateTimeKindHandling == DateTimeKind.Utc)
                dateTime = dateTime.ToUniversalTime();
              else if (DateTimeKindHandling == DateTimeKind.Local)
                dateTime = dateTime.ToLocalTime();

              ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTime, false);
            }
#if !PocketPC && !NET20
            else
            {
              DateTimeOffset dateTimeOffset = (DateTimeOffset)value.Value;
              ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime, dateTimeOffset.Offset);
            }
#endif

            _writer.Write(ticks);
          }
          break;
        case BsonType.Binary:
          {
            BsonValue value = (BsonValue)t;

            byte[] data = (byte[])value.Value;
            _writer.Write(data.Length);
            _writer.Write((byte)BsonBinaryType.Binary);
            _writer.Write(data);
          }
          break;
        case BsonType.Oid:
          {
            BsonValue value = (BsonValue)t;

            byte[] data = (byte[])value.Value;
            _writer.Write(data);
          }
          break;
        case BsonType.Regex:
          {
            BsonRegex value = (BsonRegex)t;

            WriteString((string)value.Pattern.Value, value.Pattern.ByteCount, null);
            WriteString((string)value.Options.Value, value.Options.ByteCount, null);
          }
          break;
        default:
          throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
      }
    }

    private void WriteString(string s, int byteCount, int? calculatedlengthPrefix)
    {
      if (calculatedlengthPrefix != null)
        _writer.Write(calculatedlengthPrefix.Value);

      WriteUtf8Bytes(s, byteCount);

      _writer.Write((byte)0);
    }

    public void WriteUtf8Bytes(string s, int byteCount)
    {
      if (s != null)
      {
        if (_largeByteBuffer == null)
        {
          _largeByteBuffer = new byte[256];
        }
        if (byteCount <= 256)
        {
          Encoding.GetBytes(s, 0, s.Length, _largeByteBuffer, 0);
          _writer.Write(_largeByteBuffer, 0, byteCount);
        }
        else
        {
          byte[] bytes = Encoding.GetBytes(s);
          _writer.Write(bytes);
        }
      }
    }

    private int CalculateSize(int stringByteCount)
    {
      return stringByteCount + 1;
    }

    private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
    {
      int baseSize = (includeSize)
        ? 5 // size bytes + terminator
        : 1; // terminator

      return baseSize + stringByteCount;
    }

    private int CalculateSize(BsonToken t)
    {
      switch (t.Type)
      {
        case BsonType.Object:
          {
            BsonObject value = (BsonObject)t;

            int bases = 4;
            foreach (BsonProperty p in value)
            {
              int size = 1;
              size += CalculateSize(p.Name);
              size += CalculateSize(p.Value);

              bases += size;
            }
            bases += 1;
            value.CalculatedSize = bases;
            return bases;
          }
        case BsonType.Array:
          {
            BsonArray value = (BsonArray)t;

            int size = 4;
            int index = 0;
            foreach (BsonToken c in value)
            {
              size += 1;
              size += CalculateSize(MathUtils.IntLength(index));
              size += CalculateSize(c);
              index++;
            }
            size += 1;
            value.CalculatedSize = size;

            return value.CalculatedSize;
          }
        case BsonType.Integer:
          return 4;
        case BsonType.Long:
          return 8;
        case BsonType.Number:
          return 8;
        case BsonType.String:
          {
            BsonString value = (BsonString)t;
            string s = (string)value.Value;
            value.ByteCount = (s != null) ? Encoding.GetByteCount(s) : 0;
            value.CalculatedSize = CalculateSizeWithLength(value.ByteCount, value.IncludeLength);

            return value.CalculatedSize;
          }
        case BsonType.Boolean:
          return 1;
        case BsonType.Null:
        case BsonType.Undefined:
          return 0;
        case BsonType.Date:
          return 8;
        case BsonType.Binary:
          {
            BsonValue value = (BsonValue)t;

            byte[] data = (byte[])value.Value;
            value.CalculatedSize = 4 + 1 + data.Length;

            return value.CalculatedSize;
          }
        case BsonType.Oid:
          return 12;
        case BsonType.Regex:
          {
            BsonRegex value = (BsonRegex)t;
            int size = 0;
            size += CalculateSize(value.Pattern);
            size += CalculateSize(value.Options);
            value.CalculatedSize = size;

            return value.CalculatedSize;
          }
        default:
          throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
      }
    }
  }
}
#endregion Bson_BsonBinaryWriter.cs

/// ********   File: \Bson\BsonObjectId.cs
#region Bson_BsonObjectId.cs

namespace Newtonsoft.Json.Bson
{
  /// <summary>
  /// Represents a BSON Oid (object id).
  /// </summary>
  public class BsonObjectId
  {
    /// <summary>
    /// Gets or sets the value of the Oid.
    /// </summary>
    /// <value>The value of the Oid.</value>
    public byte[] Value { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonObjectId"/> class.
    /// </summary>
    /// <param name="value">The Oid value.</param>
    public BsonObjectId(byte[] value)
    {
      ValidationUtils.ArgumentNotNull(value, "value");
      if (value.Length != 12)
        throw new ArgumentException("An ObjectId must be 12 bytes", "value");

      Value = value;
    }
  }
}
#endregion Bson_BsonObjectId.cs

/// ********   File: \Bson\BsonReader.cs
#region Bson_BsonReader.cs

namespace Newtonsoft.Json.Bson
{
  /// <summary>
  /// Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
  /// </summary>
  public class BsonReader : JsonReader
  {
    private const int MaxCharBytesSize = 128;
    private static readonly byte[] SeqRange1 = new byte[] {0, 127}; // range of 1-byte sequence
    private static readonly byte[] SeqRange2 = new byte[] {194, 223}; // range of 2-byte sequence
    private static readonly byte[] SeqRange3 = new byte[] {224, 239}; // range of 3-byte sequence
    private static readonly byte[] SeqRange4 = new byte[] {240, 244}; // range of 4-byte sequence

    private readonly BinaryReader _reader;
    private readonly List<ContainerContext> _stack;

    private byte[] _byteBuffer;
    private char[] _charBuffer;

    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;

    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;

    private enum BsonReaderState
    {
      Normal,
      ReferenceStart,
      ReferenceRef,
      ReferenceId,
      CodeWScopeStart,
      CodeWScopeCode,
      CodeWScopeScope,
      CodeWScopeScopeObject,
      CodeWScopeScopeEnd
    }

    private class ContainerContext
    {
      public readonly BsonType Type;
      public int Length;
      public int Position;

      public ContainerContext(BsonType type)
      {
        Type = type;
      }
    }

    /// <summary>
    /// Gets or sets a value indicating whether binary data reading should compatible with incorrect Json.NET 3.5 written binary.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
    /// </value>
    public bool JsonNet35BinaryCompatibility
    {
      get { return _jsonNet35BinaryCompatibility; }
      set { _jsonNet35BinaryCompatibility = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the root object will be read as a JSON array.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
    /// </value>
    public bool ReadRootValueAsArray
    {
      get { return _readRootValueAsArray; }
      set { _readRootValueAsArray = value; }
    }

    /// <summary>
    /// Gets or sets the <see cref="DateTimeKind" /> used when reading <see cref="DateTime"/> values from BSON.
    /// </summary>
    /// <value>The <see cref="DateTimeKind" /> used when reading <see cref="DateTime"/> values from BSON.</value>
    public DateTimeKind DateTimeKindHandling
    {
      get { return _dateTimeKindHandling; }
      set { _dateTimeKindHandling = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonReader"/> class.
    /// </summary>
    /// <param name="stream">The stream.</param>
    public BsonReader(Stream stream)
      : this(stream, false, DateTimeKind.Local)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonReader"/> class.
    /// </summary>
    /// <param name="reader">The reader.</param>
    public BsonReader(BinaryReader reader)
      : this(reader, false, DateTimeKind.Local)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonReader"/> class.
    /// </summary>
    /// <param name="stream">The stream.</param>
    /// <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
    /// <param name="dateTimeKindHandling">The <see cref="DateTimeKind" /> used when reading <see cref="DateTime"/> values from BSON.</param>
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
    {
      ValidationUtils.ArgumentNotNull(stream, "stream");
      _reader = new BinaryReader(stream);
      _stack = new List<ContainerContext>();
      _readRootValueAsArray = readRootValueAsArray;
      _dateTimeKindHandling = dateTimeKindHandling;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonReader"/> class.
    /// </summary>
    /// <param name="reader">The reader.</param>
    /// <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
    /// <param name="dateTimeKindHandling">The <see cref="DateTimeKind" /> used when reading <see cref="DateTime"/> values from BSON.</param>
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");
      _reader = reader;
      _stack = new List<ContainerContext>();
      _readRootValueAsArray = readRootValueAsArray;
      _dateTimeKindHandling = dateTimeKindHandling;
    }

    private string ReadElement()
    {
      _currentElementType = ReadType();
      string elementName = ReadString();
      return elementName;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
    /// </returns>
    public override byte[] ReadAsBytes()
    {
      return ReadAsBytesInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Decimal}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override decimal? ReadAsDecimal()
    {
      return ReadAsDecimalInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Int32}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override int? ReadAsInt32()
    {
      return ReadAsInt32Internal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="String"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override string ReadAsString()
    {
      return ReadAsStringInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTime? ReadAsDateTime()
    {
      return ReadAsDateTimeInternal();
    }

#if !NET20
    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="Nullable{DateTimeOffset}"/>. This method will return <c>null</c> at the end of an array.
    /// </returns>
    public override DateTimeOffset? ReadAsDateTimeOffset()
    {
      return ReadAsDateTimeOffsetInternal();
    }
#endif

    /// <summary>
    /// Reads the next JSON token from the stream.
    /// </summary>
    /// <returns>
    /// true if the next token was read successfully; false if there are no more tokens to read.
    /// </returns>
    public override bool Read()
    {
      _readType = Json.ReadType.Read;

      return ReadInternal();
    }

    internal override bool ReadInternal()
    {
      try
      {
        bool success;

        switch (_bsonReaderState)
        {
          case BsonReaderState.Normal:
            success = ReadNormal();
            break;
          case BsonReaderState.ReferenceStart:
          case BsonReaderState.ReferenceRef:
          case BsonReaderState.ReferenceId:
            success = ReadReference();
            break;
          case BsonReaderState.CodeWScopeStart:
          case BsonReaderState.CodeWScopeCode:
          case BsonReaderState.CodeWScopeScope:
          case BsonReaderState.CodeWScopeScopeObject:
          case BsonReaderState.CodeWScopeScopeEnd:
            success = ReadCodeWScope();
            break;
          default:
            throw JsonReaderException.Create(this, "Unexpected state: {0}".FormatWith(CultureInfo.InvariantCulture, _bsonReaderState));
        }

        if (!success)
        {
          SetToken(JsonToken.None);
          return false;
        }

        return true;
      }
      catch (EndOfStreamException)
      {
        SetToken(JsonToken.None);
        return false;
      }
    }

    /// <summary>
    /// Changes the <see cref="JsonReader.State"/> to Closed.
    /// </summary>
    public override void Close()
    {
      base.Close();

      if (CloseInput && _reader != null)
#if !(NETFX_CORE || PORTABLE)
        _reader.Close();
#else
        _reader.Dispose();
#endif
    }

    private bool ReadCodeWScope()
    {
      switch (_bsonReaderState)
      {
        case BsonReaderState.CodeWScopeStart:
          SetToken(JsonToken.PropertyName, "$code");
          _bsonReaderState = BsonReaderState.CodeWScopeCode;
          return true;
        case BsonReaderState.CodeWScopeCode:
          // total CodeWScope size - not used
          ReadInt32();

          SetToken(JsonToken.String, ReadLengthString());
          _bsonReaderState = BsonReaderState.CodeWScopeScope;
          return true;
        case BsonReaderState.CodeWScopeScope:
          if (CurrentState == State.PostValue)
          {
            SetToken(JsonToken.PropertyName, "$scope");
            return true;
          }
          else
          {
            SetToken(JsonToken.StartObject);
            _bsonReaderState = BsonReaderState.CodeWScopeScopeObject;

            ContainerContext newContext = new ContainerContext(BsonType.Object);
            PushContext(newContext);
            newContext.Length = ReadInt32();

            return true;
          }
        case BsonReaderState.CodeWScopeScopeObject:
          bool result = ReadNormal();
          if (result && TokenType == JsonToken.EndObject)
            _bsonReaderState = BsonReaderState.CodeWScopeScopeEnd;

          return result;
        case BsonReaderState.CodeWScopeScopeEnd:
          SetToken(JsonToken.EndObject);
          _bsonReaderState = BsonReaderState.Normal;
          return true;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    private bool ReadReference()
    {
      switch (CurrentState)
      {
        case State.ObjectStart:
          {
            SetToken(JsonToken.PropertyName, "$ref");
            _bsonReaderState = BsonReaderState.ReferenceRef;
            return true;
          }
        case State.Property:
          {
            if (_bsonReaderState == BsonReaderState.ReferenceRef)
            {
              SetToken(JsonToken.String, ReadLengthString());
              return true;
            }
            else if (_bsonReaderState == BsonReaderState.ReferenceId)
            {
              SetToken(JsonToken.Bytes, ReadBytes(12));
              return true;
            }
            else
            {
              throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
            }
          }
        case State.PostValue:
          {
            if (_bsonReaderState == BsonReaderState.ReferenceRef)
            {
              SetToken(JsonToken.PropertyName, "$id");
              _bsonReaderState = BsonReaderState.ReferenceId;
              return true;
            }
            else if (_bsonReaderState == BsonReaderState.ReferenceId)
            {
              SetToken(JsonToken.EndObject);
              _bsonReaderState = BsonReaderState.Normal;
              return true;
            }
            else
            {
              throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
            }
          }
        default:
          throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + CurrentState);
      }
    }

    private bool ReadNormal()
    {
      switch (CurrentState)
      {
        case State.Start:
          {
            JsonToken token = (!_readRootValueAsArray) ? JsonToken.StartObject : JsonToken.StartArray;
            BsonType type = (!_readRootValueAsArray) ? BsonType.Object : BsonType.Array;

            SetToken(token);
            ContainerContext newContext = new ContainerContext(type);
            PushContext(newContext);
            newContext.Length = ReadInt32();
            return true;
          }
        case State.Complete:
        case State.Closed:
          return false;
        case State.Property:
          {
            ReadType(_currentElementType);
            return true;
          }
        case State.ObjectStart:
        case State.ArrayStart:
        case State.PostValue:
          ContainerContext context = _currentContext;
          if (context == null)
            return false;

          int lengthMinusEnd = context.Length - 1;

          if (context.Position < lengthMinusEnd)
          {
            if (context.Type == BsonType.Array)
            {
              ReadElement();
              ReadType(_currentElementType);
              return true;
            }
            else
            {
              SetToken(JsonToken.PropertyName, ReadElement());
              return true;
            }
          }
          else if (context.Position == lengthMinusEnd)
          {
            if (ReadByte() != 0)
              throw JsonReaderException.Create(this, "Unexpected end of object byte value.");

            PopContext();
            if (_currentContext != null)
              MovePosition(context.Length);

            JsonToken endToken = (context.Type == BsonType.Object) ? JsonToken.EndObject : JsonToken.EndArray;
            SetToken(endToken);
            return true;
          }
          else
          {
            throw JsonReaderException.Create(this, "Read past end of current container context.");
          }
        case State.ConstructorStart:
          break;
        case State.Constructor:
          break;
        case State.Error:
          break;
        case State.Finished:
          break;
        default:
          throw new ArgumentOutOfRangeException();
      }

      return false;
    }

    private void PopContext()
    {
      _stack.RemoveAt(_stack.Count - 1);
      if (_stack.Count == 0)
        _currentContext = null;
      else
        _currentContext = _stack[_stack.Count - 1];
    }

    private void PushContext(ContainerContext newContext)
    {
      _stack.Add(newContext);
      _currentContext = newContext;
    }

    private byte ReadByte()
    {
      MovePosition(1);
      return _reader.ReadByte();
    }

    private void ReadType(BsonType type)
    {
      switch (type)
      {
        case BsonType.Number:
          SetToken(JsonToken.Float, ReadDouble());
          break;
        case BsonType.String:
        case BsonType.Symbol:
          SetToken(JsonToken.String, ReadLengthString());
          break;
        case BsonType.Object:
          {
            SetToken(JsonToken.StartObject);

            ContainerContext newContext = new ContainerContext(BsonType.Object);
            PushContext(newContext);
            newContext.Length = ReadInt32();
            break;
          }
        case BsonType.Array:
          {
            SetToken(JsonToken.StartArray);

            ContainerContext newContext = new ContainerContext(BsonType.Array);
            PushContext(newContext);
            newContext.Length = ReadInt32();
            break;
          }
        case BsonType.Binary:
          SetToken(JsonToken.Bytes, ReadBinary());
          break;
        case BsonType.Undefined:
          SetToken(JsonToken.Undefined);
          break;
        case BsonType.Oid:
          byte[] oid = ReadBytes(12);
          SetToken(JsonToken.Bytes, oid);
          break;
        case BsonType.Boolean:
          bool b = Convert.ToBoolean(ReadByte());
          SetToken(JsonToken.Boolean, b);
          break;
        case BsonType.Date:
          long ticks = ReadInt64();
          DateTime utcDateTime = JsonConvert.ConvertJavaScriptTicksToDateTime(ticks);

          DateTime dateTime;
          switch (DateTimeKindHandling)
          {
            case DateTimeKind.Unspecified:
              dateTime = DateTime.SpecifyKind(utcDateTime, DateTimeKind.Unspecified);
              break;
            case DateTimeKind.Local:
              dateTime = utcDateTime.ToLocalTime();
              break;
            default:
              dateTime = utcDateTime;
              break;
          }

          SetToken(JsonToken.Date, dateTime);
          break;
        case BsonType.Null:
          SetToken(JsonToken.Null);
          break;
        case BsonType.Regex:
          string expression = ReadString();
          string modifiers = ReadString();

          string regex = @"/" + expression + @"/" + modifiers;
          SetToken(JsonToken.String, regex);
          break;
        case BsonType.Reference:
          SetToken(JsonToken.StartObject);
          _bsonReaderState = BsonReaderState.ReferenceStart;
          break;
        case BsonType.Code:
          SetToken(JsonToken.String, ReadLengthString());
          break;
        case BsonType.CodeWScope:
          SetToken(JsonToken.StartObject);
          _bsonReaderState = BsonReaderState.CodeWScopeStart;
          break;
        case BsonType.Integer:
          SetToken(JsonToken.Integer, (long) ReadInt32());
          break;
        case BsonType.TimeStamp:
        case BsonType.Long:
          SetToken(JsonToken.Integer, ReadInt64());
          break;
        default:
          throw new ArgumentOutOfRangeException("type", "Unexpected BsonType value: " + type);
      }
    }

    private byte[] ReadBinary()
    {
      int dataLength = ReadInt32();

      BsonBinaryType binaryType = (BsonBinaryType) ReadByte();

#pragma warning disable 612,618
      // the old binary type has the data length repeated in the data for some reason
      if (binaryType == BsonBinaryType.Data && !_jsonNet35BinaryCompatibility)
      {
        dataLength = ReadInt32();
      }
#pragma warning restore 612,618

      return ReadBytes(dataLength);
    }

    private string ReadString()
    {
      EnsureBuffers();

      StringBuilder builder = null;

      int totalBytesRead = 0;
      // used in case of left over multibyte characters in the buffer
      int offset = 0;
      do
      {
        int count = offset;
        byte b;
        while (count < MaxCharBytesSize && (b = _reader.ReadByte()) > 0)
        {
          _byteBuffer[count++] = b;
        }
        int byteCount = count - offset;
        totalBytesRead += byteCount;

        if (count < MaxCharBytesSize && builder == null)
        {
          // pref optimization to avoid reading into a string builder
          // if string is smaller than the buffer then return it directly
          int length = Encoding.UTF8.GetChars(_byteBuffer, 0, byteCount, _charBuffer, 0);

          MovePosition(totalBytesRead + 1);
          return new string(_charBuffer, 0, length);
        }
        else
        {
          // calculate the index of the end of the last full character in the buffer
          int lastFullCharStop = GetLastFullCharStop(count - 1);

          int charCount = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);

          if (builder == null)
            builder = new StringBuilder(MaxCharBytesSize*2);

          builder.Append(_charBuffer, 0, charCount);

          if (lastFullCharStop < byteCount - 1)
          {
            offset = byteCount - lastFullCharStop - 1;
            // copy left over multi byte characters to beginning of buffer for next iteration
            Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, offset);
          }
          else
          {
            // reached end of string
            if (count < MaxCharBytesSize)
            {
              MovePosition(totalBytesRead + 1);
              return builder.ToString();
            }

            offset = 0;
          }
        }
      } while (true);
    }

    private string ReadLengthString()
    {
      int length = ReadInt32();

      MovePosition(length);

      string s = GetString(length - 1);
      _reader.ReadByte();

      return s;
    }

    private string GetString(int length)
    {
      if (length == 0)
        return string.Empty;

      EnsureBuffers();

      StringBuilder builder = null;

      int totalBytesRead = 0;

      // used in case of left over multibyte characters in the buffer
      int offset = 0;
      do
      {
        int count = ((length - totalBytesRead) > MaxCharBytesSize - offset)
                      ? MaxCharBytesSize - offset
                      : length - totalBytesRead;

        int byteCount = _reader.Read(_byteBuffer, offset, count);

        if (byteCount == 0)
          throw new EndOfStreamException("Unable to read beyond the end of the stream.");

        totalBytesRead += byteCount;

        // Above, byteCount is how many bytes we read this time.
        // Below, byteCount is how many bytes are in the _byteBuffer.
        byteCount += offset;

        if (byteCount == length)
        {
          // pref optimization to avoid reading into a string builder
          // first iteration and all bytes read then return string directly
          int charCount = Encoding.UTF8.GetChars(_byteBuffer, 0, byteCount, _charBuffer, 0);
          return new string(_charBuffer, 0, charCount);
        }
        else
        {
          int lastFullCharStop = GetLastFullCharStop(byteCount - 1);

          if (builder == null)
            builder = new StringBuilder(length);

          int charCount = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
          builder.Append(_charBuffer, 0, charCount);

          if (lastFullCharStop < byteCount - 1)
          {
            offset = byteCount - lastFullCharStop - 1;
            // copy left over multi byte characters to beginning of buffer for next iteration
            Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, offset);
          }
          else
          {
            offset = 0;
          }
        }
      } while (totalBytesRead < length);

      return builder.ToString();
    }

    private int GetLastFullCharStop(int start)
    {
      int lookbackPos = start;
      int bis = 0;
      while (lookbackPos >= 0)
      {
        bis = BytesInSequence(_byteBuffer[lookbackPos]);
        if (bis == 0)
        {
          lookbackPos--;
          continue;
        }
        else if (bis == 1)
        {
          break;
        }
        else
        {
          lookbackPos--;
          break;
        }
      }
      if (bis == start - lookbackPos)
      {
        //Full character.
        return start;
      }
      else
      {
        return lookbackPos;
      }
    }

    private int BytesInSequence(byte b)
    {
      if (b <= SeqRange1[1]) return 1;
      if (b >= SeqRange2[0] && b <= SeqRange2[1]) return 2;
      if (b >= SeqRange3[0] && b <= SeqRange3[1]) return 3;
      if (b >= SeqRange4[0] && b <= SeqRange4[1]) return 4;
      return 0;
    }

    private void EnsureBuffers()
    {
      if (_byteBuffer == null)
      {
        _byteBuffer = new byte[MaxCharBytesSize];
      }
      if (_charBuffer == null)
      {
        int charBufferSize = Encoding.UTF8.GetMaxCharCount(MaxCharBytesSize);
        _charBuffer = new char[charBufferSize];
      }
    }

    private double ReadDouble()
    {
      MovePosition(8);
      return _reader.ReadDouble();
    }

    private int ReadInt32()
    {
      MovePosition(4);
      return _reader.ReadInt32();
    }

    private long ReadInt64()
    {
      MovePosition(8);
      return _reader.ReadInt64();
    }

    private BsonType ReadType()
    {
      MovePosition(1);
      return (BsonType) _reader.ReadSByte();
    }

    private void MovePosition(int count)
    {
      _currentContext.Position += count;
    }

    private byte[] ReadBytes(int count)
    {
      MovePosition(count);
      return _reader.ReadBytes(count);
    }
  }
}
#endregion Bson_BsonReader.cs

/// ********   File: \Bson\BsonToken.cs
#region Bson_BsonToken.cs

namespace Newtonsoft.Json.Bson
{
  internal abstract class BsonToken
  {
    public abstract BsonType Type { get; }
    public BsonToken Parent { get; set; }
    public int CalculatedSize { get; set; }
  }

  internal class BsonObject : BsonToken, IEnumerable<BsonProperty>
  {
    private readonly List<BsonProperty> _children = new List<BsonProperty>();

    public void Add(string name, BsonToken token)
    {
      _children.Add(new BsonProperty { Name = new BsonString(name, false), Value = token });
      token.Parent = this;
    }

    public override BsonType Type
    {
      get { return BsonType.Object; }
    }

    public IEnumerator<BsonProperty> GetEnumerator()
    {
      return _children.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      return GetEnumerator();
    }
  }

  internal class BsonArray : BsonToken, IEnumerable<BsonToken>
  {
    private readonly List<BsonToken> _children = new List<BsonToken>();

    public void Add(BsonToken token)
    {
      _children.Add(token);
      token.Parent = this;
    }

    public override BsonType Type
    {
      get { return BsonType.Array; }
    }

    public IEnumerator<BsonToken> GetEnumerator()
    {
      return _children.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      return GetEnumerator();
    }
  }

  internal class BsonValue : BsonToken
  {
    private readonly object _value;
    private readonly BsonType _type;

    public BsonValue(object value, BsonType type)
    {
      _value = value;
      _type = type;
    }

    public object Value
    {
      get { return _value; }
    }

    public override BsonType Type
    {
      get { return _type; }
    }
  }

  internal class BsonString : BsonValue
  {
    public int ByteCount { get; set; }
    public bool IncludeLength { get; set; }

    public BsonString(object value, bool includeLength)
      : base(value, BsonType.String)
    {
      IncludeLength = includeLength;
    }
  }

  internal class BsonRegex : BsonToken
  {
    public BsonString Pattern { get; set; }
    public BsonString Options { get; set; }

    public BsonRegex(string pattern, string options)
    {
      Pattern = new BsonString(pattern, false);
      Options = new BsonString(options, false);
    }

    public override BsonType Type
    {
      get { return BsonType.Regex; }
    }
  }

  internal class BsonProperty
  {
    public BsonString Name { get; set; }
    public BsonToken Value { get; set; }
  }
}
#endregion Bson_BsonToken.cs

/// ********   File: \Bson\BsonType.cs
#region Bson_BsonType.cs

namespace Newtonsoft.Json.Bson
{
  internal enum BsonType : sbyte 
  {
    Number = 1,
    String = 2,
    Object = 3,
    Array = 4,
    Binary = 5,
    Undefined = 6,
    Oid = 7,
    Boolean = 8,
    Date = 9,
    Null = 10,
    Regex = 11,
    Reference = 12,
    Code = 13,
    Symbol = 14,
    CodeWScope = 15,
    Integer = 16,
    TimeStamp = 17,
    Long = 18,
    MinKey = -1,
    MaxKey = 127
  }
}
#endregion Bson_BsonType.cs

/// ********   File: \Bson\BsonWriter.cs
#region Bson_BsonWriter.cs

namespace Newtonsoft.Json.Bson
{
  /// <summary>
  /// Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
  /// </summary>
  public class BsonWriter : JsonWriter
  {
    private readonly BsonBinaryWriter _writer;

    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;

    /// <summary>
    /// Gets or sets the <see cref="DateTimeKind" /> used when writing <see cref="DateTime"/> values to BSON.
    /// When set to <see cref="DateTimeKind.Unspecified" /> no conversion will occur.
    /// </summary>
    /// <value>The <see cref="DateTimeKind" /> used when writing <see cref="DateTime"/> values to BSON.</value>
    public DateTimeKind DateTimeKindHandling
    {
      get { return _writer.DateTimeKindHandling; }
      set { _writer.DateTimeKindHandling = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonWriter"/> class.
    /// </summary>
    /// <param name="stream">The stream.</param>
    public BsonWriter(Stream stream)
    {
      ValidationUtils.ArgumentNotNull(stream, "stream");
      _writer = new BsonBinaryWriter(new BinaryWriter(stream));
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BsonWriter"/> class.
    /// </summary>
    /// <param name="writer">The writer.</param>
    public BsonWriter(BinaryWriter writer)
    {
      ValidationUtils.ArgumentNotNull(writer, "writer");
      _writer = new BsonBinaryWriter(writer);
    }

    /// <summary>
    /// Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
    /// </summary>
    public override void Flush()
    {
      _writer.Flush();
    }

    /// <summary>
    /// Writes the end.
    /// </summary>
    /// <param name="token">The token.</param>
    protected override void WriteEnd(JsonToken token)
    {
      base.WriteEnd(token);
      RemoveParent();

      if (Top == 0)
      {
        _writer.WriteToken(_root);
      }
    }

    /// <summary>
    /// Writes out a comment <code>/*...*/</code> containing the specified text.
    /// </summary>
    /// <param name="text">Text to place inside the comment.</param>
    public override void WriteComment(string text)
    {
      throw JsonWriterException.Create(this, "Cannot write JSON comment as BSON.", null);
    }

    /// <summary>
    /// Writes the start of a constructor with the given name.
    /// </summary>
    /// <param name="name">The name of the constructor.</param>
    public override void WriteStartConstructor(string name)
    {
      throw JsonWriterException.Create(this, "Cannot write JSON constructor as BSON.", null);
    }

    /// <summary>
    /// Writes raw JSON.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public override void WriteRaw(string json)
    {
      throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
    }

    /// <summary>
    /// Writes raw JSON where a value is expected and updates the writer's state.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public override void WriteRawValue(string json)
    {
      throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
    }

    /// <summary>
    /// Writes the beginning of a Json array.
    /// </summary>
    public override void WriteStartArray()
    {
      base.WriteStartArray();

      AddParent(new BsonArray());
    }

    /// <summary>
    /// Writes the beginning of a Json object.
    /// </summary>
    public override void WriteStartObject()
    {
      base.WriteStartObject();

      AddParent(new BsonObject());
    }

    /// <summary>
    /// Writes the property name of a name/value pair on a Json object.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    public override void WritePropertyName(string name)
    {
      base.WritePropertyName(name);

      _propertyName = name;
    }

    /// <summary>
    /// Closes this stream and the underlying stream.
    /// </summary>
    public override void Close()
    {
      base.Close();

      if (CloseOutput && _writer != null)
        _writer.Close();
    }

    private void AddParent(BsonToken container)
    {
      AddToken(container);
      _parent = container;
    }

    private void RemoveParent()
    {
      _parent = _parent.Parent;
    }

    private void AddValue(object value, BsonType type)
    {
      AddToken(new BsonValue(value, type));
    }

    internal void AddToken(BsonToken token)
    {
      if (_parent != null)
      {
        if (_parent is BsonObject)
        {
          ((BsonObject) _parent).Add(_propertyName, token);
          _propertyName = null;
        }
        else
        {
          ((BsonArray) _parent).Add(token);
        }
      }
      else
      {
        if (token.Type != BsonType.Object && token.Type != BsonType.Array)
          throw JsonWriterException.Create(this, "Error writing {0} value. BSON must start with an Object or Array.".FormatWith(CultureInfo.InvariantCulture, token.Type), null);

        _parent = token;
        _root = token;
      }
    }

    #region WriteValue methods

    /// <summary>
    /// Writes a null value.
    /// </summary>
    public override void WriteNull()
    {
      base.WriteNull();
      AddValue(null, BsonType.Null);
    }

    /// <summary>
    /// Writes an undefined value.
    /// </summary>
    public override void WriteUndefined()
    {
      base.WriteUndefined();
      AddValue(null, BsonType.Undefined);
    }

    /// <summary>
    /// Writes a <see cref="String"/> value.
    /// </summary>
    /// <param name="value">The <see cref="String"/> value to write.</param>
    public override void WriteValue(string value)
    {
      base.WriteValue(value);
      if (value == null)
        AddValue(null, BsonType.Null);
      else
        AddToken(new BsonString(value, true));
    }

    /// <summary>
    /// Writes a <see cref="Int32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int32"/> value to write.</param>
    public override void WriteValue(int value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt32"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(uint value)
    {
      if (value > int.MaxValue)
        throw JsonWriterException.Create(this, "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values.", null);

      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Int64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int64"/> value to write.</param>
    public override void WriteValue(long value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Long);
    }

    /// <summary>
    /// Writes a <see cref="UInt64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt64"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ulong value)
    {
      if (value > long.MaxValue)
        throw JsonWriterException.Create(this, "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values.", null);

      base.WriteValue(value);
      AddValue(value, BsonType.Long);
    }

    /// <summary>
    /// Writes a <see cref="Single"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Single"/> value to write.</param>
    public override void WriteValue(float value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Number);
    }

    /// <summary>
    /// Writes a <see cref="Double"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Double"/> value to write.</param>
    public override void WriteValue(double value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Number);
    }

    /// <summary>
    /// Writes a <see cref="Boolean"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Boolean"/> value to write.</param>
    public override void WriteValue(bool value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Boolean);
    }

    /// <summary>
    /// Writes a <see cref="Int16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int16"/> value to write.</param>
    public override void WriteValue(short value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt16"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ushort value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Char"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Char"/> value to write.</param>
    public override void WriteValue(char value)
    {
      base.WriteValue(value);
      string s = null;
#if !(NETFX_CORE || PORTABLE)
      s = value.ToString(CultureInfo.InvariantCulture);
#else
      s = value.ToString();
#endif
      AddToken(new BsonString(s, true));
    }

    /// <summary>
    /// Writes a <see cref="Byte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Byte"/> value to write.</param>
    public override void WriteValue(byte value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="SByte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="SByte"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(sbyte value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Decimal"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Decimal"/> value to write.</param>
    public override void WriteValue(decimal value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Number);
    }

    /// <summary>
    /// Writes a <see cref="DateTime"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to write.</param>
    public override void WriteValue(DateTime value)
    {
      base.WriteValue(value);
      value = JsonConvert.EnsureDateTime(value, DateTimeZoneHandling);
      AddValue(value, BsonType.Date);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Writes a <see cref="DateTimeOffset"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to write.</param>
    public override void WriteValue(DateTimeOffset value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Date);
    }
#endif

    /// <summary>
    /// Writes a <see cref="T:Byte[]"/> value.
    /// </summary>
    /// <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
    public override void WriteValue(byte[] value)
    {
      base.WriteValue(value);
      AddValue(value, BsonType.Binary);
    }

    /// <summary>
    /// Writes a <see cref="Guid"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to write.</param>
    public override void WriteValue(Guid value)
    {
      base.WriteValue(value);
      AddToken(new BsonString(value.ToString(), true));
    }

    /// <summary>
    /// Writes a <see cref="TimeSpan"/> value.
    /// </summary>
    /// <param name="value">The <see cref="TimeSpan"/> value to write.</param>
    public override void WriteValue(TimeSpan value)
    {
      base.WriteValue(value);
      AddToken(new BsonString(value.ToString(), true));
    }

    /// <summary>
    /// Writes a <see cref="Uri"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Uri"/> value to write.</param>
    public override void WriteValue(Uri value)
    {
      base.WriteValue(value);
      AddToken(new BsonString(value.ToString(), true));
    }

    #endregion

    /// <summary>
    /// Writes a <see cref="T:Byte[]"/> value that represents a BSON object id.
    /// </summary>
    /// <param name="value">The Object ID value to write.</param>
    public void WriteObjectId(byte[] value)
    {
      ValidationUtils.ArgumentNotNull(value, "value");

      if (value.Length != 12)
        throw JsonWriterException.Create(this, "An object id must be 12 bytes", null);

      // hack to update the writer state
      UpdateScopeWithFinishedValue();
      AutoComplete(JsonToken.Undefined);
      AddValue(value, BsonType.Oid);
    }

    /// <summary>
    /// Writes a BSON regex.
    /// </summary>
    /// <param name="pattern">The regex pattern.</param>
    /// <param name="options">The regex options.</param>
    public void WriteRegex(string pattern, string options)
    {
      ValidationUtils.ArgumentNotNull(pattern, "pattern");

      // hack to update the writer state
      UpdateScopeWithFinishedValue();
      AutoComplete(JsonToken.Undefined);
      AddToken(new BsonRegex(pattern, options));
    }
  }
}
#endregion Bson_BsonWriter.cs

/// ********   File: \Converters\BinaryConverter.cs
#region Converters_BinaryConverter.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Converters
{
#if !NET20
  internal interface IBinary
  {
    byte[] ToArray();
  }
#endif

  /// <summary>
  /// Converts a binary value to and from a base 64 string value.
  /// </summary>
  public class BinaryConverter : JsonConverter
  {
#if !NET20
    private const string BinaryTypeName = "System.Data.Linq.Binary";
#endif

    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      if (value == null)
      {
        writer.WriteNull();
        return;
      }

      byte[] data = GetByteArray(value);

      writer.WriteValue(data);
    }

    private byte[] GetByteArray(object value)
    {
#if !(NET20)
      if (value.GetType().AssignableToTypeName(BinaryTypeName))
      {
        IBinary binary = DynamicWrapper.CreateWrapper<IBinary>(value);
        return binary.ToArray();
      }
#endif
      if (value is SqlBinary)
        return ((SqlBinary) value).Value;

      throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      Type t = (ReflectionUtils.IsNullableType(objectType))
        ? Nullable.GetUnderlyingType(objectType)
        : objectType;

      if (reader.TokenType == JsonToken.Null)
      {
        if (!ReflectionUtils.IsNullable(objectType))
          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));

        return null;
      }

      byte[] data;

      if (reader.TokenType == JsonToken.StartArray)
      {
        data = ReadByteArray(reader);
      }
      else if (reader.TokenType == JsonToken.String)
      {
        // current token is already at base64 string
        // unable to call ReadAsBytes so do it the old fashion way
        string encodedData = reader.Value.ToString();
        data = Convert.FromBase64String(encodedData);
      }
      else
      {
        throw JsonSerializationException.Create(reader, "Unexpected token parsing binary. Expected String or StartArray, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
      }

      
#if !NET20
      if (t.AssignableToTypeName(BinaryTypeName))
        return Activator.CreateInstance(t, data);
#endif

      if (t == typeof(SqlBinary))
        return new SqlBinary(data);

      throw JsonSerializationException.Create(reader, "Unexpected object type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, objectType));
    }

    private byte[] ReadByteArray(JsonReader reader)
    {
      List<byte> byteList = new List<byte>();

      while (reader.Read())
      {
        switch (reader.TokenType)
        {
          case JsonToken.Integer:
            byteList.Add(Convert.ToByte(reader.Value, CultureInfo.InvariantCulture));
            break;
          case JsonToken.EndArray:
            return byteList.ToArray();
          case JsonToken.Comment:
            // skip
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when reading bytes: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
        }
      }

      throw JsonSerializationException.Create(reader, "Unexpected end when reading bytes.");
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
#if !NET20
      if (objectType.AssignableToTypeName(BinaryTypeName))
        return true;
#endif

      if (objectType == typeof(SqlBinary) || objectType == typeof(SqlBinary?))
        return true;

      return false;
    }
  }
}
#endif
#endregion Converters_BinaryConverter.cs

/// ********   File: \Converters\BsonObjectIdConverter.cs
#region Converters_BsonObjectIdConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="BsonObjectId"/> to and from JSON and BSON.
  /// </summary>
  public class BsonObjectIdConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      BsonObjectId objectId = (BsonObjectId) value;

      BsonWriter bsonWriter = writer as BsonWriter;
      if (bsonWriter != null)
      {
        bsonWriter.WriteObjectId(objectId.Value);
      }
      else
      {
        writer.WriteValue(objectId.Value);
      }
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      if (reader.TokenType != JsonToken.Bytes)
        throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      byte[] value = (byte[])reader.Value;

      return new BsonObjectId(value);
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return (objectType == typeof (BsonObjectId));
    }
  }
}
#endregion Converters_BsonObjectIdConverter.cs

/// ********   File: \Converters\CustomCreationConverter.cs
#region Converters_CustomCreationConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Create a custom object
  /// </summary>
  /// <typeparam name="T">The object type to convert.</typeparam>
  public abstract class CustomCreationConverter<T> : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      if (reader.TokenType == JsonToken.Null)
        return null;

      T value = Create(objectType);
      if (value == null)
        throw new JsonSerializationException("No object created.");

      serializer.Populate(reader, value);
      return value;
    }

    /// <summary>
    /// Creates an object which will then be populated by the serializer.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>The created object.</returns>
    public abstract T Create(Type objectType);

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return typeof (T).IsAssignableFrom(objectType);
    }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonConverter"/> can write JSON.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this <see cref="JsonConverter"/> can write JSON; otherwise, <c>false</c>.
    /// </value>
    public override bool CanWrite
    {
      get { return false; }
    }
  }
}
#endregion Converters_CustomCreationConverter.cs

/// ********   File: \Converters\DataSetConverter.cs
#region Converters_DataSetConverter.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="DataSet"/> to and from JSON.
  /// </summary>
  public class DataSetConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      DataSet dataSet = (DataSet)value;
      DefaultContractResolver resolver = serializer.ContractResolver as DefaultContractResolver;

      DataTableConverter converter = new DataTableConverter();

      writer.WriteStartObject();

      foreach (DataTable table in dataSet.Tables)
      {
        writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(table.TableName) : table.TableName);
        
        converter.WriteJson(writer, table, serializer);
      }

      writer.WriteEndObject();
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      DataSet ds = new DataSet();

      DataTableConverter converter = new DataTableConverter();

      reader.Read();

      while (reader.TokenType == JsonToken.PropertyName)
      {
        DataTable dt = (DataTable)converter.ReadJson(reader, typeof (DataTable), null, serializer);
        ds.Tables.Add(dt);

        reader.Read();
      }

      return ds;
    }

    /// <summary>
    /// Determines whether this instance can convert the specified value type.
    /// </summary>
    /// <param name="valueType">Type of the value.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type valueType)
    {
      return (valueType == typeof(DataSet));
    }
  }
}
#endif
#endregion Converters_DataSetConverter.cs

/// ********   File: \Converters\DataTableConverter.cs
#region Converters_DataTableConverter.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="DataTable"/> to and from JSON.
  /// </summary>
  public class DataTableConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      DataTable table = (DataTable)value;
      DefaultContractResolver resolver = serializer.ContractResolver as DefaultContractResolver;

      writer.WriteStartArray();

      foreach (DataRow row in table.Rows)
      {
        writer.WriteStartObject();
        foreach (DataColumn column in row.Table.Columns)
        {
          if (serializer.NullValueHandling == NullValueHandling.Ignore && (row[column] == null || row[column] == DBNull.Value))
            continue;

          writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(column.ColumnName) : column.ColumnName);
          serializer.Serialize(writer, row[column]);
        }
        writer.WriteEndObject();
      }

      writer.WriteEndArray();
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      DataTable dt;

      if (reader.TokenType == JsonToken.PropertyName)
      {
        dt = new DataTable((string)reader.Value);
        reader.Read();
      }
      else
      {
        dt = new DataTable();
      }

      reader.Read();

      while (reader.TokenType == JsonToken.StartObject)
      {
        DataRow dr = dt.NewRow();
        reader.Read();

        while (reader.TokenType == JsonToken.PropertyName)
        {
          string columnName = (string)reader.Value;

          reader.Read();

          if (!dt.Columns.Contains(columnName))
          {
            Type columnType = GetColumnDataType(reader.TokenType);
            dt.Columns.Add(new DataColumn(columnName, columnType));
          }

          dr[columnName] = reader.Value ?? DBNull.Value;
          reader.Read();
        }

        dr.EndEdit();
        dt.Rows.Add(dr);

        reader.Read();
      }

      return dt;
    }

    private static Type GetColumnDataType(JsonToken tokenType)
    {
      switch (tokenType)
      {
        case JsonToken.Integer:
          return typeof (long);
        case JsonToken.Float:
          return typeof (double);
        case JsonToken.String:
        case JsonToken.Null:
        case JsonToken.Undefined:
          return typeof (string);
        case JsonToken.Boolean:
          return typeof (bool);
        case JsonToken.Date:
          return typeof (DateTime);
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>
    /// Determines whether this instance can convert the specified value type.
    /// </summary>
    /// <param name="valueType">Type of the value.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type valueType)
    {
      return (valueType == typeof(DataTable));
    }
  }
}
#endif
#endregion Converters_DataTableConverter.cs

/// ********   File: \Converters\DateTimeConverterBase.cs
#region Converters_DateTimeConverterBase.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Provides a base class for converting a <see cref="DateTime"/> to and from JSON.
  /// </summary>
  public abstract class DateTimeConverterBase : JsonConverter
  {
    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      if (objectType == typeof(DateTime) || objectType == typeof(DateTime?))
        return true;
#if !PocketPC && !NET20
      if (objectType == typeof(DateTimeOffset) || objectType == typeof(DateTimeOffset?))
        return true;
#endif

      return false;
    }
  }
}
#endregion Converters_DateTimeConverterBase.cs

/// ********   File: \Converters\EntityKeyMemberConverter.cs
#region Converters_EntityKeyMemberConverter.cs

#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Converters
{
  internal interface IEntityKeyMember
  {
    string Key { get; set; }
    object Value { get; set; }
  }

  /// <summary>
  /// Converts an Entity Framework EntityKey to and from JSON.
  /// </summary>
  public class EntityKeyMemberConverter : JsonConverter
  {
    private const string EntityKeyMemberFullTypeName = "System.Data.EntityKeyMember";

    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      IEntityKeyMember entityKeyMember = DynamicWrapper.CreateWrapper<IEntityKeyMember>(value);
      Type keyType = (entityKeyMember.Value != null) ? entityKeyMember.Value.GetType() : null;

      writer.WriteStartObject();
      writer.WritePropertyName("Key");
      writer.WriteValue(entityKeyMember.Key);
      writer.WritePropertyName("Type");
      writer.WriteValue((keyType != null) ? keyType.FullName : null);

      writer.WritePropertyName("Value");

      if (keyType != null)
      {
        string valueJson;
        if (JsonSerializerInternalWriter.TryConvertToString(entityKeyMember.Value, keyType, out valueJson))
          writer.WriteValue(valueJson);
        else
          writer.WriteValue(entityKeyMember.Value);
      }
      else
      {
        writer.WriteNull();
      }

      writer.WriteEndObject();
    }

    private static void ReadAndAssertProperty(JsonReader reader, string propertyName)
    {
      ReadAndAssert(reader);

      if (reader.TokenType != JsonToken.PropertyName || reader.Value.ToString() != propertyName)
        throw new JsonSerializationException("Expected JSON property '{0}'.".FormatWith(CultureInfo.InvariantCulture, propertyName));
    }

    private static void ReadAndAssert(JsonReader reader)
    {
      if (!reader.Read())
        throw new JsonSerializationException("Unexpected end.");
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      IEntityKeyMember entityKeyMember = DynamicWrapper.CreateWrapper<IEntityKeyMember>(Activator.CreateInstance(objectType));

      ReadAndAssertProperty(reader, "Key");
      ReadAndAssert(reader);
      entityKeyMember.Key = reader.Value.ToString();

      ReadAndAssertProperty(reader, "Type");
      ReadAndAssert(reader);
      string type = reader.Value.ToString();

      Type t = Type.GetType(type);

      ReadAndAssertProperty(reader, "Value");
      ReadAndAssert(reader);
      entityKeyMember.Value = serializer.Deserialize(reader, t);

      ReadAndAssert(reader);

      return DynamicWrapper.GetUnderlyingObject(entityKeyMember);
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return (objectType.AssignableToTypeName(EntityKeyMemberFullTypeName));
    }
  }
}
#endif
#endregion Converters_EntityKeyMemberConverter.cs

/// ********   File: \Converters\ExpandoObjectConverter.cs
#region Converters_ExpandoObjectConverter.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts an ExpandoObject to and from JSON.
  /// </summary>
  public class ExpandoObjectConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      // can write is set to false
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      return ReadValue(reader);
    }

    private object ReadValue(JsonReader reader)
    {
      while (reader.TokenType == JsonToken.Comment)
      {
        if (!reader.Read())
          throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
      }

      switch (reader.TokenType)
      {
        case JsonToken.StartObject:
          return ReadObject(reader);
        case JsonToken.StartArray:
          return ReadList(reader);
        default:
          if (JsonReader.IsPrimitiveToken(reader.TokenType))
            return reader.Value;

          throw JsonSerializationException.Create(reader, "Unexpected token when converting ExpandoObject: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
      }
    }

    private object ReadList(JsonReader reader)
    {
      IList<object> list = new List<object>();

      while (reader.Read())
      {
        switch (reader.TokenType)
        {
          case JsonToken.Comment:
            break;
          default:
            object v = ReadValue(reader);

            list.Add(v);
            break;
          case JsonToken.EndArray:
            return list;
        }
      }

      throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
    }

    private object ReadObject(JsonReader reader)
    {
      IDictionary<string, object> expandoObject = new ExpandoObject();

      while (reader.Read())
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            string propertyName = reader.Value.ToString();

            if (!reader.Read())
              throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");

            object v = ReadValue(reader);

            expandoObject[propertyName] = v;
            break;
          case JsonToken.Comment:
            break;
          case JsonToken.EndObject:
            return expandoObject;
        }
      }

      throw JsonSerializationException.Create(reader, "Unexpected end when reading ExpandoObject.");
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return (objectType == typeof (ExpandoObject));
    }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonConverter"/> can write JSON.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this <see cref="JsonConverter"/> can write JSON; otherwise, <c>false</c>.
    /// </value>
    public override bool CanWrite
    {
      get { return false; }
    }
  }
}

#endif
#endregion Converters_ExpandoObjectConverter.cs

/// ********   File: \Converters\IsoDateTimeConverter.cs
#region Converters_IsoDateTimeConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="DateTime"/> to and from the ISO 8601 date format (e.g. 2008-04-12T12:53Z).
  /// </summary>
  public class IsoDateTimeConverter : DateTimeConverterBase
  {
    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
    private string _dateTimeFormat;
    private CultureInfo _culture;

    /// <summary>
    /// Gets or sets the date time styles used when converting a date to and from JSON.
    /// </summary>
    /// <value>The date time styles used when converting a date to and from JSON.</value>
    public DateTimeStyles DateTimeStyles
    {
      get { return _dateTimeStyles; }
      set { _dateTimeStyles = value; }
    }

    /// <summary>
    /// Gets or sets the date time format used when converting a date to and from JSON.
    /// </summary>
    /// <value>The date time format used when converting a date to and from JSON.</value>
    public string DateTimeFormat
    {
      get { return _dateTimeFormat ?? string.Empty; }
      set { _dateTimeFormat = StringUtils.NullEmptyString(value); }
    }

    /// <summary>
    /// Gets or sets the culture used when converting a date to and from JSON.
    /// </summary>
    /// <value>The culture used when converting a date to and from JSON.</value>
    public CultureInfo Culture
    {
      get { return _culture ?? CultureInfo.CurrentCulture; }
      set { _culture = value; }
    }

    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      string text;

      if (value is DateTime)
      {
        DateTime dateTime = (DateTime)value;

        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
          || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
          dateTime = dateTime.ToUniversalTime();

        text = dateTime.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);
      }
#if !PocketPC && !NET20
      else if (value is DateTimeOffset)
      {
        DateTimeOffset dateTimeOffset = (DateTimeOffset)value;
        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
          || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
          dateTimeOffset = dateTimeOffset.ToUniversalTime();

        text = dateTimeOffset.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);
      }
#endif
      else
      {
        throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith(CultureInfo.InvariantCulture, ReflectionUtils.GetObjectType(value)));
      }

      writer.WriteValue(text);
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      bool nullable = ReflectionUtils.IsNullableType(objectType);
      Type t = (nullable)
        ? Nullable.GetUnderlyingType(objectType)
        : objectType;

      if (reader.TokenType == JsonToken.Null)
      {
        if (!ReflectionUtils.IsNullableType(objectType))
          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
 
        return null;
      }

      if (reader.TokenType == JsonToken.Date)
      {
#if !PocketPC && !NET20
        if (t == typeof(DateTimeOffset))
          return new DateTimeOffset((DateTime)reader.Value);
#endif

        return reader.Value;
      }

      if (reader.TokenType != JsonToken.String)
        throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      string dateText = reader.Value.ToString();

      if (string.IsNullOrEmpty(dateText) && nullable)
        return null;

#if !PocketPC && !NET20
      if (t == typeof(DateTimeOffset))
      {
        if (!string.IsNullOrEmpty(_dateTimeFormat))
          return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
        else
          return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
      }
#endif

      if (!string.IsNullOrEmpty(_dateTimeFormat))
        return DateTime.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
      else
        return DateTime.Parse(dateText, Culture, _dateTimeStyles);
    }
  }
}
#endregion Converters_IsoDateTimeConverter.cs

/// ********   File: \Converters\JavaScriptDateTimeConverter.cs
#region Converters_JavaScriptDateTimeConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="DateTime"/> to and from a JavaScript date constructor (e.g. new Date(52231943)).
  /// </summary>
  public class JavaScriptDateTimeConverter : DateTimeConverterBase
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      long ticks;

      if (value is DateTime)
      {
        DateTime dateTime = (DateTime)value;
        DateTime utcDateTime = dateTime.ToUniversalTime();
        ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(utcDateTime);
      }
#if !PocketPC && !NET20
      else if (value is DateTimeOffset)
      {
        DateTimeOffset dateTimeOffset = (DateTimeOffset)value;
        DateTimeOffset utcDateTimeOffset = dateTimeOffset.ToUniversalTime();
        ticks = JsonConvert.ConvertDateTimeToJavaScriptTicks(utcDateTimeOffset.UtcDateTime);
      }
#endif
      else
      {
        throw new JsonSerializationException("Expected date object value.");
      }

      writer.WriteStartConstructor("Date");
      writer.WriteValue(ticks);
      writer.WriteEndConstructor();
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing property value of the JSON that is being converted.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      Type t = (ReflectionUtils.IsNullableType(objectType))
        ? Nullable.GetUnderlyingType(objectType)
        : objectType;

      if (reader.TokenType == JsonToken.Null)
      {
        if (!ReflectionUtils.IsNullable(objectType))
          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));

        return null;
      }

      if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
        throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));

      reader.Read();

      if (reader.TokenType != JsonToken.Integer)
        throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      long ticks = (long)reader.Value;

      DateTime d = JsonConvert.ConvertJavaScriptTicksToDateTime(ticks);

      reader.Read();

      if (reader.TokenType != JsonToken.EndConstructor)
        throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected EndConstructor, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

#if !PocketPC && !NET20
      if (t == typeof(DateTimeOffset))
        return new DateTimeOffset(d);
#endif

      return d;
    }
  }
}
#endregion Converters_JavaScriptDateTimeConverter.cs

/// ********   File: \Converters\KeyValuePairConverter.cs
#region Converters_KeyValuePairConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="KeyValuePair{TKey,TValue}"/> to and from JSON.
  /// </summary>
  public class KeyValuePairConverter : JsonConverter
  {
    private const string KeyName = "Key";
    private const string ValueName = "Value";

    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      Type t = value.GetType();
      PropertyInfo keyProperty = t.GetProperty(KeyName);
      PropertyInfo valueProperty = t.GetProperty(ValueName);

      DefaultContractResolver resolver = serializer.ContractResolver as DefaultContractResolver;

      writer.WriteStartObject();

      writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(KeyName) : KeyName);
      serializer.Serialize(writer, ReflectionUtils.GetMemberValue(keyProperty, value));
      writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(ValueName) : ValueName);
      serializer.Serialize(writer, ReflectionUtils.GetMemberValue(valueProperty, value));
      writer.WriteEndObject();
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      bool isNullable = ReflectionUtils.IsNullableType(objectType);

      if (reader.TokenType == JsonToken.Null)
      {
        if (!isNullable)
          throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");

        return null;
      }

      Type t = (isNullable)
       ? Nullable.GetUnderlyingType(objectType)
       : objectType;

      IList<Type> genericArguments = t.GetGenericArguments();
      Type keyType = genericArguments[0];
      Type valueType = genericArguments[1];

      object key = null;
      object value = null;

      reader.Read();

      while (reader.TokenType == JsonToken.PropertyName)
      {
        string propertyName = reader.Value.ToString();
        if (string.Equals(propertyName, KeyName, StringComparison.OrdinalIgnoreCase))
        {
          reader.Read();
          key = serializer.Deserialize(reader, keyType);
        }
        else if (string.Equals(propertyName, ValueName, StringComparison.OrdinalIgnoreCase))
        {
          reader.Read();
          value = serializer.Deserialize(reader, valueType);
        }
        else
        {
          reader.Skip();
        }

        reader.Read();
      }

      return ReflectionUtils.CreateInstance(t, key, value);
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      Type t = (ReflectionUtils.IsNullableType(objectType))
        ? Nullable.GetUnderlyingType(objectType)
        : objectType;

      if (t.IsValueType() && t.IsGenericType())
        return (t.GetGenericTypeDefinition() == typeof(KeyValuePair<,>));

      return false;
    }
  }
}
#endregion Converters_KeyValuePairConverter.cs

/// ********   File: \Converters\RegexConverter.cs
#region Converters_RegexConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="Regex"/> to and from JSON and BSON.
  /// </summary>
  public class RegexConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      Regex regex = (Regex) value;

      BsonWriter bsonWriter = writer as BsonWriter;
      if (bsonWriter != null)
        WriteBson(bsonWriter, regex);
      else
        WriteJson(writer, regex);
    }

    private bool HasFlag(RegexOptions options, RegexOptions flag)
    {
      return ((options & flag) == flag);
    }

    private void WriteBson(BsonWriter writer, Regex regex)
    {
      // Regular expression - The first cstring is the regex pattern, the second
      // is the regex options string. Options are identified by characters, which 
      // must be stored in alphabetical order. Valid options are 'i' for case 
      // insensitive matching, 'm' for multiline matching, 'x' for verbose mode, 
      // 'l' to make \w, \W, etc. locale dependent, 's' for dotall mode 
      // ('.' matches everything), and 'u' to make \w, \W, etc. match unicode.

      string options = null;

      if (HasFlag(regex.Options, RegexOptions.IgnoreCase))
        options += "i";

      if (HasFlag(regex.Options, RegexOptions.Multiline))
        options += "m";

      if (HasFlag(regex.Options, RegexOptions.Singleline))
        options += "s";

      options += "u";

      if (HasFlag(regex.Options, RegexOptions.ExplicitCapture))
        options += "x";

      writer.WriteRegex(regex.ToString(), options);
    }

    private void WriteJson(JsonWriter writer, Regex regex)
    {
      writer.WriteStartObject();
      writer.WritePropertyName("Pattern");
      writer.WriteValue(regex.ToString());
      writer.WritePropertyName("Options");
      writer.WriteValue(regex.Options);
      writer.WriteEndObject();
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      BsonReader bsonReader = reader as BsonReader;

      if (bsonReader != null)
        return ReadBson(bsonReader);
      else
        return ReadJson(reader);
    }

    private object ReadBson(BsonReader reader)
    {
      string regexText = (string)reader.Value;
      int patternOptionDelimiterIndex = regexText.LastIndexOf('/');

      string patternText = regexText.Substring(1, patternOptionDelimiterIndex - 1);
      string optionsText = regexText.Substring(patternOptionDelimiterIndex + 1);

      RegexOptions options = RegexOptions.None;
      foreach (char c in optionsText)
      {
        switch (c)
        {
          case 'i':
            options |= RegexOptions.IgnoreCase;
            break;
          case 'm':
            options |= RegexOptions.Multiline;
            break;
          case 's':
            options |= RegexOptions.Singleline;
            break;
          case 'x':
            options |= RegexOptions.ExplicitCapture;
            break;
        }
      }

      return new Regex(patternText, options);
    }

    private Regex ReadJson(JsonReader reader)
    {
      reader.Read();
      reader.Read();
      string pattern = (string)reader.Value;

      reader.Read();
      reader.Read();
      int options = Convert.ToInt32(reader.Value, CultureInfo.InvariantCulture);

      reader.Read();

      return new Regex(pattern, (RegexOptions) options);
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return (objectType == typeof (Regex));
    }
  }
}
#endregion Converters_RegexConverter.cs

/// ********   File: \Converters\StringEnumConverter.cs
#region Converters_StringEnumConverter.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts an <see cref="Enum"/> to and from its name string value.
  /// </summary>
  public class StringEnumConverter : JsonConverter
  {
    private readonly Dictionary<Type, BidirectionalDictionary<string, string>> _enumMemberNamesPerType = new Dictionary<Type, BidirectionalDictionary<string, string>>();

    /// <summary>
    /// Gets or sets a value indicating whether the written enum text should be camel case.
    /// </summary>
    /// <value><c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
    public bool CamelCaseText { get; set; }
    
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      if (value == null)
      {
        writer.WriteNull();
        return;
      }

      Enum e = (Enum)value;

      string enumName = e.ToString("G");

      if (char.IsNumber(enumName[0]) || enumName[0] == '-')
      {
        writer.WriteValue(value);
      }
      else
      {
        BidirectionalDictionary<string, string> map = GetEnumNameMap(e.GetType());

        string resolvedEnumName;
        map.TryGetByFirst(enumName, out resolvedEnumName);
        resolvedEnumName = resolvedEnumName ?? enumName;

        if (CamelCaseText)
        {
          string[] names = resolvedEnumName.Split(',').Select(item => StringUtils.ToCamelCase(item.Trim())).ToArray();
          resolvedEnumName = string.Join(", ", names);
        }

        writer.WriteValue(resolvedEnumName);
      }
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      Type t = (ReflectionUtils.IsNullableType(objectType))
      ? Nullable.GetUnderlyingType(objectType)
      : objectType;

      if (reader.TokenType == JsonToken.Null)
      {
        if (!ReflectionUtils.IsNullableType(objectType))
          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));

        return null;
      }

      if (reader.TokenType == JsonToken.String)
      {
        var map = GetEnumNameMap(t);
        string resolvedEnumName;
        map.TryGetBySecond(reader.Value.ToString(), out resolvedEnumName);
        resolvedEnumName = resolvedEnumName ?? reader.Value.ToString();

        return Enum.Parse(t, resolvedEnumName, true);
      }

      if (reader.TokenType == JsonToken.Integer)
        return ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, t);

      throw JsonSerializationException.Create(reader, "Unexpected token when parsing enum. Expected String or Integer, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
    }

    /// <summary>
    /// A cached representation of the Enum string representation to respect per Enum field name.
    /// </summary>
    /// <param name="t">The type of the Enum.</param>
    /// <returns>A map of enum field name to either the field name, or the configured enum member name (<see cref="EnumMemberAttribute"/>).</returns>
    private BidirectionalDictionary<string, string> GetEnumNameMap(Type t)
    {
      BidirectionalDictionary<string, string> map;

      if (!_enumMemberNamesPerType.TryGetValue(t, out map))
      {
        lock (_enumMemberNamesPerType)
        {
          if (_enumMemberNamesPerType.TryGetValue(t, out map))
            return map;

          map = new BidirectionalDictionary<string, string>(
            StringComparer.OrdinalIgnoreCase,
            StringComparer.OrdinalIgnoreCase);

          foreach (FieldInfo f in t.GetFields())
          {
            string n1 = f.Name;
            string n2;
            
#if !NET20
            n2 = f.GetCustomAttributes(typeof (EnumMemberAttribute), true)
                          .Cast<EnumMemberAttribute>()
                          .Select(a => a.Value)
                          .SingleOrDefault() ?? f.Name;
#else
            n2 = f.Name;
#endif

            string s;
            if (map.TryGetBySecond(n2, out s))
            {
              throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'."
                .FormatWith(CultureInfo.InvariantCulture, n2, t.Name));
            }

            map.Set(n1, n2);
          }

          _enumMemberNamesPerType[t] = map;
        }
      }

      return map;
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      Type t = (ReflectionUtils.IsNullableType(objectType))
      ? Nullable.GetUnderlyingType(objectType)
      : objectType;

      return t.IsEnum();
    }
  }
}
#endregion Converters_StringEnumConverter.cs

/// ********   File: \Converters\VersionConverter.cs
#region Converters_VersionConverter.cs

namespace Newtonsoft.Json.Converters
{
  /// <summary>
  /// Converts a <see cref="Version"/> to and from a string (e.g. "1.2.3.4").
  /// </summary>
  public class VersionConverter : JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      if (value == null)
      {
        writer.WriteNull();
      }
      else if (value is Version)
      {
        writer.WriteValue(value.ToString());
      }
      else
      {
        throw new JsonSerializationException("Expected Version object value");
      }
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing property value of the JSON that is being converted.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      if (reader.TokenType == JsonToken.Null)
      {
        return null;
      }
      else
      {
        if (reader.TokenType == JsonToken.String)
        {
          try
          {
            Version v = new Version((string) reader.Value);
            return v;
          }
          catch (Exception ex)
          {
            throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture, reader.Value), ex);
          }
        }
        else
        {
          throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
        }
      }
    }

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type objectType)
    {
      return objectType == typeof (Version);
    }
  }
}
#endregion Converters_VersionConverter.cs

/// ********   File: \Converters\XmlNodeConverter.cs
#region Converters_XmlNodeConverter.cs

#if (!(SILVERLIGHT || PORTABLE) || WINDOWS_PHONE)
#if !NET20
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Converters
{
  #region XmlNodeWrappers
#if !SILVERLIGHT && !NETFX_CORE
  internal class XmlDocumentWrapper : XmlNodeWrapper, IXmlDocument
  {
    private readonly XmlDocument _document;

    public XmlDocumentWrapper(XmlDocument document)
      : base(document)
    {
      _document = document;
    }

    public IXmlNode CreateComment(string data)
    {
      return new XmlNodeWrapper(_document.CreateComment(data));
    }

    public IXmlNode CreateTextNode(string text)
    {
      return new XmlNodeWrapper(_document.CreateTextNode(text));
    }

    public IXmlNode CreateCDataSection(string data)
    {
      return new XmlNodeWrapper(_document.CreateCDataSection(data));
    }

    public IXmlNode CreateWhitespace(string text)
    {
      return new XmlNodeWrapper(_document.CreateWhitespace(text));
    }

    public IXmlNode CreateSignificantWhitespace(string text)
    {
      return new XmlNodeWrapper(_document.CreateSignificantWhitespace(text));
    }

    public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
    {
      return new XmlNodeWrapper(_document.CreateXmlDeclaration(version, encoding, standalone));
    }

    public IXmlNode CreateProcessingInstruction(string target, string data)
    {
      return new XmlNodeWrapper(_document.CreateProcessingInstruction(target, data));
    }

    public IXmlElement CreateElement(string elementName)
    {
      return new XmlElementWrapper(_document.CreateElement(elementName));
    }

    public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
    {
      return new XmlElementWrapper(_document.CreateElement(qualifiedName, namespaceUri));
    }

    public IXmlNode CreateAttribute(string name, string value)
    {
      XmlNodeWrapper attribute = new XmlNodeWrapper(_document.CreateAttribute(name));
      attribute.Value = value;

      return attribute;
    }

    public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
    {
      XmlNodeWrapper attribute = new XmlNodeWrapper(_document.CreateAttribute(qualifiedName, namespaceUri));
      attribute.Value = value;

      return attribute;
    }

    public IXmlElement DocumentElement
    {
      get
      {
        if (_document.DocumentElement == null)
          return null;

        return new XmlElementWrapper(_document.DocumentElement);
      }
    }
  }

  internal class XmlElementWrapper : XmlNodeWrapper, IXmlElement
  {
    private readonly XmlElement _element;

    public XmlElementWrapper(XmlElement element)
      : base(element)
    {
      _element = element;
    }

    public void SetAttributeNode(IXmlNode attribute)
    {
      XmlNodeWrapper xmlAttributeWrapper = (XmlNodeWrapper)attribute;

      _element.SetAttributeNode((XmlAttribute) xmlAttributeWrapper.WrappedNode);
    }

    public string GetPrefixOfNamespace(string namespaceUri)
    {
      return _element.GetPrefixOfNamespace(namespaceUri);
    }
  }

  internal class XmlDeclarationWrapper : XmlNodeWrapper, IXmlDeclaration
  {
    private readonly XmlDeclaration _declaration;

    public XmlDeclarationWrapper(XmlDeclaration declaration)
      : base(declaration)
    {
      _declaration = declaration;
    }

    public string Version
    {
      get { return _declaration.Version; }
    }

    public string Encoding
    {
      get { return _declaration.Encoding; }
      set { _declaration.Encoding = value; }
    }

    public string Standalone
    {
      get { return _declaration.Standalone; }
      set { _declaration.Standalone = value; }
    }
  }

  internal class XmlNodeWrapper : IXmlNode
  {
    private readonly XmlNode _node;

    public XmlNodeWrapper(XmlNode node)
    {
      _node = node;
    }

    public object WrappedNode
    {
      get { return _node; }
    }

    public XmlNodeType NodeType
    {
      get { return _node.NodeType; }
    }

    public string Name
    {
      get { return _node.Name; }
    }

    public string LocalName
    {
      get { return _node.LocalName; }
    }

    public IList<IXmlNode> ChildNodes
    {
      get { return _node.ChildNodes.Cast<XmlNode>().Select(n => WrapNode(n)).ToList(); }
    }

    private IXmlNode WrapNode(XmlNode node)
    {
      switch (node.NodeType)
      {
        case XmlNodeType.Element:
          return new XmlElementWrapper((XmlElement) node);
        case XmlNodeType.XmlDeclaration:
          return new XmlDeclarationWrapper((XmlDeclaration) node);
        default:
          return new XmlNodeWrapper(node);
      }
    }

    public IList<IXmlNode> Attributes
    {
      get
      {
        if (_node.Attributes == null)
          return null;

        return _node.Attributes.Cast<XmlAttribute>().Select(a => WrapNode(a)).ToList();
      }
    }

    public IXmlNode ParentNode
    {
      get
      {
        XmlNode node = (_node is XmlAttribute)
                         ? ((XmlAttribute) _node).OwnerElement
                         : _node.ParentNode;
        
        if (node == null)
          return null;

        return WrapNode(node);
      }
    }

    public string Value
    {
      get { return _node.Value; }
      set { _node.Value = value; }
    }

    public IXmlNode AppendChild(IXmlNode newChild)
    {
      XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper) newChild;
      _node.AppendChild(xmlNodeWrapper._node);

      return newChild;
    }

    public string Prefix
    {
      get { return _node.Prefix; }
    }

    public string NamespaceUri
    {
      get { return _node.NamespaceURI; }
    }
  }
#endif
  #endregion

  #region Interfaces
  internal interface IXmlDocument : IXmlNode
  {
    IXmlNode CreateComment(string text);
    IXmlNode CreateTextNode(string text);
    IXmlNode CreateCDataSection(string data);
    IXmlNode CreateWhitespace(string text);
    IXmlNode CreateSignificantWhitespace(string text);
    IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    IXmlNode CreateProcessingInstruction(string target, string data);
    IXmlElement CreateElement(string elementName);
    IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    IXmlNode CreateAttribute(string name, string value);
    IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);

    IXmlElement DocumentElement { get; }
  }

  internal interface IXmlDeclaration : IXmlNode
  {
    string Version { get; }
    string Encoding { get; set; }
    string Standalone { get; set; }
  }

  internal interface IXmlElement : IXmlNode
  {
    void SetAttributeNode(IXmlNode attribute);
    string GetPrefixOfNamespace(string namespaceUri);
  }

  internal interface IXmlNode
  {
    XmlNodeType NodeType { get; }
    string LocalName { get; }
    IList<IXmlNode> ChildNodes { get; }
    IList<IXmlNode> Attributes { get; }
    IXmlNode ParentNode { get; }
    string Value { get; set; }
    IXmlNode AppendChild(IXmlNode newChild);
    string NamespaceUri { get; }
    object WrappedNode { get; }
  }
  #endregion

  #region XNodeWrappers
#if !NET20
  internal class XDeclarationWrapper : XObjectWrapper, IXmlDeclaration
  {
    internal XDeclaration Declaration { get; private set; }

    public XDeclarationWrapper(XDeclaration declaration)
      : base(null)
    {
      Declaration = declaration;
    }

    public override XmlNodeType NodeType
    {
      get { return XmlNodeType.XmlDeclaration; }
    }

    public string Version
    {
      get { return Declaration.Version; }
    }

    public string Encoding
    {
      get { return Declaration.Encoding; }
      set { Declaration.Encoding = value; }
    }

    public string Standalone
    {
      get { return Declaration.Standalone; }
      set { Declaration.Standalone = value; }
    }
  }

  internal class XDocumentWrapper : XContainerWrapper, IXmlDocument
  {
    private XDocument Document
    {
      get { return (XDocument)WrappedNode; }
    }

    public XDocumentWrapper(XDocument document)
      : base(document)
    {
    }

    public override IList<IXmlNode> ChildNodes
    {
      get
      {
        IList<IXmlNode> childNodes = base.ChildNodes;

        if (Document.Declaration != null)
          childNodes.Insert(0, new XDeclarationWrapper(Document.Declaration));

        return childNodes;
      }
    }

    public IXmlNode CreateComment(string text)
    {
      return new XObjectWrapper(new XComment(text));
    }

    public IXmlNode CreateTextNode(string text)
    {
      return new XObjectWrapper(new XText(text));
    }

    public IXmlNode CreateCDataSection(string data)
    {
      return new XObjectWrapper(new XCData(data));
    }

    public IXmlNode CreateWhitespace(string text)
    {
      return new XObjectWrapper(new XText(text));
    }

    public IXmlNode CreateSignificantWhitespace(string text)
    {
      return new XObjectWrapper(new XText(text));
    }

    public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
    {
      return new XDeclarationWrapper(new XDeclaration(version, encoding, standalone));
    }

    public IXmlNode CreateProcessingInstruction(string target, string data)
    {
      return new XProcessingInstructionWrapper(new XProcessingInstruction(target, data));
    }

    public IXmlElement CreateElement(string elementName)
    {
      return new XElementWrapper(new XElement(elementName));
    }

    public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
    {
      string localName = MiscellaneousUtils.GetLocalName(qualifiedName);
      return new XElementWrapper(new XElement(XName.Get(localName, namespaceUri)));
    }

    public IXmlNode CreateAttribute(string name, string value)
    {
      return new XAttributeWrapper(new XAttribute(name, value));
    }

    public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
    {
      string localName = MiscellaneousUtils.GetLocalName(qualifiedName);
      return new XAttributeWrapper(new XAttribute(XName.Get(localName, namespaceUri), value));
    }

    public IXmlElement DocumentElement
    {
      get
      {
        if (Document.Root == null)
          return null;

        return new XElementWrapper(Document.Root);
      }
    }

    public override IXmlNode AppendChild(IXmlNode newChild)
    {
      XDeclarationWrapper declarationWrapper = newChild as XDeclarationWrapper;
      if (declarationWrapper != null)
      {
        Document.Declaration = declarationWrapper.Declaration;
        return declarationWrapper;
      }
      else
      {
        return base.AppendChild(newChild);
      }
    }
  }

  internal class XTextWrapper : XObjectWrapper
  {
    private XText Text
    {
      get { return (XText)WrappedNode; }
    }

    public XTextWrapper(XText text)
      : base(text)
    {
    }

    public override string Value
    {
      get { return Text.Value; }
      set { Text.Value = value; }
    }

    public override IXmlNode ParentNode
    {
      get
      {
        if (Text.Parent == null)
          return null;
        
        return XContainerWrapper.WrapNode(Text.Parent);
      }
    }
  }

  internal class XCommentWrapper : XObjectWrapper
  {
    private XComment Text
    {
      get { return (XComment)WrappedNode; }
    }

    public XCommentWrapper(XComment text)
      : base(text)
    {
    }

    public override string Value
    {
      get { return Text.Value; }
      set { Text.Value = value; }
    }

    public override IXmlNode ParentNode
    {
      get
      {
        if (Text.Parent == null)
          return null;

        return XContainerWrapper.WrapNode(Text.Parent);
      }
    }
  }

  internal class XProcessingInstructionWrapper : XObjectWrapper
  {
    private XProcessingInstruction ProcessingInstruction
    {
      get { return (XProcessingInstruction)WrappedNode; }
    }

    public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction)
      : base(processingInstruction)
    {
    }

    public override string LocalName
    {
      get { return ProcessingInstruction.Target; }
    }

    public override string Value
    {
      get { return ProcessingInstruction.Data; }
      set { ProcessingInstruction.Data = value; }
    }
  }

  internal class XContainerWrapper : XObjectWrapper
  {
    private XContainer Container
    {
      get { return (XContainer)WrappedNode; }
    }

    public XContainerWrapper(XContainer container)
      : base(container)
    {
    }

    public override IList<IXmlNode> ChildNodes
    {
      get { return Container.Nodes().Select(n => WrapNode(n)).ToList(); }
    }

    public override IXmlNode ParentNode
    {
      get
      {
        if (Container.Parent == null)
          return null;
        
        return WrapNode(Container.Parent);
      }
    }

    internal static IXmlNode WrapNode(XObject node)
    {
      if (node is XDocument)
        return new XDocumentWrapper((XDocument)node);
      else if (node is XElement)
        return new XElementWrapper((XElement)node);
      else if (node is XContainer)
        return new XContainerWrapper((XContainer)node);
      else if (node is XProcessingInstruction)
        return new XProcessingInstructionWrapper((XProcessingInstruction)node);
      else if (node is XText)
        return new XTextWrapper((XText)node);
      else if (node is XComment)
        return new XCommentWrapper((XComment)node);
      else if (node is XAttribute)
        return new XAttributeWrapper((XAttribute) node);
      else
        return new XObjectWrapper(node);
    }

    public override IXmlNode AppendChild(IXmlNode newChild)
    {
      Container.Add(newChild.WrappedNode);
      return newChild;
    }
  }

  internal class XObjectWrapper : IXmlNode
  {
    private readonly XObject _xmlObject;

    public XObjectWrapper(XObject xmlObject)
    {
      _xmlObject = xmlObject;
    }

    public object WrappedNode
    {
      get { return _xmlObject; }
    }

    public virtual XmlNodeType NodeType
    {
      get { return _xmlObject.NodeType; }
    }

    public virtual string LocalName
    {
      get { return null; }
    }

    public virtual IList<IXmlNode> ChildNodes
    {
      get { return new List<IXmlNode>(); }
    }

    public virtual IList<IXmlNode> Attributes
    {
      get { return null; }
    }

    public virtual IXmlNode ParentNode
    {
      get { return null; }
    }

    public virtual string Value
    {
      get { return null; }
      set { throw new InvalidOperationException(); }
    }

    public virtual IXmlNode AppendChild(IXmlNode newChild)
    {
      throw new InvalidOperationException();
    }

    public virtual string NamespaceUri
    {
      get { return null; }
    }
  }

  internal class XAttributeWrapper : XObjectWrapper
  {
    private XAttribute Attribute
    {
      get { return (XAttribute)WrappedNode; }
    }

    public XAttributeWrapper(XAttribute attribute)
      : base(attribute)
    {
    }

    public override string Value
    {
      get { return Attribute.Value; }
      set { Attribute.Value = value; }
    }

    public override string LocalName
    {
      get { return Attribute.Name.LocalName; }
    }

    public override string NamespaceUri
    {
      get { return Attribute.Name.NamespaceName; }
    }

    public override IXmlNode ParentNode
    {
      get
      {
        if (Attribute.Parent == null)
          return null;

        return XContainerWrapper.WrapNode(Attribute.Parent);
      }
    }
  }

  internal class XElementWrapper : XContainerWrapper, IXmlElement
  {
    private XElement Element
    {
      get { return (XElement) WrappedNode; }
    }

    public XElementWrapper(XElement element)
      : base(element)
    {
    }

    public void SetAttributeNode(IXmlNode attribute)
    {
      XObjectWrapper wrapper = (XObjectWrapper)attribute;
      Element.Add(wrapper.WrappedNode);
    }

    public override IList<IXmlNode> Attributes
    {
      get { return Element.Attributes().Select(a => new XAttributeWrapper(a)).Cast<IXmlNode>().ToList(); }
    }

    public override string Value
    {
      get { return Element.Value; }
      set { Element.Value = value; }
    }

    public override string LocalName
    {
      get { return Element.Name.LocalName; }
    }

    public override string NamespaceUri
    {
      get { return Element.Name.NamespaceName; }
    }

    public string GetPrefixOfNamespace(string namespaceUri)
    {
      return Element.GetPrefixOfNamespace(namespaceUri);
    }
  }
#endif
  #endregion

  /// <summary>
  /// Converts XML to and from JSON.
  /// </summary>
  public class XmlNodeConverter : JsonConverter
  {
    private const string TextName = "#text";
    private const string CommentName = "#comment";
    private const string CDataName = "#cdata-section";
    private const string WhitespaceName = "#whitespace";
    private const string SignificantWhitespaceName = "#significant-whitespace";
    private const string DeclarationName = "?xml";
    private const string JsonNamespaceUri = "http://james.newtonking.com/projects/json";

    /// <summary>
    /// Gets or sets the name of the root element to insert when deserializing to XML if the JSON structure has produces multiple root elements.
    /// </summary>
    /// <value>The name of the deserialize root element.</value>
    public string DeserializeRootElementName { get; set; }

    /// <summary>
    /// Gets or sets a flag to indicate whether to write the Json.NET array attribute.
    /// This attribute helps preserve arrays when converting the written XML back to JSON.
    /// </summary>
    /// <value><c>true</c> if the array attibute is written to the XML; otherwise, <c>false</c>.</value>
    public bool WriteArrayAttribute { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether to write the root JSON object.
    /// </summary>
    /// <value><c>true</c> if the JSON root object is omitted; otherwise, <c>false</c>.</value>
    public bool OmitRootObject { get; set; }

    #region Writing
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <param name="value">The value.</param>
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
      IXmlNode node = WrapXml(value);

      XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
      PushParentNamespaces(node, manager);

      if (!OmitRootObject)
        writer.WriteStartObject();

      SerializeNode(writer, node, manager, !OmitRootObject);
      
      if (!OmitRootObject)
        writer.WriteEndObject();
    }

    private IXmlNode WrapXml(object value)
    {
#if !NET20
      if (value is XObject)
        return XContainerWrapper.WrapNode((XObject)value);
#endif
#if !(SILVERLIGHT || NETFX_CORE)
      if (value is XmlNode)
        return new XmlNodeWrapper((XmlNode)value);
#endif
      
      throw new ArgumentException("Value must be an XML object.", "value");
    }

    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
    {
      List<IXmlNode> parentElements = null;

      IXmlNode parent = node;
      while ((parent = parent.ParentNode) != null)
      {
        if (parent.NodeType == XmlNodeType.Element)
        {
          if (parentElements == null)
            parentElements = new List<IXmlNode>();

          parentElements.Add(parent);
        }
      }

      if (parentElements != null)
      {
        parentElements.Reverse();

        foreach (IXmlNode parentElement in parentElements)
        {
          manager.PushScope();
          foreach (IXmlNode attribute in parentElement.Attributes)
          {
            if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/" && attribute.LocalName != "xmlns")
              manager.AddNamespace(attribute.LocalName, attribute.Value);
          }
        }
      }
    }

    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
    {
      string prefix = (node.NamespaceUri == null || (node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/"))
                        ? null
                        : manager.LookupPrefix(node.NamespaceUri);

      if (!string.IsNullOrEmpty(prefix))
        return prefix + ":" + node.LocalName;
      else
        return node.LocalName;
    }

    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
    {
      switch (node.NodeType)
      {
        case XmlNodeType.Attribute:
          if (node.NamespaceUri == JsonNamespaceUri)
            return "$" + node.LocalName;
          else
            return "@" + ResolveFullName(node, manager);
        case XmlNodeType.CDATA:
          return CDataName;
        case XmlNodeType.Comment:
          return CommentName;
        case XmlNodeType.Element:
          return ResolveFullName(node, manager);
        case XmlNodeType.ProcessingInstruction:
          return "?" + ResolveFullName(node, manager);
        case XmlNodeType.XmlDeclaration:
          return DeclarationName;
        case XmlNodeType.SignificantWhitespace:
          return SignificantWhitespaceName;
        case XmlNodeType.Text:
          return TextName;
        case XmlNodeType.Whitespace:
          return WhitespaceName;
        default:
          throw new JsonSerializationException("Unexpected XmlNodeType when getting node name: " + node.NodeType);
      }
    }

    private bool IsArray(IXmlNode node)
    {
      IXmlNode jsonArrayAttribute = (node.Attributes != null)
                                      ? node.Attributes.SingleOrDefault(a => a.LocalName == "Array" && a.NamespaceUri == JsonNamespaceUri)
                                      : null;
      
      return (jsonArrayAttribute != null && XmlConvert.ToBoolean(jsonArrayAttribute.Value));
    }

    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
    {
      // group nodes together by name
      Dictionary<string, List<IXmlNode>> nodesGroupedByName = new Dictionary<string, List<IXmlNode>>();

      for (int i = 0; i < node.ChildNodes.Count; i++)
      {
        IXmlNode childNode = node.ChildNodes[i];
        string nodeName = GetPropertyName(childNode, manager);

        List<IXmlNode> nodes;
        if (!nodesGroupedByName.TryGetValue(nodeName, out nodes))
        {
          nodes = new List<IXmlNode>();
          nodesGroupedByName.Add(nodeName, nodes);
        }

        nodes.Add(childNode);
      }

      // loop through grouped nodes. write single name instances as normal,
      // write multiple names together in an array
      foreach (KeyValuePair<string, List<IXmlNode>> nodeNameGroup in nodesGroupedByName)
      {
        List<IXmlNode> groupedNodes = nodeNameGroup.Value;
        bool writeArray;

        if (groupedNodes.Count == 1)
        {
          writeArray = IsArray(groupedNodes[0]);
        }
        else
        {
          writeArray = true;
        }

        if (!writeArray)
        {
          SerializeNode(writer, groupedNodes[0], manager, writePropertyName);
        }
        else
        {
          string elementNames = nodeNameGroup.Key;

          if (writePropertyName)
            writer.WritePropertyName(elementNames);

          writer.WriteStartArray();

          for (int i = 0; i < groupedNodes.Count; i++)
          {
            SerializeNode(writer, groupedNodes[i], manager, false);
          }

          writer.WriteEndArray();
        }
      }
    }

    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
    {
      switch (node.NodeType)
      {
        case XmlNodeType.Document:
        case XmlNodeType.DocumentFragment:
          SerializeGroupedNodes(writer, node, manager, writePropertyName);
          break;
        case XmlNodeType.Element:
          if (IsArray(node) && node.ChildNodes.All(n => n.LocalName == node.LocalName) && node.ChildNodes.Count > 0)
          {
            SerializeGroupedNodes(writer, node, manager, false);
          }
          else
          {
            foreach (IXmlNode attribute in node.Attributes)
            {
              if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/")
              {
                string prefix = (attribute.LocalName != "xmlns")
                                  ? attribute.LocalName
                                  : string.Empty;

                manager.AddNamespace(prefix, attribute.Value);
              }
            }

            if (writePropertyName)
              writer.WritePropertyName(GetPropertyName(node, manager));

            if (!ValueAttributes(node.Attributes).Any() && node.ChildNodes.Count == 1
                && node.ChildNodes[0].NodeType == XmlNodeType.Text)
            {
              // write elements with a single text child as a name value pair
              writer.WriteValue(node.ChildNodes[0].Value);
            }
            else if (node.ChildNodes.Count == 0 && CollectionUtils.IsNullOrEmpty(node.Attributes))
            {
              // empty element
              writer.WriteNull();
            }
            else
            {
              writer.WriteStartObject();

              for (int i = 0; i < node.Attributes.Count; i++)
              {
                SerializeNode(writer, node.Attributes[i], manager, true);
              }

              SerializeGroupedNodes(writer, node, manager, true);

              writer.WriteEndObject();
            }
          }

          break;
        case XmlNodeType.Comment:
          if (writePropertyName)
            writer.WriteComment(node.Value);
          break;
        case XmlNodeType.Attribute:
        case XmlNodeType.Text:
        case XmlNodeType.CDATA:
        case XmlNodeType.ProcessingInstruction:
        case XmlNodeType.Whitespace:
        case XmlNodeType.SignificantWhitespace:
          if (node.NamespaceUri == "http://www.w3.org/2000/xmlns/" && node.Value == JsonNamespaceUri)
            return;

          if (node.NamespaceUri == JsonNamespaceUri)
          {
            if (node.LocalName == "Array")
              return;
          }

          if (writePropertyName)
            writer.WritePropertyName(GetPropertyName(node, manager));
          writer.WriteValue(node.Value);
          break;
        case XmlNodeType.XmlDeclaration:
          IXmlDeclaration declaration = (IXmlDeclaration)node;
          writer.WritePropertyName(GetPropertyName(node, manager));
          writer.WriteStartObject();

          if (!string.IsNullOrEmpty(declaration.Version))
          {
            writer.WritePropertyName("@version");
            writer.WriteValue(declaration.Version);
          }
          if (!string.IsNullOrEmpty(declaration.Encoding))
          {
            writer.WritePropertyName("@encoding");
            writer.WriteValue(declaration.Encoding);
          }
          if (!string.IsNullOrEmpty(declaration.Standalone))
          {
            writer.WritePropertyName("@standalone");
            writer.WriteValue(declaration.Standalone);
          }

          writer.WriteEndObject();
          break;
        default:
          throw new JsonSerializationException("Unexpected XmlNodeType when serializing nodes: " + node.NodeType);
      }
    }
    #endregion

    #region Reading
    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
      XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
      IXmlDocument document = null;
      IXmlNode rootNode = null;

#if !NET20
      if (typeof(XObject).IsAssignableFrom(objectType))
      {
        if (objectType != typeof (XDocument) && objectType != typeof (XElement))
          throw new JsonSerializationException("XmlNodeConverter only supports deserializing XDocument or XElement.");

        XDocument d = new XDocument();
        document = new XDocumentWrapper(d);
        rootNode = document;
      }
#endif
#if !(SILVERLIGHT || NETFX_CORE)
      if (typeof(XmlNode).IsAssignableFrom(objectType))
      {
        if (objectType != typeof (XmlDocument))
          throw new JsonSerializationException("XmlNodeConverter only supports deserializing XmlDocuments");

        XmlDocument d = new XmlDocument();
        document = new XmlDocumentWrapper(d);
        rootNode = document;
      }
#endif
      
      if (document == null || rootNode == null)
        throw new JsonSerializationException("Unexpected type when converting XML: " + objectType);

      if (reader.TokenType != JsonToken.StartObject)
        throw new JsonSerializationException("XmlNodeConverter can only convert JSON that begins with an object.");

      if (!string.IsNullOrEmpty(DeserializeRootElementName))
      {
        //rootNode = document.CreateElement(DeserializeRootElementName);
        //document.AppendChild(rootNode);
        ReadElement(reader, document, rootNode, DeserializeRootElementName, manager);
      }
      else
      {
        reader.Read();
        DeserializeNode(reader, document, manager, rootNode);
      }

#if !NET20
      if (objectType == typeof(XElement))
      {
        XElement element = (XElement)document.DocumentElement.WrappedNode;
        element.Remove();

        return element;
      }
#endif

      return document.WrappedNode;
    }

    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
    {
      switch (propertyName)
      {
        case TextName:
          currentNode.AppendChild(document.CreateTextNode(reader.Value.ToString()));
          break;
        case CDataName:
          currentNode.AppendChild(document.CreateCDataSection(reader.Value.ToString()));
          break;
        case WhitespaceName:
          currentNode.AppendChild(document.CreateWhitespace(reader.Value.ToString()));
          break;
        case SignificantWhitespaceName:
          currentNode.AppendChild(document.CreateSignificantWhitespace(reader.Value.ToString()));
          break;
        default:
          // processing instructions and the xml declaration start with ?
          if (!string.IsNullOrEmpty(propertyName) && propertyName[0] == '?')
          {
            CreateInstruction(reader, document, currentNode, propertyName);
          }
          else
          {
            if (reader.TokenType == JsonToken.StartArray)
            {
              // handle nested arrays
              ReadArrayElements(reader, document, propertyName, currentNode, manager);
              return;
            }

            // have to wait until attributes have been parsed before creating element
            // attributes may contain namespace info used by the element
            ReadElement(reader, document, currentNode, propertyName, manager);
          }
          break;
      }
    }

    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
    {
      if (string.IsNullOrEmpty(propertyName))
        throw new JsonSerializationException("XmlNodeConverter cannot convert JSON with an empty property name to XML.");

      Dictionary<string, string> attributeNameValues = ReadAttributeElements(reader, manager);

      string elementPrefix = MiscellaneousUtils.GetPrefix(propertyName);

      if (propertyName.StartsWith("@"))
      {
        var attributeName = propertyName.Substring(1);
        var attributeValue = reader.Value.ToString();

        var attributePrefix = MiscellaneousUtils.GetPrefix(attributeName);

        var attribute = (!string.IsNullOrEmpty(attributePrefix))
                                 ? document.CreateAttribute(attributeName, manager.LookupNamespace(attributePrefix), attributeValue)
                                 : document.CreateAttribute(attributeName, attributeValue);

        ((IXmlElement)currentNode).SetAttributeNode(attribute);
      }
      else
      {
        IXmlElement element = CreateElement(propertyName, document, elementPrefix, manager);

        currentNode.AppendChild(element);

        // add attributes to newly created element
        foreach (KeyValuePair<string, string> nameValue in attributeNameValues)
        {
          string attributePrefix = MiscellaneousUtils.GetPrefix(nameValue.Key);

          IXmlNode attribute = (!string.IsNullOrEmpty(attributePrefix))
                                 ? document.CreateAttribute(nameValue.Key, manager.LookupNamespace(attributePrefix), nameValue.Value)
                                 : document.CreateAttribute(nameValue.Key, nameValue.Value);

          element.SetAttributeNode(attribute);
        }

        if (reader.TokenType == JsonToken.String
            || reader.TokenType == JsonToken.Integer
            || reader.TokenType == JsonToken.Float
            || reader.TokenType == JsonToken.Boolean
            || reader.TokenType == JsonToken.Date)
        {
          element.AppendChild(document.CreateTextNode(ConvertTokenToXmlValue(reader)));
        }
        else if (reader.TokenType == JsonToken.Null)
        {
          // empty element. do nothing
        }
        else
        {
          // finished element will have no children to deserialize
          if (reader.TokenType != JsonToken.EndObject)
          {
            manager.PushScope();

            DeserializeNode(reader, document, manager, element);

            manager.PopScope();
          }
        }
      }
    }

    private string ConvertTokenToXmlValue(JsonReader reader)
    {
      if (reader.TokenType == JsonToken.String)
      {
        return reader.Value.ToString();
      }
      else if (reader.TokenType == JsonToken.Integer)
      {
        return XmlConvert.ToString(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
      }
      else if (reader.TokenType == JsonToken.Float)
      {
        return XmlConvert.ToString(Convert.ToDouble(reader.Value, CultureInfo.InvariantCulture));
      }
      else if (reader.TokenType == JsonToken.Boolean)
      {
        return XmlConvert.ToString(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
      }
      else if (reader.TokenType == JsonToken.Date)
      {
        DateTime d = Convert.ToDateTime(reader.Value, CultureInfo.InvariantCulture);
#if !NETFX_CORE
        return XmlConvert.ToString(d, DateTimeUtils.ToSerializationMode(d.Kind));
#else
        return XmlConvert.ToString(d);
#endif   
      }
      else if (reader.TokenType == JsonToken.Null)
      {
        return null;
      }
      else
      {
        throw JsonSerializationException.Create(reader, "Cannot get an XML string value from token type '{0}'.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
      }
    }

    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
    {
      string elementPrefix = MiscellaneousUtils.GetPrefix(propertyName);

      IXmlElement nestedArrayElement = CreateElement(propertyName, document, elementPrefix, manager);

      currentNode.AppendChild(nestedArrayElement);

      int count = 0;
      while (reader.Read() && reader.TokenType != JsonToken.EndArray)
      {
        DeserializeValue(reader, document, manager, propertyName, nestedArrayElement);
        count++;
      }

      if (WriteArrayAttribute)
      {
        AddJsonArrayAttribute(nestedArrayElement, document);
      }

      if (count == 1 && WriteArrayAttribute)
      {
        IXmlElement arrayElement = nestedArrayElement.ChildNodes.CastValid<IXmlElement>().Single(n => n.LocalName == propertyName);
        AddJsonArrayAttribute(arrayElement, document);
      }
    }

    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
    {
      element.SetAttributeNode(document.CreateAttribute("json:Array", JsonNamespaceUri, "true"));

#if !NET20
      // linq to xml doesn't automatically include prefixes via the namespace manager
      if (element is XElementWrapper)
      {
        if (element.GetPrefixOfNamespace(JsonNamespaceUri) == null)
        {
          element.SetAttributeNode(document.CreateAttribute("xmlns:json", "http://www.w3.org/2000/xmlns/", JsonNamespaceUri));
        }
      }
#endif
    }

    private Dictionary<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
    {
      Dictionary<string, string> attributeNameValues = new Dictionary<string, string>();
      bool finishedAttributes = false;
      bool finishedElement = false;

      // a string token means the element only has a single text child
      if (reader.TokenType != JsonToken.String
          && reader.TokenType != JsonToken.Null
          && reader.TokenType != JsonToken.Boolean
          && reader.TokenType != JsonToken.Integer
          && reader.TokenType != JsonToken.Float
          && reader.TokenType != JsonToken.Date
          && reader.TokenType != JsonToken.StartConstructor)
      {
        // read properties until first non-attribute is encountered
        while (!finishedAttributes && !finishedElement && reader.Read())
        {
          switch (reader.TokenType)
          {
            case JsonToken.PropertyName:
              string attributeName = reader.Value.ToString();

              if (!string.IsNullOrEmpty(attributeName))
              {
                char firstChar = attributeName[0];
                string attributeValue;

                switch (firstChar)
                {
                  case '@':
                    attributeName = attributeName.Substring(1);
                    reader.Read();
                    attributeValue = ConvertTokenToXmlValue(reader);
                    attributeNameValues.Add(attributeName, attributeValue);

                    string namespacePrefix;
                    if (IsNamespaceAttribute(attributeName, out namespacePrefix))
                    {
                      manager.AddNamespace(namespacePrefix, attributeValue);
                    }
                    break;
                  case '$':
                    attributeName = attributeName.Substring(1);
                    reader.Read();
                    attributeValue = reader.Value.ToString();

                    // check that JsonNamespaceUri is in scope
                    // if it isn't then add it to document and namespace manager
                    string jsonPrefix = manager.LookupPrefix(JsonNamespaceUri);
                    if (jsonPrefix == null)
                    {
                      // ensure that the prefix used is free
                      int? i = null;
                      while (manager.LookupNamespace("json" + i) != null)
                      {
                        i = i.GetValueOrDefault() + 1;
                      }
                      jsonPrefix = "json" + i;

                      attributeNameValues.Add("xmlns:" + jsonPrefix, JsonNamespaceUri);
                      manager.AddNamespace(jsonPrefix, JsonNamespaceUri);
                    }

                    attributeNameValues.Add(jsonPrefix + ":" + attributeName, attributeValue);
                    break;
                  default:
                    finishedAttributes = true;
                    break;
                }
              }
              else
              {
                finishedAttributes = true;
              }

              break;
            case JsonToken.EndObject:
              finishedElement = true;
              break;
            default:
              throw new JsonSerializationException("Unexpected JsonToken: " + reader.TokenType);
          }
        }
      }

      return attributeNameValues;
    }

    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
    {
      if (propertyName == DeclarationName)
      {
        string version = null;
        string encoding = null;
        string standalone = null;
        while (reader.Read() && reader.TokenType != JsonToken.EndObject)
        {
          switch (reader.Value.ToString())
          {
            case "@version":
              reader.Read();
              version = reader.Value.ToString();
              break;
            case "@encoding":
              reader.Read();
              encoding = reader.Value.ToString();
              break;
            case "@standalone":
              reader.Read();
              standalone = reader.Value.ToString();
              break;
            default:
              throw new JsonSerializationException("Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
          }
        }

        IXmlNode declaration = document.CreateXmlDeclaration(version, encoding, standalone);
        currentNode.AppendChild(declaration);
      }
      else
      {
        IXmlNode instruction = document.CreateProcessingInstruction(propertyName.Substring(1), reader.Value.ToString());
        currentNode.AppendChild(instruction);
      }
    }

    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager)
    {
      string ns = string.IsNullOrEmpty(elementPrefix) ? manager.DefaultNamespace : manager.LookupNamespace(elementPrefix);

      IXmlElement element = (!string.IsNullOrEmpty(ns)) ? document.CreateElement(elementName, ns) : document.CreateElement(elementName);

      return element;
    }

    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
    {
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            if (currentNode.NodeType == XmlNodeType.Document && document.DocumentElement != null)
              throw new JsonSerializationException("JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifing a DeserializeRootElementName.");

            string propertyName = reader.Value.ToString();
            reader.Read();

            if (reader.TokenType == JsonToken.StartArray)
            {
              int count = 0;
              while (reader.Read() && reader.TokenType != JsonToken.EndArray)
              {
                DeserializeValue(reader, document, manager, propertyName, currentNode);
                count++;
              }

              if (count == 1 && WriteArrayAttribute)
              {
                IXmlElement arrayElement = currentNode.ChildNodes.CastValid<IXmlElement>().Single(n => n.LocalName == propertyName);
                AddJsonArrayAttribute(arrayElement, document);
              }
            }
            else
            {
              DeserializeValue(reader, document, manager, propertyName, currentNode);
            }
            break;
          case JsonToken.StartConstructor:
            string constructorName = reader.Value.ToString();

            while (reader.Read() && reader.TokenType != JsonToken.EndConstructor)
            {
              DeserializeValue(reader, document, manager, constructorName, currentNode);
            }
            break;
          case JsonToken.Comment:
            currentNode.AppendChild(document.CreateComment((string)reader.Value));
            break;
          case JsonToken.EndObject:
          case JsonToken.EndArray:
            return;
          default:
            throw new JsonSerializationException("Unexpected JsonToken when deserializing node: " + reader.TokenType);
        }
      } while (reader.TokenType == JsonToken.PropertyName || reader.Read());
      // don't read if current token is a property. token was already read when parsing element attributes
    }

    /// <summary>
    /// Checks if the attributeName is a namespace attribute.
    /// </summary>
    /// <param name="attributeName">Attribute name to test.</param>
    /// <param name="prefix">The attribute name prefix if it has one, otherwise an empty string.</param>
    /// <returns>True if attribute name is for a namespace attribute, otherwise false.</returns>
    private bool IsNamespaceAttribute(string attributeName, out string prefix)
    {
      if (attributeName.StartsWith("xmlns", StringComparison.Ordinal))
      {
        if (attributeName.Length == 5)
        {
          prefix = string.Empty;
          return true;
        }
        else if (attributeName[5] == ':')
        {
          prefix = attributeName.Substring(6, attributeName.Length - 6);
          return true;
        }
      }
      prefix = null;
      return false;
    }

    private IEnumerable<IXmlNode> ValueAttributes(IEnumerable<IXmlNode> c)
    {
      return c.Where(a => a.NamespaceUri != JsonNamespaceUri);
    }
    #endregion

    /// <summary>
    /// Determines whether this instance can convert the specified value type.
    /// </summary>
    /// <param name="valueType">Type of the value.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
    /// </returns>
    public override bool CanConvert(Type valueType)
    {
#if !NET20
      if (typeof(XObject).IsAssignableFrom(valueType))
        return true;
#endif
#if !(SILVERLIGHT || NETFX_CORE)
      if (typeof(XmlNode).IsAssignableFrom(valueType))
        return true;
#endif

      return false;
    }
  }
}
#endif
#endregion Converters_XmlNodeConverter.cs

/// ********   File: \Linq\Extensions.cs
#region Linq_Extensions.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Contains the LINQ to JSON extension methods.
  /// </summary>
  public static class Extensions
  {
    /// <summary>
    /// Returns a collection of tokens that contains the ancestors of every token in the source collection.
    /// </summary>
    /// <typeparam name="T">The type of the objects in source, constrained to <see cref="JToken"/>.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the ancestors of every node in the source collection.</returns>
    public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      return source.SelectMany(j => j.Ancestors()).AsJEnumerable();
    }

    //TODO
    //public static IEnumerable<JObject> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JObject
    //{
    //  ValidationUtils.ArgumentNotNull(source, "source");

    //  return source.SelectMany(j => j.AncestorsAndSelf());
    //}

    /// <summary>
    /// Returns a collection of tokens that contains the descendants of every token in the source collection.
    /// </summary>
    /// <typeparam name="T">The type of the objects in source, constrained to <see cref="JContainer"/>.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the descendants of every node in the source collection.</returns>
    public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      return source.SelectMany(j => j.Descendants()).AsJEnumerable();
    }

    //TODO
    //public static IEnumerable<JObject> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
    //{
    //  ValidationUtils.ArgumentNotNull(source, "source");

    //  return source.SelectMany(j => j.DescendantsAndSelf());
    //}

    /// <summary>
    /// Returns a collection of child properties of every object in the source collection.
    /// </summary>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JObject"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JProperty"/> that contains the properties of every object in the source collection.</returns>
    public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      return source.SelectMany(d => d.Properties()).AsJEnumerable();
    }

    /// <summary>
    /// Returns a collection of child values of every object in the source collection with the given key.
    /// </summary>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <param name="key">The token key.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the values of every node in the source collection with the given key.</returns>
    public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
    {
      return Values<JToken, JToken>(source, key).AsJEnumerable();
    }

    /// <summary>
    /// Returns a collection of child values of every object in the source collection.
    /// </summary>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the values of every node in the source collection.</returns>
    public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
    {
      return source.Values(null);
    }

    /// <summary>
    /// Returns a collection of converted child values of every object in the source collection with the given key.
    /// </summary>
    /// <typeparam name="U">The type to convert the values to.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <param name="key">The token key.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> that contains the converted values of every node in the source collection with the given key.</returns>
    public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
    {
      return Values<JToken, U>(source, key);
    }

    /// <summary>
    /// Returns a collection of converted child values of every object in the source collection.
    /// </summary>
    /// <typeparam name="U">The type to convert the values to.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> that contains the converted values of every node in the source collection.</returns>
    public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
    {
      return Values<JToken, U>(source, null);
    }

    /// <summary>
    /// Converts the value.
    /// </summary>
    /// <typeparam name="U">The type to convert the value to.</typeparam>
    /// <param name="value">A <see cref="JToken"/> cast as a <see cref="IEnumerable{T}"/> of <see cref="JToken"/>.</param>
    /// <returns>A converted value.</returns>
    public static U Value<U>(this IEnumerable<JToken> value)
    {
      return value.Value<JToken, U>();
    }

    /// <summary>
    /// Converts the value.
    /// </summary>
    /// <typeparam name="T">The source collection type.</typeparam>
    /// <typeparam name="U">The type to convert the value to.</typeparam>
    /// <param name="value">A <see cref="JToken"/> cast as a <see cref="IEnumerable{T}"/> of <see cref="JToken"/>.</param>
    /// <returns>A converted value.</returns>
    public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
    {
      ValidationUtils.ArgumentNotNull(value, "source");

      JToken token = value as JToken;
      if (token == null)
        throw new ArgumentException("Source value must be a JToken.");

      return token.Convert<JToken, U>();
    }

    internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      foreach (JToken token in source)
      {
        if (key == null)
        {
          if (token is JValue)
          {
            yield return Convert<JValue, U>((JValue)token);
          }
          else
          {
            foreach (JToken t in token.Children())
            {
              yield return t.Convert<JToken, U>();
            }
          }
        }
        else
        {
          JToken value = token[key];
          if (value != null)
            yield return value.Convert<JToken, U>();
        }
      }

      yield break;
    }

    //TODO
    //public static IEnumerable<T> InDocumentOrder<T>(this IEnumerable<T> source) where T : JObject;

    //public static IEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
    //{
    //  ValidationUtils.ArgumentNotNull(source, "source");

    //  return source.SelectMany(c => c.Children());
    //}

    /// <summary>
    /// Returns a collection of child tokens of every array in the source collection.
    /// </summary>
    /// <typeparam name="T">The source collection type.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the values of every node in the source collection.</returns>
    public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
    {
      return Children<T, JToken>(source).AsJEnumerable();
    }

    /// <summary>
    /// Returns a collection of converted child tokens of every array in the source collection.
    /// </summary>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <typeparam name="U">The type to convert the values to.</typeparam>
    /// <typeparam name="T">The source collection type.</typeparam>
    /// <returns>An <see cref="IEnumerable{T}"/> that contains the converted values of every node in the source collection.</returns>
    public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      return source.SelectMany(c => c.Children()).Convert<JToken, U>();
    }

    internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
    {
      ValidationUtils.ArgumentNotNull(source, "source");

      foreach (T token in source)
      {
        yield return Convert<JToken, U>(token);
      }
    }

    internal static U Convert<T, U>(this T token) where T : JToken
    {
      if (token == null)
        return default(U);

      if (token is U
        // don't want to cast JValue to its interfaces, want to get the internal value
        && typeof(U) != typeof(IComparable) && typeof(U) != typeof(IFormattable))
      {
        // HACK
        return (U)(object)token;
      }
      else
      {
        JValue value = token as JValue;
        if (value == null)
          throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, token.GetType(), typeof(T)));

        if (value.Value is U)
          return (U)value.Value;

        Type targetType = typeof(U);

        if (ReflectionUtils.IsNullableType(targetType))
        {
          if (value.Value == null)
            return default(U);

          targetType = Nullable.GetUnderlyingType(targetType);
        }

        return (U)System.Convert.ChangeType(value.Value, targetType, CultureInfo.InvariantCulture);
      }
    }

    //TODO
    //public static void Remove<T>(this IEnumerable<T> source) where T : JContainer;

    /// <summary>
    /// Returns the input typed as <see cref="IJEnumerable{T}"/>.
    /// </summary>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>The input typed as <see cref="IJEnumerable{T}"/>.</returns>
    public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
    {
      return source.AsJEnumerable<JToken>();
    }

    /// <summary>
    /// Returns the input typed as <see cref="IJEnumerable{T}"/>.
    /// </summary>
    /// <typeparam name="T">The source collection type.</typeparam>
    /// <param name="source">An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> that contains the source collection.</param>
    /// <returns>The input typed as <see cref="IJEnumerable{T}"/>.</returns>
    public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
    {
      if (source == null)
        return null;
      else if (source is IJEnumerable<T>)
        return (IJEnumerable<T>)source;
      else
        return new JEnumerable<T>(source);
    }
  }
}
#endregion Linq_Extensions.cs

/// ********   File: \Linq\IJEnumerable.cs
#region Linq_IJEnumerable.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a collection of <see cref="JToken"/> objects.
  /// </summary>
  /// <typeparam name="T">The type of token</typeparam>
  public interface IJEnumerable<
#if !(NET20 || NET35 || SILVERLIGHT || PORTABLE)
    out
#endif
    T> : IEnumerable<T> where T : JToken
  {
    /// <summary>
    /// Gets the <see cref="IJEnumerable{JToken}"/> with the specified key.
    /// </summary>
    /// <value></value>
    IJEnumerable<JToken> this[object key] { get; }
  }
}
#endregion Linq_IJEnumerable.cs

/// ********   File: \Linq\JArray.cs
#region Linq_JArray.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a JSON array.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
  /// </example>
  public class JArray : JContainer, IList<JToken>
  {
    private readonly List<JToken> _values = new List<JToken>();

    /// <summary>
    /// Gets the container's children tokens.
    /// </summary>
    /// <value>The container's children tokens.</value>
    protected override IList<JToken> ChildrenTokens
    {
      get { return _values; }
    }

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public override JTokenType Type
    {
      get { return JTokenType.Array; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JArray"/> class.
    /// </summary>
    public JArray()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JArray"/> class from another <see cref="JArray"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JArray"/> object to copy from.</param>
    public JArray(JArray other)
      : base(other)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JArray"/> class with the specified content.
    /// </summary>
    /// <param name="content">The contents of the array.</param>
    public JArray(params object[] content)
      : this((object)content)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JArray"/> class with the specified content.
    /// </summary>
    /// <param name="content">The contents of the array.</param>
    public JArray(object content)
    {
      Add(content);
    }

    internal override bool DeepEquals(JToken node)
    {
      JArray t = node as JArray;
      return (t != null && ContentsEqual(t));
    }

    internal override JToken CloneToken()
    {
      return new JArray(this);
    }

    /// <summary>
    /// Loads an <see cref="JArray"/> from a <see cref="JsonReader"/>. 
    /// </summary>
    /// <param name="reader">A <see cref="JsonReader"/> that will be read for the content of the <see cref="JArray"/>.</param>
    /// <returns>A <see cref="JArray"/> that contains the JSON that was read from the specified <see cref="JsonReader"/>.</returns>
    public static new JArray Load(JsonReader reader)
    {
      if (reader.TokenType == JsonToken.None)
      {
        if (!reader.Read())
          throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
      }

      while (reader.TokenType == JsonToken.Comment)
      {
        reader.Read();
      }

      if (reader.TokenType != JsonToken.StartArray)
        throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      JArray a = new JArray();
      a.SetLineInfo(reader as IJsonLineInfo);

      a.ReadTokenFrom(reader);

      return a;
    }

    /// <summary>
    /// Load a <see cref="JArray"/> from a string that contains JSON.
    /// </summary>
    /// <param name="json">A <see cref="String"/> that contains JSON.</param>
    /// <returns>A <see cref="JArray"/> populated from the string that contains JSON.</returns>
    /// <example>
    ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
    /// </example>
    public static new JArray Parse(string json)
    {
      JsonReader reader = new JsonTextReader(new StringReader(json));

      JArray a = Load(reader);

      if (reader.Read() && reader.TokenType != JsonToken.Comment)
        throw JsonReaderException.Create(reader, "Additional text found in JSON string after parsing content.");

      return a;
    }

    /// <summary>
    /// Creates a <see cref="JArray"/> from an object.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JArray"/>.</param>
    /// <returns>A <see cref="JArray"/> with the values of the specified object</returns>
    public static new JArray FromObject(object o)
    {
      return FromObject(o, new JsonSerializer());
    }

    /// <summary>
    /// Creates a <see cref="JArray"/> from an object.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JArray"/>.</param>
    /// <param name="jsonSerializer">The <see cref="JsonSerializer"/> that will be used to read the object.</param>
    /// <returns>A <see cref="JArray"/> with the values of the specified object</returns>
    public static new JArray FromObject(object o, JsonSerializer jsonSerializer)
    {
      JToken token = FromObjectInternal(o, jsonSerializer);

      if (token.Type != JTokenType.Array)
        throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture, token.Type));

      return (JArray)token;
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
    {
      writer.WriteStartArray();

      for (int i = 0; i < _values.Count; i++)
      {
        _values[i].WriteTo(writer, converters);
      }

      writer.WriteEndArray();
    }

    /// <summary>
    /// Gets the <see cref="JToken"/> with the specified key.
    /// </summary>
    /// <value>The <see cref="JToken"/> with the specified key.</value>
    public override JToken this[object key]
    {
      get
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        if (!(key is int))
          throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Array position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        return GetItem((int)key);
      }
      set
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        if (!(key is int))
          throw new ArgumentException("Set JArray values with invalid key value: {0}. Array position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        SetItem((int)key, value);
      }
    }

    /// <summary>
    /// Gets or sets the <see cref="Newtonsoft.Json.Linq.JToken"/> at the specified index.
    /// </summary>
    /// <value></value>
    public JToken this[int index]
    {
      get { return GetItem(index); }
      set { SetItem(index, value); }
    }

    #region IList<JToken> Members

    /// <summary>
    /// Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
    /// </summary>
    /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
    /// <returns>
    /// The index of <paramref name="item"/> if found in the list; otherwise, -1.
    /// </returns>
    public int IndexOf(JToken item)
    {
      return IndexOfItem(item);
    }

    /// <summary>
    /// Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
    /// </summary>
    /// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
    /// <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
    /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
    public void Insert(int index, JToken item)
    {
      InsertItem(index, item, false);
    }

    /// <summary>
    /// Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
    /// </summary>
    /// <param name="index">The zero-based index of the item to remove.</param>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
    /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
    public void RemoveAt(int index)
    {
      RemoveItemAt(index);
    }

    #endregion

    #region ICollection<JToken> Members

    /// <summary>
    /// Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
    /// </summary>
    /// <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
    /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
    public void Add(JToken item)
    {
      Add((object)item);
    }

    /// <summary>
    /// Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
    /// </summary>
    /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
    public void Clear()
    {
      ClearItems();
    }

    /// <summary>
    /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
    /// </summary>
    /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
    /// <returns>
    /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
    /// </returns>
    public bool Contains(JToken item)
    {
      return ContainsItem(item);
    }

    void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
    {
      CopyItemsTo(array, arrayIndex);
    }

    bool ICollection<JToken>.IsReadOnly
    {
      get { return false; }
    }

    /// <summary>
    /// Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
    /// </summary>
    /// <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
    /// <returns>
    /// true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
    /// </returns>
    /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.</exception>
    public bool Remove(JToken item)
    {
      return RemoveItem(item);
    }

    #endregion

    internal override int GetDeepHashCode()
    {
      return ContentsHashCode();
    }
  }
}
#endregion Linq_JArray.cs

/// ********   File: \Linq\JConstructor.cs
#region Linq_JConstructor.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a JSON constructor.
  /// </summary>
  public class JConstructor : JContainer
  {
    private string _name;
    private readonly List<JToken> _values = new List<JToken>();

    /// <summary>
    /// Gets the container's children tokens.
    /// </summary>
    /// <value>The container's children tokens.</value>
    protected override IList<JToken> ChildrenTokens
    {
      get { return _values; }
    }

    /// <summary>
    /// Gets or sets the name of this constructor.
    /// </summary>
    /// <value>The constructor name.</value>
    public string Name
    {
      get { return _name; }
      set { _name = value; }
    }

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public override JTokenType Type
    {
      get { return JTokenType.Constructor; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JConstructor"/> class.
    /// </summary>
    public JConstructor()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JConstructor"/> class from another <see cref="JConstructor"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JConstructor"/> object to copy from.</param>
    public JConstructor(JConstructor other)
      : base(other)
    {
      _name = other.Name;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JConstructor"/> class with the specified name and content.
    /// </summary>
    /// <param name="name">The constructor name.</param>
    /// <param name="content">The contents of the constructor.</param>
    public JConstructor(string name, params object[] content)
      : this(name, (object)content)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JConstructor"/> class with the specified name and content.
    /// </summary>
    /// <param name="name">The constructor name.</param>
    /// <param name="content">The contents of the constructor.</param>
    public JConstructor(string name, object content)
      : this(name)
    {
      Add(content);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JConstructor"/> class with the specified name.
    /// </summary>
    /// <param name="name">The constructor name.</param>
    public JConstructor(string name)
    {
      ValidationUtils.ArgumentNotNullOrEmpty(name, "name");

      _name = name;
    }

    internal override bool DeepEquals(JToken node)
    {
      JConstructor c = node as JConstructor;
      return (c != null && _name == c.Name && ContentsEqual(c));
    }

    internal override JToken CloneToken()
    {
      return new JConstructor(this);
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
    {
      writer.WriteStartConstructor(_name);

      foreach (JToken token in Children())
      {
        token.WriteTo(writer, converters);
      }

      writer.WriteEndConstructor();
    }

    /// <summary>
    /// Gets the <see cref="JToken"/> with the specified key.
    /// </summary>
    /// <value>The <see cref="JToken"/> with the specified key.</value>
    public override JToken this[object key]
    {
      get
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        if (!(key is int))
          throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        return GetItem((int)key);
      }
      set
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        if (!(key is int))
          throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        SetItem((int)key, value);
      }
    }

    internal override int GetDeepHashCode()
    {
      return _name.GetHashCode() ^ ContentsHashCode();
    }

    /// <summary>
    /// Loads an <see cref="JConstructor"/> from a <see cref="JsonReader"/>. 
    /// </summary>
    /// <param name="reader">A <see cref="JsonReader"/> that will be read for the content of the <see cref="JConstructor"/>.</param>
    /// <returns>A <see cref="JConstructor"/> that contains the JSON that was read from the specified <see cref="JsonReader"/>.</returns>
    public static new JConstructor Load(JsonReader reader)
    {
      if (reader.TokenType == JsonToken.None)
      {
        if (!reader.Read())
          throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
      }

      while (reader.TokenType == JsonToken.Comment)
      {
        reader.Read();
      }

      if (reader.TokenType != JsonToken.StartConstructor)
        throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      JConstructor c = new JConstructor((string)reader.Value);
      c.SetLineInfo(reader as IJsonLineInfo);

      c.ReadTokenFrom(reader);

      return c;
    }
  }
}
#endregion Linq_JConstructor.cs

/// ********   File: \Linq\JContainer.cs
#region Linq_JContainer.cs

#if !PORTABLE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a token that can contain other tokens.
  /// </summary>
  public abstract class JContainer : JToken, IList<JToken>
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    , ITypedList, IBindingList
#elif !PORTABLE
    , INotifyCollectionChanged
#endif
    , IList
#if !(SILVERLIGHT || NET20 || NET35 || NETFX_CORE || PORTABLE)
    , INotifyCollectionChanged
#endif
  {
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    internal ListChangedEventHandler _listChanged;
    internal AddingNewEventHandler _addingNew;

    /// <summary>
    /// Occurs when the list changes or an item in the list changes.
    /// </summary>
    public event ListChangedEventHandler ListChanged
    {
      add { _listChanged += value; }
      remove { _listChanged -= value; }
    }

    /// <summary>
    /// Occurs before an item is added to the collection.
    /// </summary>
    public event AddingNewEventHandler AddingNew
    {
      add { _addingNew += value; }
      remove { _addingNew -= value; }
    }
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
    internal NotifyCollectionChangedEventHandler _collectionChanged;

    /// <summary>
    /// Occurs when the items list of the collection has changed, or the collection is reset.
    /// </summary>
    public event NotifyCollectionChangedEventHandler CollectionChanged
    {
      add { _collectionChanged += value; }
      remove { _collectionChanged -= value; }
    }
#endif

    /// <summary>
    /// Gets the container's children tokens.
    /// </summary>
    /// <value>The container's children tokens.</value>
    protected abstract IList<JToken> ChildrenTokens { get; }

    private object _syncRoot;
    private bool _busy;

    internal JContainer()
    {
    }

    internal JContainer(JContainer other)
      : this()
    {
      ValidationUtils.ArgumentNotNull(other, "c");

      foreach (JToken child in other)
      {
        Add(child);
      }
    }

    internal void CheckReentrancy()
    {
      if (_busy)
        throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture, GetType()));
    }

    internal virtual IList<JToken> CreateChildrenCollection()
    {
      return new List<JToken>();
    }

 #if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Raises the <see cref="AddingNew"/> event.
    /// </summary>
    /// <param name="e">The <see cref="AddingNewEventArgs"/> instance containing the event data.</param>
    protected virtual void OnAddingNew(AddingNewEventArgs e)
    {
      AddingNewEventHandler handler = _addingNew;
      if (handler != null)
        handler(this, e);
    }

    /// <summary>
    /// Raises the <see cref="ListChanged"/> event.
    /// </summary>
    /// <param name="e">The <see cref="ListChangedEventArgs"/> instance containing the event data.</param>
    protected virtual void OnListChanged(ListChangedEventArgs e)
    {
      ListChangedEventHandler handler = _listChanged;

      if (handler != null)
      {
        _busy = true;
        try
        {
          handler(this, e);
        }
        finally
        {
          _busy = false;
        }
      }
    }
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
    /// <summary>
    /// Raises the <see cref="CollectionChanged"/> event.
    /// </summary>
    /// <param name="e">The <see cref="NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
    {
      NotifyCollectionChangedEventHandler handler = _collectionChanged;

      if (handler != null)
      {
        _busy = true;
        try
        {
          handler(this, e);
        }
        finally
        {
          _busy = false;
        }
      }
    }
#endif

    /// <summary>
    /// Gets a value indicating whether this token has childen tokens.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this token has child values; otherwise, <c>false</c>.
    /// </value>
    public override bool HasValues
    {
      get { return ChildrenTokens.Count > 0; }
    }

    internal bool ContentsEqual(JContainer container)
    {
      if (container == this)
        return true;

      IList<JToken> t1 = ChildrenTokens;
      IList<JToken> t2 = container.ChildrenTokens;

      if (t1.Count != t2.Count)
        return false;

      for (int i = 0; i < t1.Count; i++)
      {
        if (!t1[i].DeepEquals(t2[i]))
          return false;
      }

      return true;
    }

    /// <summary>
    /// Get the first child token of this token.
    /// </summary>
    /// <value>
    /// A <see cref="JToken"/> containing the first child token of the <see cref="JToken"/>.
    /// </value>
    public override JToken First
    {
      get { return ChildrenTokens.FirstOrDefault(); }
    }

    /// <summary>
    /// Get the last child token of this token.
    /// </summary>
    /// <value>
    /// A <see cref="JToken"/> containing the last child token of the <see cref="JToken"/>.
    /// </value>
    public override JToken Last
    {
      get { return ChildrenTokens.LastOrDefault(); }
    }

    /// <summary>
    /// Returns a collection of the child tokens of this token, in document order.
    /// </summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> containing the child tokens of this <see cref="JToken"/>, in document order.
    /// </returns>
    public override JEnumerable<JToken> Children()
    {
      return new JEnumerable<JToken>(ChildrenTokens);
    }

    /// <summary>
    /// Returns a collection of the child values of this token, in document order.
    /// </summary>
    /// <typeparam name="T">The type to convert the values to.</typeparam>
    /// <returns>
    /// A <see cref="IEnumerable{T}"/> containing the child values of this <see cref="JToken"/>, in document order.
    /// </returns>
    public override IEnumerable<T> Values<T>()
    {
      return ChildrenTokens.Convert<JToken, T>();
    }

    /// <summary>
    /// Returns a collection of the descendant tokens for this token in document order.
    /// </summary>
    /// <returns>An <see cref="IEnumerable{JToken}"/> containing the descendant tokens of the <see cref="JToken"/>.</returns>
    public IEnumerable<JToken> Descendants()
    {
      foreach (JToken o in ChildrenTokens)
      {
        yield return o;
        JContainer c = o as JContainer;
        if (c != null)
        {
          foreach (JToken d in c.Descendants())
          {
            yield return d;
          }
        }
      }
    }

    internal bool IsMultiContent(object content)
    {
      return (content is IEnumerable && !(content is string) && !(content is JToken) && !(content is byte[]));
    }

    internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
    {
      if (item == null)
        return new JValue((object) null);

      if (skipParentCheck)
        return item;

      // to avoid a token having multiple parents or creating a recursive loop, create a copy if...
      // the item already has a parent
      // the item is being added to itself
      // the item is being added to the root parent of itself
      if (item.Parent != null || item == this || (item.HasValues && Root == item))
        item = item.CloneToken();

      return item;
    }

    private class JTokenReferenceEqualityComparer : IEqualityComparer<JToken>
    {
      public static readonly JTokenReferenceEqualityComparer Instance = new JTokenReferenceEqualityComparer();

      public bool Equals(JToken x, JToken y)
      {
        return ReferenceEquals(x, y);
      }

      public int GetHashCode(JToken obj)
      {
        if (obj == null)
          return 0;

        return obj.GetHashCode();
      }
    }

    internal int IndexOfItem(JToken item)
    {
      return ChildrenTokens.IndexOf(item, JTokenReferenceEqualityComparer.Instance);
    }

    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck)
    {
      if (index > ChildrenTokens.Count)
        throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");

      CheckReentrancy();

      item = EnsureParentToken(item, skipParentCheck);

      JToken previous = (index == 0) ? null : ChildrenTokens[index - 1];
      // haven't inserted new token yet so next token is still at the inserting index
      JToken next = (index == ChildrenTokens.Count) ? null : ChildrenTokens[index];

      ValidateToken(item, null);

      item.Parent = this;

      item.Previous = previous;
      if (previous != null)
        previous.Next = item;

      item.Next = next;
      if (next != null)
        next.Previous = item;
      
      ChildrenTokens.Insert(index, item);

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (_listChanged != null)
        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
      if (_collectionChanged != null)
        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index));
#endif
    }

    internal virtual void RemoveItemAt(int index)
    {
      if (index < 0)
        throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
      if (index >= ChildrenTokens.Count)
        throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");

      CheckReentrancy();

      JToken item = ChildrenTokens[index];
      JToken previous = (index == 0) ? null : ChildrenTokens[index - 1];
      JToken next = (index == ChildrenTokens.Count - 1) ? null : ChildrenTokens[index + 1];

      if (previous != null)
        previous.Next = next;
      if (next != null)
        next.Previous = previous;

      item.Parent = null;
      item.Previous = null;
      item.Next = null;

      ChildrenTokens.RemoveAt(index);

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (_listChanged != null)
        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
      if (_collectionChanged != null)
        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, item, index));
#endif
    }

    internal virtual bool RemoveItem(JToken item)
    {
      int index = IndexOfItem(item);
      if (index >= 0)
      {
        RemoveItemAt(index);
        return true;
      }

      return false;
    }

    internal virtual JToken GetItem(int index)
    {
      return ChildrenTokens[index];
    }

    internal virtual void SetItem(int index, JToken item)
    {
      if (index < 0)
        throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
      if (index >= ChildrenTokens.Count)
        throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");

      JToken existing = ChildrenTokens[index];

      if (IsTokenUnchanged(existing, item))
        return;

      CheckReentrancy();

      item = EnsureParentToken(item, false);

      ValidateToken(item, existing);

      JToken previous = (index == 0) ? null : ChildrenTokens[index - 1];
      JToken next = (index == ChildrenTokens.Count - 1) ? null : ChildrenTokens[index + 1];

      item.Parent = this;

      item.Previous = previous;
      if (previous != null)
        previous.Next = item;

      item.Next = next;
      if (next != null)
        next.Previous = item;

      ChildrenTokens[index] = item;

      existing.Parent = null;
      existing.Previous = null;
      existing.Next = null;

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (_listChanged != null)
        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
      if (_collectionChanged != null)
        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, item, existing, index));
#endif
    }

    internal virtual void ClearItems()
    {
      CheckReentrancy();

      foreach (JToken item in ChildrenTokens)
      {
        item.Parent = null;
        item.Previous = null;
        item.Next = null;
      }

      ChildrenTokens.Clear();

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (_listChanged != null)
        OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
      if (_collectionChanged != null)
        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
#endif
    }

    internal virtual void ReplaceItem(JToken existing, JToken replacement)
    {
      if (existing == null || existing.Parent != this)
        return;

      int index = IndexOfItem(existing);
      SetItem(index, replacement);
    }

    internal virtual bool ContainsItem(JToken item)
    {
      return (IndexOfItem(item) != -1);
    }

    internal virtual void CopyItemsTo(Array array, int arrayIndex)
    {
      if (array == null)
        throw new ArgumentNullException("array");
      if (arrayIndex < 0)
        throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
      if (arrayIndex >= array.Length && arrayIndex != 0)
        throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
      if (Count > array.Length - arrayIndex)
        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");

      int index = 0;
      foreach (JToken token in ChildrenTokens)
      {
        array.SetValue(token, arrayIndex + index);
        index++;
      }
    }

    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
    {
      JValue v1 = currentValue as JValue;
      if (v1 != null)
      {
        // null will get turned into a JValue of type null
        if (v1.Type == JTokenType.Null && newValue == null)
          return true;

        return v1.Equals(newValue);
      }

      return false;
    }

    internal virtual void ValidateToken(JToken o, JToken existing)
    {
      ValidationUtils.ArgumentNotNull(o, "o");

      if (o.Type == JTokenType.Property)
        throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
    }

    /// <summary>
    /// Adds the specified content as children of this <see cref="JToken"/>.
    /// </summary>
    /// <param name="content">The content to be added.</param>
    public virtual void Add(object content)
    {
      AddInternal(ChildrenTokens.Count, content, false);
    }

    internal void AddAndSkipParentCheck(JToken token)
    {
      AddInternal(ChildrenTokens.Count, token, true);
    }

    /// <summary>
    /// Adds the specified content as the first children of this <see cref="JToken"/>.
    /// </summary>
    /// <param name="content">The content to be added.</param>
    public void AddFirst(object content)
    {
      AddInternal(0, content, false);
    }

    internal void AddInternal(int index, object content, bool skipParentCheck)
    {
      if (IsMultiContent(content))
      {
        IEnumerable enumerable = (IEnumerable)content;

        int multiIndex = index;
        foreach (object c in enumerable)
        {
          AddInternal(multiIndex, c, skipParentCheck);
          multiIndex++;
        }
      }
      else
      {
        JToken item = CreateFromContent(content);

        InsertItem(index, item, skipParentCheck);
      }
    }

    internal JToken CreateFromContent(object content)
    {
      if (content is JToken)
        return (JToken)content;
      
      return new JValue(content);
    }

    /// <summary>
    /// Creates an <see cref="JsonWriter"/> that can be used to add tokens to the <see cref="JToken"/>.
    /// </summary>
    /// <returns>An <see cref="JsonWriter"/> that is ready to have content written to it.</returns>
    public JsonWriter CreateWriter()
    {
      return new JTokenWriter(this);
    }

    /// <summary>
    /// Replaces the children nodes of this token with the specified content.
    /// </summary>
    /// <param name="content">The content.</param>
    public void ReplaceAll(object content)
    {
      ClearItems();
      Add(content);
    }

    /// <summary>
    /// Removes the child nodes from this token.
    /// </summary>
    public void RemoveAll()
    {
      ClearItems();
    }

    internal void ReadTokenFrom(JsonReader reader)
    {
      int startDepth = reader.Depth;

      if (!reader.Read())
        throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));

      ReadContentFrom(reader);

      int endDepth = reader.Depth;

      if (endDepth > startDepth)
        throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
    }

    internal void ReadContentFrom(JsonReader r)
    {
      ValidationUtils.ArgumentNotNull(r, "r");
      IJsonLineInfo lineInfo = r as IJsonLineInfo;

      JContainer parent = this;

      do
      {
        if (parent is JProperty && ((JProperty)parent).Value != null)
        {
          if (parent == this)
            return;

          parent = parent.Parent;
        }

        switch (r.TokenType)
        {
          case JsonToken.None:
            // new reader. move to actual content
            break;
          case JsonToken.StartArray:
            JArray a = new JArray();
            a.SetLineInfo(lineInfo);
            parent.Add(a);
            parent = a;
            break;

          case JsonToken.EndArray:
            if (parent == this)
              return;

            parent = parent.Parent;
            break;
          case JsonToken.StartObject:
            JObject o = new JObject();
            o.SetLineInfo(lineInfo);
            parent.Add(o);
            parent = o;
            break;
          case JsonToken.EndObject:
            if (parent == this)
              return;

            parent = parent.Parent;
            break;
          case JsonToken.StartConstructor:
            JConstructor constructor = new JConstructor(r.Value.ToString());
            constructor.SetLineInfo(constructor);
            parent.Add(constructor);
            parent = constructor;
            break;
          case JsonToken.EndConstructor:
            if (parent == this)
              return;

            parent = parent.Parent;
            break;
          case JsonToken.String:
          case JsonToken.Integer:
          case JsonToken.Float:
          case JsonToken.Date:
          case JsonToken.Boolean:
          case JsonToken.Bytes:
            JValue v = new JValue(r.Value);
            v.SetLineInfo(lineInfo);
            parent.Add(v);
            break;
          case JsonToken.Comment:
            v = JValue.CreateComment(r.Value.ToString());
            v.SetLineInfo(lineInfo);
            parent.Add(v);
            break;
          case JsonToken.Null:
            v = new JValue(null, JTokenType.Null);
            v.SetLineInfo(lineInfo);
            parent.Add(v);
            break;
          case JsonToken.Undefined:
            v = new JValue(null, JTokenType.Undefined);
            v.SetLineInfo(lineInfo);
            parent.Add(v);
            break;
          case JsonToken.PropertyName:
            string propertyName = r.Value.ToString();
            JProperty property = new JProperty(propertyName);
            property.SetLineInfo(lineInfo);
            JObject parentObject = (JObject) parent;
            // handle multiple properties with the same name in JSON
            JProperty existingPropertyWithName = parentObject.Property(propertyName);
            if (existingPropertyWithName == null)
              parent.Add(property);
            else
              existingPropertyWithName.Replace(property);
            parent = property;
            break;
          default:
            throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, r.TokenType));
        }
      }
      while (r.Read());
    }

    internal int ContentsHashCode()
    {
      int hashCode = 0;
      foreach (JToken item in ChildrenTokens)
      {
        hashCode ^= item.GetDeepHashCode();
      }
      return hashCode;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    string ITypedList.GetListName(PropertyDescriptor[] listAccessors)
    {
      return string.Empty;
    }

    PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
    {
      ICustomTypeDescriptor d = First as ICustomTypeDescriptor;
      if (d != null)
        return d.GetProperties();

      return null;
    }
#endif

    #region IList<JToken> Members

    int IList<JToken>.IndexOf(JToken item)
    {
      return IndexOfItem(item);
    }

    void IList<JToken>.Insert(int index, JToken item)
    {
      InsertItem(index, item, false);
    }

    void IList<JToken>.RemoveAt(int index)
    {
      RemoveItemAt(index);
    }

    JToken IList<JToken>.this[int index]
    {
      get { return GetItem(index); }
      set { SetItem(index, value); }
    }

    #endregion

    #region ICollection<JToken> Members

    void ICollection<JToken>.Add(JToken item)
    {
      Add(item);
    }

    void ICollection<JToken>.Clear()
    {
      ClearItems();
    }

    bool ICollection<JToken>.Contains(JToken item)
    {
      return ContainsItem(item);
    }

    void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
    {
      CopyItemsTo(array, arrayIndex);
    }

    bool ICollection<JToken>.IsReadOnly
    {
      get { return false; }
    }

    bool ICollection<JToken>.Remove(JToken item)
    {
      return RemoveItem(item);
    }

    #endregion

    private JToken EnsureValue(object value)
    {
      if (value == null)
        return null;

      if (value is JToken)
        return (JToken) value;

      throw new ArgumentException("Argument is not a JToken.");
    }

    #region IList Members

    int IList.Add(object value)
    {
      Add(EnsureValue(value));
      return Count - 1;
    }

    void IList.Clear()
    {
      ClearItems();
    }

    bool IList.Contains(object value)
    {
      return ContainsItem(EnsureValue(value));
    }

    int IList.IndexOf(object value)
    {
      return IndexOfItem(EnsureValue(value));
    }

    void IList.Insert(int index, object value)
    {
      InsertItem(index, EnsureValue(value), false);
    }

    bool IList.IsFixedSize
    {
      get { return false; }
    }

    bool IList.IsReadOnly
    {
      get { return false; }
    }

    void IList.Remove(object value)
    {
      RemoveItem(EnsureValue(value));
    }

    void IList.RemoveAt(int index)
    {
      RemoveItemAt(index);
    }

    object IList.this[int index]
    {
      get { return GetItem(index); }
      set { SetItem(index, EnsureValue(value)); }
    }

    #endregion

    #region ICollection Members

    void ICollection.CopyTo(Array array, int index)
    {
      CopyItemsTo(array, index);
    }

    /// <summary>
    /// Gets the count of child JSON tokens.
    /// </summary>
    /// <value>The count of child JSON tokens</value>
    public int Count
    {
      get { return ChildrenTokens.Count; }
    }

    bool ICollection.IsSynchronized
    {
      get { return false; }
    }

    object ICollection.SyncRoot
    {
      get
      {
        if (_syncRoot == null)
          Interlocked.CompareExchange(ref _syncRoot, new object(), null);

        return _syncRoot;
      }

    }

    #endregion

    #region IBindingList Members

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    void IBindingList.AddIndex(PropertyDescriptor property)
    {
    }

    object IBindingList.AddNew()
    {
      AddingNewEventArgs args = new AddingNewEventArgs();
      OnAddingNew(args);

      if (args.NewObject == null)
        throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith(CultureInfo.InvariantCulture, GetType()));

      if (!(args.NewObject is JToken))
        throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JToken)));

      JToken newItem = (JToken)args.NewObject;
      Add(newItem);

      return newItem;
    }

    bool IBindingList.AllowEdit
    {
      get { return true; }
    }

    bool IBindingList.AllowNew
    {
      get { return true; }
    }

    bool IBindingList.AllowRemove
    {
      get { return true; }
    }

    void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
    {
      throw new NotSupportedException();
    }

    int IBindingList.Find(PropertyDescriptor property, object key)
    {
      throw new NotSupportedException();
    }

    bool IBindingList.IsSorted
    {
      get { return false; }
    }

    void IBindingList.RemoveIndex(PropertyDescriptor property)
    {
    }

    void IBindingList.RemoveSort()
    {
      throw new NotSupportedException();
    }

    ListSortDirection IBindingList.SortDirection
    {
      get { return ListSortDirection.Ascending; }
    }

    PropertyDescriptor IBindingList.SortProperty
    {
      get { return null; }
    }

    bool IBindingList.SupportsChangeNotification
    {
      get { return true; }
    }

    bool IBindingList.SupportsSearching
    {
      get { return false; }
    }

    bool IBindingList.SupportsSorting
    {
      get { return false; }
    }
#endif

    #endregion
  }
}
#endregion Linq_JContainer.cs

/// ********   File: \Linq\JEnumerable.cs
#region Linq_JEnumerable.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a collection of <see cref="JToken"/> objects.
  /// </summary>
  /// <typeparam name="T">The type of token</typeparam>
  public struct JEnumerable<T> : IJEnumerable<T> where T : JToken
  {
    /// <summary>
    /// An empty collection of <see cref="JToken"/> objects.
    /// </summary>
    public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Enumerable.Empty<T>());

    private readonly IEnumerable<T> _enumerable;

    /// <summary>
    /// Initializes a new instance of the <see cref="JEnumerable{T}"/> struct.
    /// </summary>
    /// <param name="enumerable">The enumerable.</param>
    public JEnumerable(IEnumerable<T> enumerable)
    {
      ValidationUtils.ArgumentNotNull(enumerable, "enumerable");

      _enumerable = enumerable;
    }

    /// <summary>
    /// Returns an enumerator that iterates through the collection.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
    /// </returns>
    public IEnumerator<T> GetEnumerator()
    {
      return _enumerable.GetEnumerator();
    }

    /// <summary>
    /// Returns an enumerator that iterates through a collection.
    /// </summary>
    /// <returns>
    /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
    /// </returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
      return GetEnumerator();
    }

    /// <summary>
    /// Gets the <see cref="IJEnumerable{JToken}"/> with the specified key.
    /// </summary>
    /// <value></value>
    public IJEnumerable<JToken> this[object key]
    {
      get { return new JEnumerable<JToken>(Extensions.Values<T, JToken>(_enumerable, key)); }
    }

    /// <summary>
    /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
    /// </summary>
    /// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
    /// <returns>
    /// 	<c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
    /// </returns>
    public override bool Equals(object obj)
    {
      if (obj is JEnumerable<T>)
        return _enumerable.Equals(((JEnumerable<T>)obj)._enumerable);

      return false;
    }

    /// <summary>
    /// Returns a hash code for this instance.
    /// </summary>
    /// <returns>
    /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
    /// </returns>
    public override int GetHashCode()
    {
      return _enumerable.GetHashCode();
    }
  }
}

#endregion Linq_JEnumerable.cs

/// ********   File: \Linq\JObject.cs
#region Linq_JObject.cs

#if !PORTABLE
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a JSON object.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
  /// </example>
  public class JObject : JContainer, IDictionary<string, JToken>, INotifyPropertyChanged
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    , ICustomTypeDescriptor
#endif
#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
    , INotifyPropertyChanging
#endif
  {
    private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();

    /// <summary>
    /// Gets the container's children tokens.
    /// </summary>
    /// <value>The container's children tokens.</value>
    protected override IList<JToken> ChildrenTokens
    {
      get { return _properties; }
    }

    /// <summary>
    /// Occurs when a property value changes.
    /// </summary>
    public event PropertyChangedEventHandler PropertyChanged;

#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Occurs when a property value is changing.
    /// </summary>
    public event PropertyChangingEventHandler PropertyChanging;
#endif

    /// <summary>
    /// Initializes a new instance of the <see cref="JObject"/> class.
    /// </summary>
    public JObject()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JObject"/> class from another <see cref="JObject"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JObject"/> object to copy from.</param>
    public JObject(JObject other)
      : base(other)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JObject"/> class with the specified content.
    /// </summary>
    /// <param name="content">The contents of the object.</param>
    public JObject(params object[] content)
      : this((object)content)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JObject"/> class with the specified content.
    /// </summary>
    /// <param name="content">The contents of the object.</param>
    public JObject(object content)
    {
      Add(content);
    }

    internal override bool DeepEquals(JToken node)
    {
      JObject t = node as JObject;
      if (t == null)
        return false;

      return _properties.Compare(t._properties);
    }

    internal override void InsertItem(int index, JToken item, bool skipParentCheck)
    {
      // don't add comments to JObject, no name to reference comment by
      if (item != null && item.Type == JTokenType.Comment)
        return;

      base.InsertItem(index, item, skipParentCheck);
    }

    internal override void ValidateToken(JToken o, JToken existing)
    {
      ValidationUtils.ArgumentNotNull(o, "o");

      if (o.Type != JTokenType.Property)
        throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));

      JProperty newProperty = (JProperty) o;

      if (existing != null)
      {
        JProperty existingProperty = (JProperty) existing;

        if (newProperty.Name == existingProperty.Name)
          return;
      }

      if (_properties.TryGetValue(newProperty.Name, out existing))
        throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture, newProperty.Name, GetType()));
    }

    internal void InternalPropertyChanged(JProperty childProperty)
    {
      OnPropertyChanged(childProperty.Name);
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (_listChanged != null)
        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOfItem(childProperty)));
#endif
#if SILVERLIGHT || !(NET20 || NET35 || PORTABLE)
      if (_collectionChanged != null)
        OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, childProperty, childProperty, IndexOfItem(childProperty)));
#endif
    }

    internal void InternalPropertyChanging(JProperty childProperty)
    {
#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
      OnPropertyChanging(childProperty.Name);
#endif
    }

    internal override JToken CloneToken()
    {
      return new JObject(this);
    }

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public override JTokenType Type
    {
      get { return JTokenType.Object; }
    }

    /// <summary>
    /// Gets an <see cref="IEnumerable{JProperty}"/> of this object's properties.
    /// </summary>
    /// <returns>An <see cref="IEnumerable{JProperty}"/> of this object's properties.</returns>
    public IEnumerable<JProperty> Properties()
    {
      return _properties.Cast<JProperty>();
    }

    /// <summary>
    /// Gets a <see cref="JProperty"/> the specified name.
    /// </summary>
    /// <param name="name">The property name.</param>
    /// <returns>A <see cref="JProperty"/> with the specified name or null.</returns>
    public JProperty Property(string name)
    {
      if (name == null)
        return null;

      JToken property;
      _properties.TryGetValue(name, out property);
      return (JProperty)property;
    }

    /// <summary>
    /// Gets an <see cref="JEnumerable{JToken}"/> of this object's property values.
    /// </summary>
    /// <returns>An <see cref="JEnumerable{JToken}"/> of this object's property values.</returns>
    public JEnumerable<JToken> PropertyValues()
    {
      return new JEnumerable<JToken>(Properties().Select(p => p.Value));
    }

    /// <summary>
    /// Gets the <see cref="JToken"/> with the specified key.
    /// </summary>
    /// <value>The <see cref="JToken"/> with the specified key.</value>
    public override JToken this[object key]
    {
      get
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        string propertyName = key as string;
        if (propertyName == null)
          throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        return this[propertyName];
      }
      set
      {
        ValidationUtils.ArgumentNotNull(key, "o");

        string propertyName = key as string;
        if (propertyName == null)
          throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));

        this[propertyName] = value;
      }
    }

    /// <summary>
    /// Gets or sets the <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.
    /// </summary>
    /// <value></value>
    public JToken this[string propertyName]
    {
      get
      {
        ValidationUtils.ArgumentNotNull(propertyName, "propertyName");

        JProperty property = Property(propertyName);

        return (property != null) ? property.Value : null;
      }
      set
      {
        JProperty property = Property(propertyName);
        if (property != null)
        {
          property.Value = value;
        }
        else
        {
#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
          OnPropertyChanging(propertyName);
#endif
          Add(new JProperty(propertyName, value));
          OnPropertyChanged(propertyName);
        }
      }
    }

    /// <summary>
    /// Loads an <see cref="JObject"/> from a <see cref="JsonReader"/>. 
    /// </summary>
    /// <param name="reader">A <see cref="JsonReader"/> that will be read for the content of the <see cref="JObject"/>.</param>
    /// <returns>A <see cref="JObject"/> that contains the JSON that was read from the specified <see cref="JsonReader"/>.</returns>
    public static new JObject Load(JsonReader reader)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      if (reader.TokenType == JsonToken.None)
      {
        if (!reader.Read())
          throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
      }

      while (reader.TokenType == JsonToken.Comment)
      {
        reader.Read();
      }

      if (reader.TokenType != JsonToken.StartObject)
      {
        throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
      }

      JObject o = new JObject();
      o.SetLineInfo(reader as IJsonLineInfo);
      
      o.ReadTokenFrom(reader);

      return o;
    }

    /// <summary>
    /// Load a <see cref="JObject"/> from a string that contains JSON.
    /// </summary>
    /// <param name="json">A <see cref="String"/> that contains JSON.</param>
    /// <returns>A <see cref="JObject"/> populated from the string that contains JSON.</returns>
    /// <example>
    ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
    /// </example>
    public static new JObject Parse(string json)
    {
      JsonReader reader = new JsonTextReader(new StringReader(json));

      JObject o = Load(reader);

      if (reader.Read() && reader.TokenType != JsonToken.Comment)
        throw JsonReaderException.Create(reader, "Additional text found in JSON string after parsing content.");

      return o;
    }

    /// <summary>
    /// Creates a <see cref="JObject"/> from an object.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JObject"/>.</param>
    /// <returns>A <see cref="JObject"/> with the values of the specified object</returns>
    public static new JObject FromObject(object o)
    {
      return FromObject(o, new JsonSerializer());
    }

    /// <summary>
    /// Creates a <see cref="JArray"/> from an object.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JArray"/>.</param>
    /// <param name="jsonSerializer">The <see cref="JsonSerializer"/> that will be used to read the object.</param>
    /// <returns>A <see cref="JArray"/> with the values of the specified object</returns>
    public static new JObject FromObject(object o, JsonSerializer jsonSerializer)
    {
      JToken token = FromObjectInternal(o, jsonSerializer);

      if (token != null && token.Type != JTokenType.Object)
        throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture, token.Type));

      return (JObject)token;
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
    {
      writer.WriteStartObject();

      for (int i = 0; i < _properties.Count; i++)
      {
        _properties[i].WriteTo(writer, converters);
      }

      writer.WriteEndObject();
    }

    /// <summary>
    /// Gets the <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <value>The <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.</value>
    public JToken GetValue(string propertyName)
    {
      return GetValue(propertyName, StringComparison.Ordinal);
    }

    /// <summary>
    /// Gets the <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.
    /// The exact property name will be searched for first and if no matching property is found then
    /// the <see cref="StringComparison"/> will be used to match a property.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
    /// <value>The <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.</value>
    public JToken GetValue(string propertyName, StringComparison comparison)
    {
      if (propertyName == null)
        return null;

      // attempt to get value via dictionary first for performance
      JProperty property = Property(propertyName);
      if (property != null)
        return property.Value;

      // test above already uses this comparison so no need to repeat
      if (comparison != StringComparison.Ordinal)
      {
        foreach (JProperty p in _properties)
        {
          if (string.Equals(p.Name, propertyName, comparison))
            return p.Value;
        }
      }

      return null;
    }

    /// <summary>
    /// Tries to get the <see cref="Newtonsoft.Json.Linq.JToken"/> with the specified property name.
    /// The exact property name will be searched for first and if no matching property is found then
    /// the <see cref="StringComparison"/> will be used to match a property.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <param name="value">The value.</param>
    /// <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
    /// <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    public bool TryGetValue(string propertyName, StringComparison comparison, out JToken value)
    {
      value = GetValue(propertyName, comparison);
      return (value != null);
    }

    #region IDictionary<string,JToken> Members
    /// <summary>
    /// Adds the specified property name.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <param name="value">The value.</param>
    public void Add(string propertyName, JToken value)
    {
      Add(new JProperty(propertyName, value));
    }

    bool IDictionary<string, JToken>.ContainsKey(string key)
    {
      return _properties.Contains(key);
    }

    ICollection<string> IDictionary<string, JToken>.Keys
    {
      // todo: make order the collection returned match JObject order
      get { return _properties.Keys; }
    }

    /// <summary>
    /// Removes the property with the specified name.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <returns>true if item was successfully removed; otherwise, false.</returns>
    public bool Remove(string propertyName)
    {
      JProperty property = Property(propertyName);
      if (property == null)
        return false;

      property.Remove();
      return true;
    }

    /// <summary>
    /// Tries the get value.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <param name="value">The value.</param>
    /// <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    public bool TryGetValue(string propertyName, out JToken value)
    {
      JProperty property = Property(propertyName);
      if (property == null)
      {
        value = null;
        return false;
      }

      value = property.Value;
      return true;
    }

    ICollection<JToken> IDictionary<string, JToken>.Values
    {
      get
      {
        // todo: need to wrap _properties.Values with a collection to get the JProperty value
        throw new NotImplementedException();
      }
    }

    #endregion

    #region ICollection<KeyValuePair<string,JToken>> Members

    void ICollection<KeyValuePair<string,JToken>>.Add(KeyValuePair<string, JToken> item)
    {
      Add(new JProperty(item.Key, item.Value));
    }

    void ICollection<KeyValuePair<string, JToken>>.Clear()
    {
      RemoveAll();
    }

    bool ICollection<KeyValuePair<string,JToken>>.Contains(KeyValuePair<string, JToken> item)
    {
      JProperty property = Property(item.Key);
      if (property == null)
        return false;

      return (property.Value == item.Value);
    }

    void ICollection<KeyValuePair<string,JToken>>.CopyTo(KeyValuePair<string, JToken>[] array, int arrayIndex)
    {
      if (array == null)
        throw new ArgumentNullException("array");
      if (arrayIndex < 0)
        throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
      if (arrayIndex >= array.Length && arrayIndex != 0)
        throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
      if (Count > array.Length - arrayIndex)
        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");

      int index = 0;
      foreach (JProperty property in _properties)
      {
        array[arrayIndex + index] = new KeyValuePair<string, JToken>(property.Name, property.Value);
        index++;
      }
    }

    bool ICollection<KeyValuePair<string,JToken>>.IsReadOnly
    {
      get { return false; }
    }

    bool ICollection<KeyValuePair<string,JToken>>.Remove(KeyValuePair<string, JToken> item)
    {
      if (!((ICollection<KeyValuePair<string,JToken>>)this).Contains(item))
        return false;

      ((IDictionary<string, JToken>)this).Remove(item.Key);
      return true;
    }

    #endregion

    internal override int GetDeepHashCode()
    {
      return ContentsHashCode();
    }

    /// <summary>
    /// Returns an enumerator that iterates through the collection.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
    /// </returns>
    public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
    {
      foreach (JProperty property in _properties)
      {
        yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
      }
    }

    /// <summary>
    /// Raises the <see cref="PropertyChanged"/> event with the provided arguments.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    protected virtual void OnPropertyChanged(string propertyName)
    {
      if (PropertyChanged != null)
        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE || NET20)
    /// <summary>
    /// Raises the <see cref="PropertyChanging"/> event with the provided arguments.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    protected virtual void OnPropertyChanging(string propertyName)
    {
      if (PropertyChanging != null)
        PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
    }
#endif

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    // include custom type descriptor on JObject rather than use a provider because the properties are specific to a type
    #region ICustomTypeDescriptor
    /// <summary>
    /// Returns the properties for this instance of a component.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.ComponentModel.PropertyDescriptorCollection"/> that represents the properties for this component instance.
    /// </returns>
    PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
    {
      return ((ICustomTypeDescriptor) this).GetProperties(null);
    }

    private static Type GetTokenPropertyType(JToken token)
    {
      if (token is JValue)
      {
        JValue v = (JValue)token;
        return (v.Value != null) ? v.Value.GetType() : typeof(object);
      }

      return token.GetType();
    }

    /// <summary>
    /// Returns the properties for this instance of a component using the attribute array as a filter.
    /// </summary>
    /// <param name="attributes">An array of type <see cref="T:System.Attribute"/> that is used as a filter.</param>
    /// <returns>
    /// A <see cref="T:System.ComponentModel.PropertyDescriptorCollection"/> that represents the filtered properties for this component instance.
    /// </returns>
    PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
    {
      PropertyDescriptorCollection descriptors = new PropertyDescriptorCollection(null);

      foreach (KeyValuePair<string, JToken> propertyValue in this)
      {
        descriptors.Add(new JPropertyDescriptor(propertyValue.Key, GetTokenPropertyType(propertyValue.Value)));
      }

      return descriptors;
    }

    /// <summary>
    /// Returns a collection of custom attributes for this instance of a component.
    /// </summary>
    /// <returns>
    /// An <see cref="T:System.ComponentModel.AttributeCollection"/> containing the attributes for this object.
    /// </returns>
    AttributeCollection ICustomTypeDescriptor.GetAttributes()
    {
      return AttributeCollection.Empty;
    }

    /// <summary>
    /// Returns the class name of this instance of a component.
    /// </summary>
    /// <returns>
    /// The class name of the object, or null if the class does not have a name.
    /// </returns>
    string ICustomTypeDescriptor.GetClassName()
    {
      return null;
    }

    /// <summary>
    /// Returns the name of this instance of a component.
    /// </summary>
    /// <returns>
    /// The name of the object, or null if the object does not have a name.
    /// </returns>
    string ICustomTypeDescriptor.GetComponentName()
    {
      return null;
    }

    /// <summary>
    /// Returns a type converter for this instance of a component.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.ComponentModel.TypeConverter"/> that is the converter for this object, or null if there is no <see cref="T:System.ComponentModel.TypeConverter"/> for this object.
    /// </returns>
    TypeConverter ICustomTypeDescriptor.GetConverter()
    {
      return new TypeConverter();
    }

    /// <summary>
    /// Returns the default event for this instance of a component.
    /// </summary>
    /// <returns>
    /// An <see cref="T:System.ComponentModel.EventDescriptor"/> that represents the default event for this object, or null if this object does not have events.
    /// </returns>
    EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
    {
      return null;
    }

    /// <summary>
    /// Returns the default property for this instance of a component.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that represents the default property for this object, or null if this object does not have properties.
    /// </returns>
    PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
    {
      return null;
    }

    /// <summary>
    /// Returns an editor of the specified type for this instance of a component.
    /// </summary>
    /// <param name="editorBaseType">A <see cref="T:System.Type"/> that represents the editor for this object.</param>
    /// <returns>
    /// An <see cref="T:System.Object"/> of the specified type that is the editor for this object, or null if the editor cannot be found.
    /// </returns>
    object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
    {
      return null;
    }

    /// <summary>
    /// Returns the events for this instance of a component using the specified attribute array as a filter.
    /// </summary>
    /// <param name="attributes">An array of type <see cref="T:System.Attribute"/> that is used as a filter.</param>
    /// <returns>
    /// An <see cref="T:System.ComponentModel.EventDescriptorCollection"/> that represents the filtered events for this component instance.
    /// </returns>
    EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
    {
      return EventDescriptorCollection.Empty;
    }

    /// <summary>
    /// Returns the events for this instance of a component.
    /// </summary>
    /// <returns>
    /// An <see cref="T:System.ComponentModel.EventDescriptorCollection"/> that represents the events for this component instance.
    /// </returns>
    EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
    {
      return EventDescriptorCollection.Empty;
    }

    /// <summary>
    /// Returns an object that contains the property described by the specified property descriptor.
    /// </summary>
    /// <param name="pd">A <see cref="T:System.ComponentModel.PropertyDescriptor"/> that represents the property whose owner is to be found.</param>
    /// <returns>
    /// An <see cref="T:System.Object"/> that represents the owner of the specified property.
    /// </returns>
    object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
    {
      return null;
    }
    #endregion
#endif

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    /// <summary>
    /// Returns the <see cref="T:System.Dynamic.DynamicMetaObject"/> responsible for binding operations performed on this object.
    /// </summary>
    /// <param name="parameter">The expression tree representation of the runtime value.</param>
    /// <returns>
    /// The <see cref="T:System.Dynamic.DynamicMetaObject"/> to bind this object.
    /// </returns>
    protected override DynamicMetaObject GetMetaObject(Expression parameter)
    {
      return new DynamicProxyMetaObject<JObject>(parameter, this, new JObjectDynamicProxy(), true);
    }

    private class JObjectDynamicProxy : DynamicProxy<JObject>
    {
      public override bool TryGetMember(JObject instance, GetMemberBinder binder, out object result)
      {
        // result can be null
        result = instance[binder.Name];
        return true;
      }

      public override bool TrySetMember(JObject instance, SetMemberBinder binder, object value)
      {
        JToken v = value as JToken;

        // this can throw an error if value isn't a valid for a JValue
        if (v == null)
          v = new JValue(value);

        instance[binder.Name] = v;
        return true;
      }

      public override IEnumerable<string> GetDynamicMemberNames(JObject instance)
      {
        return instance.Properties().Select(p => p.Name);
      }
    }
#endif
  }
}
#endregion Linq_JObject.cs

/// ********   File: \Linq\JPath.cs
#region Linq_JPath.cs

namespace Newtonsoft.Json.Linq
{
  internal class JPath
  {
    private readonly string _expression;
    public List<object> Parts { get; private set; }

    private int _currentIndex;

    public JPath(string expression)
    {
      ValidationUtils.ArgumentNotNull(expression, "expression");
      _expression = expression;
      Parts = new List<object>();

      ParseMain();
    }

    private void ParseMain()
    {
      int currentPartStartIndex = _currentIndex;
      bool followingIndexer = false;

      while (_currentIndex < _expression.Length)
      {
        char currentChar = _expression[_currentIndex];

        switch (currentChar)
        {
          case '[':
          case '(':
            if (_currentIndex > currentPartStartIndex)
            {
              string member = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
              Parts.Add(member);
            }

            ParseIndexer(currentChar);
            currentPartStartIndex = _currentIndex + 1;
            followingIndexer = true;
            break;
          case ']':
          case ')':
            throw new JsonException("Unexpected character while parsing path: " + currentChar);
          case '.':
            if (_currentIndex > currentPartStartIndex)
            {
              string member = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
              Parts.Add(member);
            }
            currentPartStartIndex = _currentIndex + 1;
            followingIndexer = false;
            break;
          default:
            if (followingIndexer)
              throw new JsonException("Unexpected character following indexer: " + currentChar);
            break;
        }

        _currentIndex++;
      }

      if (_currentIndex > currentPartStartIndex)
      {
        string member = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
        Parts.Add(member);
      }
    }

    private void ParseIndexer(char indexerOpenChar)
    {
      _currentIndex++;

      char indexerCloseChar = (indexerOpenChar == '[') ? ']' : ')';
      int indexerStart = _currentIndex;
      int indexerLength = 0;
      bool indexerClosed = false;

      while (_currentIndex < _expression.Length)
      {
        char currentCharacter = _expression[_currentIndex];
        if (char.IsDigit(currentCharacter))
        {
          indexerLength++;
        }
        else if (currentCharacter == indexerCloseChar)
        {
          indexerClosed = true;
          break;
        }
        else
        {
          throw new JsonException("Unexpected character while parsing path indexer: " + currentCharacter);
        }

        _currentIndex++;
      }

      if (!indexerClosed)
        throw new JsonException("Path ended with open indexer. Expected " + indexerCloseChar);

      if (indexerLength == 0)
        throw new JsonException("Empty path indexer.");

      string indexer = _expression.Substring(indexerStart, indexerLength);
      Parts.Add(Convert.ToInt32(indexer, CultureInfo.InvariantCulture));
    }

    internal JToken Evaluate(JToken root, bool errorWhenNoMatch)
    {
      JToken current = root;

      foreach (object part in Parts)
      {
        string propertyName = part as string;
        if (propertyName != null)
        {
          JObject o = current as JObject;
          if (o != null)
          {
            current = o[propertyName];

            if (current == null && errorWhenNoMatch)
              throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, propertyName));
          }
          else
          {
            if (errorWhenNoMatch)
              throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, propertyName, current.GetType().Name));

            return null;
          }
        }
        else
        {
          int index = (int) part;

          JArray a = current as JArray;
          JConstructor c = current as JConstructor;

          if (a != null)
          {
            if (a.Count <= index)
            {
              if (errorWhenNoMatch)
                throw new IndexOutOfRangeException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture, index));
              
              return null;
            }

            current = a[index];
          }
          else if (c != null)
          {
            if (c.Count <= index)
            {
              if (errorWhenNoMatch)
                throw new IndexOutOfRangeException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture, index));

              return null;
            }

            current = c[index];
          }
          else
          {
            if (errorWhenNoMatch)
              throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, index, current.GetType().Name));

            return null;
          }
        }
      }

      return current;
    }
  }
}
#endregion Linq_JPath.cs

/// ********   File: \Linq\JProperty.cs
#region Linq_JProperty.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a JSON property.
  /// </summary>
  public class JProperty : JContainer
  {
    private readonly List<JToken> _content = new List<JToken>();
    private readonly string _name;

    /// <summary>
    /// Gets the container's children tokens.
    /// </summary>
    /// <value>The container's children tokens.</value>
    protected override IList<JToken> ChildrenTokens
    {
      get { return _content; }
    }

    /// <summary>
    /// Gets the property name.
    /// </summary>
    /// <value>The property name.</value>
    public string Name
    {
      [DebuggerStepThrough]
      get { return _name; }
    }

    /// <summary>
    /// Gets or sets the property value.
    /// </summary>
    /// <value>The property value.</value>
    public JToken Value
    {
      [DebuggerStepThrough]
      get { return (_content.Count > 0) ? _content[0] : null; }
      set
      {
        CheckReentrancy();

        JToken newValue = value ?? new JValue((object) null);

        if (_content.Count == 0)
        {
          InsertItem(0, newValue, false);
        }
        else
        {
          SetItem(0, newValue);
        }
      }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JProperty"/> class from another <see cref="JProperty"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JProperty"/> object to copy from.</param>
    public JProperty(JProperty other)
      : base(other)
    {
      _name = other.Name;
    }

    internal override JToken GetItem(int index)
    {
      if (index != 0)
        throw new ArgumentOutOfRangeException();

      return Value;
    }

    internal override void SetItem(int index, JToken item)
    {
      if (index != 0)
        throw new ArgumentOutOfRangeException();

      if (IsTokenUnchanged(Value, item))
        return;

      if (Parent != null)
        ((JObject)Parent).InternalPropertyChanging(this);

      base.SetItem(0, item);

      if (Parent != null)
        ((JObject)Parent).InternalPropertyChanged(this);
    }

    internal override bool RemoveItem(JToken item)
    {
      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
    }

    internal override void RemoveItemAt(int index)
    {
      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
    }

    internal override void InsertItem(int index, JToken item, bool skipParentCheck)
    {
      if (Value != null)
        throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));

      base.InsertItem(0, item, false);
    }

    internal override bool ContainsItem(JToken item)
    {
      return (Value == item);
    }

    internal override void ClearItems()
    {
      throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
    }

    internal override bool DeepEquals(JToken node)
    {
      JProperty t = node as JProperty;
      return (t != null && _name == t.Name && ContentsEqual(t));
    }

    internal override JToken CloneToken()
    {
      return new JProperty(this);
    }

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public override JTokenType Type
    {
      [DebuggerStepThrough]
      get { return JTokenType.Property; }
    }

    internal JProperty(string name)
    {
      // called from JTokenWriter
      ValidationUtils.ArgumentNotNull(name, "name");

      _name = name;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JProperty"/> class.
    /// </summary>
    /// <param name="name">The property name.</param>
    /// <param name="content">The property content.</param>
    public JProperty(string name, params object[] content)
      : this(name, (object)content)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JProperty"/> class.
    /// </summary>
    /// <param name="name">The property name.</param>
    /// <param name="content">The property content.</param>
    public JProperty(string name, object content)
    {
      ValidationUtils.ArgumentNotNull(name, "name");

      _name = name;

      Value = IsMultiContent(content)
        ? new JArray(content)
        : CreateFromContent(content);
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
    {
      writer.WritePropertyName(_name);

      JToken value = Value;
      if (value != null)
        value.WriteTo(writer, converters);
      else
        writer.WriteNull();
    }

    internal override int GetDeepHashCode()
    {
      return _name.GetHashCode() ^ ((Value != null) ? Value.GetDeepHashCode() : 0);
    }

    /// <summary>
    /// Loads an <see cref="JProperty"/> from a <see cref="JsonReader"/>. 
    /// </summary>
    /// <param name="reader">A <see cref="JsonReader"/> that will be read for the content of the <see cref="JProperty"/>.</param>
    /// <returns>A <see cref="JProperty"/> that contains the JSON that was read from the specified <see cref="JsonReader"/>.</returns>
    public static new JProperty Load(JsonReader reader)
    {
      if (reader.TokenType == JsonToken.None)
      {
        if (!reader.Read())
          throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
      }

      while (reader.TokenType == JsonToken.Comment)
      {
        reader.Read();
      }

      if (reader.TokenType != JsonToken.PropertyName)
        throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));

      JProperty p = new JProperty((string)reader.Value);
      p.SetLineInfo(reader as IJsonLineInfo);

      p.ReadTokenFrom(reader);

      return p;
    }
  }
}
#endregion Linq_JProperty.cs

/// ********   File: \Linq\JPropertyDescriptor.cs
#region Linq_JPropertyDescriptor.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a view of a <see cref="JProperty"/>.
  /// </summary>
  public class JPropertyDescriptor : PropertyDescriptor
  {
    private readonly Type _propertyType;

    /// <summary>
    /// Initializes a new instance of the <see cref="JPropertyDescriptor"/> class.
    /// </summary>
    /// <param name="name">The name.</param>
    /// <param name="propertyType">Type of the property.</param>
    public JPropertyDescriptor(string name, Type propertyType)
      : base(name, null)
    {
      ValidationUtils.ArgumentNotNull(name, "name");
      ValidationUtils.ArgumentNotNull(propertyType, "propertyType");

      _propertyType = propertyType;
    }

    private static JObject CastInstance(object instance)
    {
      return (JObject)instance;
    }

    /// <summary>
    /// When overridden in a derived class, returns whether resetting an object changes its value.
    /// </summary>
    /// <returns>
    /// true if resetting the component changes its value; otherwise, false.
    /// </returns>
    /// <param name="component">The component to test for reset capability. 
    ///                 </param>
    public override bool CanResetValue(object component)
    {
      return false;
    }

    /// <summary>
    /// When overridden in a derived class, gets the current value of the property on a component.
    /// </summary>
    /// <returns>
    /// The value of a property for a given component.
    /// </returns>
    /// <param name="component">The component with the property for which to retrieve the value. 
    ///                 </param>
    public override object GetValue(object component)
    {
      JToken token = CastInstance(component)[Name];

      return token;
    }

    /// <summary>
    /// When overridden in a derived class, resets the value for this property of the component to the default value.
    /// </summary>
    /// <param name="component">The component with the property value that is to be reset to the default value. 
    ///                 </param>
    public override void ResetValue(object component)
    {
    }

    /// <summary>
    /// When overridden in a derived class, sets the value of the component to a different value.
    /// </summary>
    /// <param name="component">The component with the property value that is to be set. 
    ///                 </param><param name="value">The new value. 
    ///                 </param>
    public override void SetValue(object component, object value)
    {
      JToken token = (value is JToken) ? (JToken) value : new JValue(value);

      CastInstance(component)[Name] = token;
    }

    /// <summary>
    /// When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
    /// </summary>
    /// <returns>
    /// true if the property should be persisted; otherwise, false.
    /// </returns>
    /// <param name="component">The component with the property to be examined for persistence. 
    ///                 </param>
    public override bool ShouldSerializeValue(object component)
    {
      return false;
    }

    /// <summary>
    /// When overridden in a derived class, gets the type of the component this property is bound to.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.Type"/> that represents the type of component this property is bound to. When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)"/> or <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)"/> methods are invoked, the object specified might be an instance of this type.
    /// </returns>
    public override Type ComponentType
    {
      get { return typeof(JObject); }
    }

    /// <summary>
    /// When overridden in a derived class, gets a value indicating whether this property is read-only.
    /// </summary>
    /// <returns>
    /// true if the property is read-only; otherwise, false.
    /// </returns>
    public override bool IsReadOnly
    {
      get { return false; }
    }

    /// <summary>
    /// When overridden in a derived class, gets the type of the property.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.Type"/> that represents the type of the property.
    /// </returns>
    public override Type PropertyType
    {
      get { return _propertyType; }
    }

    /// <summary>
    /// Gets the hash code for the name of the member.
    /// </summary>
    /// <value></value>
    /// <returns>
    /// The hash code for the name of the member.
    /// </returns>
    protected override int NameHashCode
    {
      get
      {
        // override property to fix up an error in its documentation
        int nameHashCode = base.NameHashCode;
        return nameHashCode;
      }
    }
  }
}
#endif
#endregion Linq_JPropertyDescriptor.cs

/// ********   File: \Linq\JPropertyKeyedCollection.cs
#region Linq_JPropertyKeyedCollection.cs

namespace Newtonsoft.Json.Linq
{
  internal class JPropertyKeyedCollection : Collection<JToken>
  {
    private static readonly IEqualityComparer<string> Comparer = StringComparer.Ordinal;

    private Dictionary<string, JToken> _dictionary;

    private void AddKey(string key, JToken item)
    {
      EnsureDictionary();
      _dictionary[key] = item;
    }

    protected void ChangeItemKey(JToken item, string newKey)
    {
      if (!ContainsItem(item))
        throw new ArgumentException("The specified item does not exist in this KeyedCollection.");

      string keyForItem = GetKeyForItem(item);
      if (!Comparer.Equals(keyForItem, newKey))
      {
        if (newKey != null)
          AddKey(newKey, item);

        if (keyForItem != null)
          RemoveKey(keyForItem);
      }
    }

    protected override void ClearItems()
    {
      base.ClearItems();

      if (_dictionary != null)
        _dictionary.Clear();
    }

    public bool Contains(string key)
    {
      if (key == null)
        throw new ArgumentNullException("key");

      if (_dictionary != null)
        return _dictionary.ContainsKey(key);

      return false;
    }

    private bool ContainsItem(JToken item)
    {
      if (_dictionary == null)
        return false;

      string key = GetKeyForItem(item);
      JToken value;
      return _dictionary.TryGetValue(key, out value);
    }

    private void EnsureDictionary()
    {
      if (_dictionary == null)
        _dictionary = new Dictionary<string, JToken>(Comparer);
    }

    private string GetKeyForItem(JToken item)
    {
      return ((JProperty)item).Name;
    }

    protected override void InsertItem(int index, JToken item)
    {
      AddKey(GetKeyForItem(item), item);
      base.InsertItem(index, item);
    }

    public bool Remove(string key)
    {
      if (key == null)
        throw new ArgumentNullException("key");

      if (_dictionary != null)
        return _dictionary.ContainsKey(key) && Remove(_dictionary[key]);

      return false;
    }

    protected override void RemoveItem(int index)
    {
      string keyForItem = GetKeyForItem(Items[index]);
      RemoveKey(keyForItem);
      base.RemoveItem(index);
    }

    private void RemoveKey(string key)
    {
      if (_dictionary != null)
        _dictionary.Remove(key);
    }

    protected override void SetItem(int index, JToken item)
    {
      string keyForItem = GetKeyForItem(item);
      string keyAtIndex = GetKeyForItem(Items[index]);

      if (Comparer.Equals(keyAtIndex, keyForItem))
      {
        if (_dictionary != null)
          _dictionary[keyForItem] = item;
      }
      else
      {
        AddKey(keyForItem, item);

        if (keyAtIndex != null)
          RemoveKey(keyAtIndex);
      }
      base.SetItem(index, item);
    }

    public JToken this[string key]
    {
      get
      {
        if (key == null)
          throw new ArgumentNullException("key");

        if (_dictionary != null)
          return _dictionary[key];

        throw new KeyNotFoundException();
      }
    }

    public bool TryGetValue(string key, out JToken value)
    {
      if (_dictionary == null)
      {
        value = null;
        return false;
      }

      return _dictionary.TryGetValue(key, out value);
    }

    public ICollection<string> Keys
    {
      get
      {
        EnsureDictionary();
        return _dictionary.Keys;
      }
    }

    public ICollection<JToken> Values
    {
      get
      {
        EnsureDictionary();
        return _dictionary.Values;
      }
    }

    public bool Compare(JPropertyKeyedCollection other)
    {
      if (this == other)
        return true;

      // dictionaries in JavaScript aren't ordered
      // ignore order when comparing properties
      Dictionary<string, JToken> d1 = _dictionary;
      Dictionary<string, JToken> d2 = other._dictionary;

      if (d1 == null && d2 == null)
        return true;

      if (d1 == null)
        return (d2.Count == 0);

      if (d2 == null)
        return (d1.Count == 0);

      if (d1.Count != d2.Count)
        return false;

      foreach (KeyValuePair<string, JToken> keyAndProperty in d1)
      {
        JToken secondValue;
        if (!d2.TryGetValue(keyAndProperty.Key, out secondValue))
          return false;

        JProperty p1 = (JProperty)keyAndProperty.Value;
        JProperty p2 = (JProperty)secondValue;

        if (!p1.Value.DeepEquals(p2.Value))
          return false;
      }

      return true;
    }
  }
}
#endregion Linq_JPropertyKeyedCollection.cs

/// ********   File: \Linq\JRaw.cs
#region Linq_JRaw.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a raw JSON string.
  /// </summary>
  public class JRaw : JValue
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JRaw"/> class from another <see cref="JRaw"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JRaw"/> object to copy from.</param>
    public JRaw(JRaw other)
      : base(other)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JRaw"/> class.
    /// </summary>
    /// <param name="rawJson">The raw json.</param>
    public JRaw(object rawJson)
      : base(rawJson, JTokenType.Raw)
    {
    }

    /// <summary>
    /// Creates an instance of <see cref="JRaw"/> with the content of the reader's current token.
    /// </summary>
    /// <param name="reader">The reader.</param>
    /// <returns>An instance of <see cref="JRaw"/> with the content of the reader's current token.</returns>
    public static JRaw Create(JsonReader reader)
    {
      using (StringWriter sw = new StringWriter(CultureInfo.InvariantCulture))
      using (JsonTextWriter jsonWriter = new JsonTextWriter(sw))
      {
        jsonWriter.WriteToken(reader);

        return new JRaw(sw.ToString());
      }
    }

    internal override JToken CloneToken()
    {
      return new JRaw(this);
    }
  }
}
#endregion Linq_JRaw.cs

/// ********   File: \Linq\JToken.cs
#region Linq_JToken.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents an abstract JSON token.
  /// </summary>
  public abstract class JToken : IJEnumerable<JToken>, IJsonLineInfo
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
, ICloneable
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
, IDynamicMetaObjectProvider
#endif
  {
    private JContainer _parent;
    private JToken _previous;
    private JToken _next;
    private static JTokenEqualityComparer _equalityComparer;

    private int? _lineNumber;
    private int? _linePosition;

    private static readonly JTokenType[] BooleanTypes = new[] { JTokenType.Integer, JTokenType.Float, JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.Boolean };
    private static readonly JTokenType[] NumberTypes = new[] { JTokenType.Integer, JTokenType.Float, JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.Boolean };
    private static readonly JTokenType[] StringTypes = new[] { JTokenType.Date, JTokenType.Integer, JTokenType.Float, JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.Boolean, JTokenType.Bytes, JTokenType.Guid, JTokenType.TimeSpan, JTokenType.Uri };
    private static readonly JTokenType[] GuidTypes = new[] { JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.Guid };
    private static readonly JTokenType[] TimeSpanTypes = new[] { JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.TimeSpan };
    private static readonly JTokenType[] UriTypes = new[] { JTokenType.String, JTokenType.Comment, JTokenType.Raw, JTokenType.Uri };
    private static readonly JTokenType[] CharTypes = new[] { JTokenType.Integer, JTokenType.Float, JTokenType.String, JTokenType.Comment, JTokenType.Raw };
    private static readonly JTokenType[] DateTimeTypes = new[] { JTokenType.Date, JTokenType.String, JTokenType.Comment, JTokenType.Raw };
    private static readonly JTokenType[] BytesTypes = new[] { JTokenType.Bytes, JTokenType.String, JTokenType.Comment, JTokenType.Raw };

    /// <summary>
    /// Gets a comparer that can compare two tokens for value equality.
    /// </summary>
    /// <value>A <see cref="JTokenEqualityComparer"/> that can compare two nodes for value equality.</value>
    public static JTokenEqualityComparer EqualityComparer
    {
      get
      {
        if (_equalityComparer == null)
          _equalityComparer = new JTokenEqualityComparer();

        return _equalityComparer;
      }
    }

    /// <summary>
    /// Gets or sets the parent.
    /// </summary>
    /// <value>The parent.</value>
    public JContainer Parent
    {
      [DebuggerStepThrough]
      get { return _parent; }
      internal set { _parent = value; }
    }

    /// <summary>
    /// Gets the root <see cref="JToken"/> of this <see cref="JToken"/>.
    /// </summary>
    /// <value>The root <see cref="JToken"/> of this <see cref="JToken"/>.</value>
    public JToken Root
    {
      get
      {
        JContainer parent = Parent;
        if (parent == null)
          return this;

        while (parent.Parent != null)
        {
          parent = parent.Parent;
        }

        return parent;
      }
    }

    internal abstract JToken CloneToken();
    internal abstract bool DeepEquals(JToken node);

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public abstract JTokenType Type { get; }

    /// <summary>
    /// Gets a value indicating whether this token has childen tokens.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this token has child values; otherwise, <c>false</c>.
    /// </value>
    public abstract bool HasValues { get; }

    /// <summary>
    /// Compares the values of two tokens, including the values of all descendant tokens.
    /// </summary>
    /// <param name="t1">The first <see cref="JToken"/> to compare.</param>
    /// <param name="t2">The second <see cref="JToken"/> to compare.</param>
    /// <returns>true if the tokens are equal; otherwise false.</returns>
    public static bool DeepEquals(JToken t1, JToken t2)
    {
      return (t1 == t2 || (t1 != null && t2 != null && t1.DeepEquals(t2)));
    }

    /// <summary>
    /// Gets the next sibling token of this node.
    /// </summary>
    /// <value>The <see cref="JToken"/> that contains the next sibling token.</value>
    public JToken Next
    {
      get { return _next; }
      internal set { _next = value; }
    }

    /// <summary>
    /// Gets the previous sibling token of this node.
    /// </summary>
    /// <value>The <see cref="JToken"/> that contains the previous sibling token.</value>
    public JToken Previous
    {
      get { return _previous; }
      internal set { _previous = value; }
    }

    internal JToken()
    {
    }

    /// <summary>
    /// Adds the specified content immediately after this token.
    /// </summary>
    /// <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
    public void AddAfterSelf(object content)
    {
      if (_parent == null)
        throw new InvalidOperationException("The parent is missing.");

      int index = _parent.IndexOfItem(this);
      _parent.AddInternal(index + 1, content, false);
    }

    /// <summary>
    /// Adds the specified content immediately before this token.
    /// </summary>
    /// <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
    public void AddBeforeSelf(object content)
    {
      if (_parent == null)
        throw new InvalidOperationException("The parent is missing.");

      int index = _parent.IndexOfItem(this);
      _parent.AddInternal(index, content, false);
    }

    /// <summary>
    /// Returns a collection of the ancestor tokens of this token.
    /// </summary>
    /// <returns>A collection of the ancestor tokens of this token.</returns>
    public IEnumerable<JToken> Ancestors()
    {
      for (JToken parent = Parent; parent != null; parent = parent.Parent)
      {
        yield return parent;
      }
    }

    /// <summary>
    /// Returns a collection of the sibling tokens after this token, in document order.
    /// </summary>
    /// <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
    public IEnumerable<JToken> AfterSelf()
    {
      if (Parent == null)
        yield break;

      for (JToken o = Next; o != null; o = o.Next)
      {
        yield return o;
      }
    }

    /// <summary>
    /// Returns a collection of the sibling tokens before this token, in document order.
    /// </summary>
    /// <returns>A collection of the sibling tokens before this token, in document order.</returns>
    public IEnumerable<JToken> BeforeSelf()
    {
      for (JToken o = Parent.First; o != this; o = o.Next)
      {
        yield return o;
      }
    }

    /// <summary>
    /// Gets the <see cref="JToken"/> with the specified key.
    /// </summary>
    /// <value>The <see cref="JToken"/> with the specified key.</value>
    public virtual JToken this[object key]
    {
      get { throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType())); }
      set { throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType())); }
    }

    /// <summary>
    /// Gets the <see cref="JToken"/> with the specified key converted to the specified type.
    /// </summary>
    /// <typeparam name="T">The type to convert the token to.</typeparam>
    /// <param name="key">The token key.</param>
    /// <returns>The converted token value.</returns>
    public virtual T Value<T>(object key)
    {
      JToken token = this[key];

      return Extensions.Convert<JToken, T>(token);
    }

    /// <summary>
    /// Get the first child token of this token.
    /// </summary>
    /// <value>A <see cref="JToken"/> containing the first child token of the <see cref="JToken"/>.</value>
    public virtual JToken First
    {
      get { throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType())); }
    }

    /// <summary>
    /// Get the last child token of this token.
    /// </summary>
    /// <value>A <see cref="JToken"/> containing the last child token of the <see cref="JToken"/>.</value>
    public virtual JToken Last
    {
      get { throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType())); }
    }

    /// <summary>
    /// Returns a collection of the child tokens of this token, in document order.
    /// </summary>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="JToken"/> containing the child tokens of this <see cref="JToken"/>, in document order.</returns>
    public virtual JEnumerable<JToken> Children()
    {
      return JEnumerable<JToken>.Empty;
    }

    /// <summary>
    /// Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
    /// </summary>
    /// <typeparam name="T">The type to filter the child tokens on.</typeparam>
    /// <returns>A <see cref="JEnumerable{T}"/> containing the child tokens of this <see cref="JToken"/>, in document order.</returns>
    public JEnumerable<T> Children<T>() where T : JToken
    {
      return new JEnumerable<T>(Children().OfType<T>());
    }

    /// <summary>
    /// Returns a collection of the child values of this token, in document order.
    /// </summary>
    /// <typeparam name="T">The type to convert the values to.</typeparam>
    /// <returns>A <see cref="IEnumerable{T}"/> containing the child values of this <see cref="JToken"/>, in document order.</returns>
    public virtual IEnumerable<T> Values<T>()
    {
      throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
    }

    /// <summary>
    /// Removes this token from its parent.
    /// </summary>
    public void Remove()
    {
      if (_parent == null)
        throw new InvalidOperationException("The parent is missing.");

      _parent.RemoveItem(this);
    }

    /// <summary>
    /// Replaces this token with the specified token.
    /// </summary>
    /// <param name="value">The value.</param>
    public void Replace(JToken value)
    {
      if (_parent == null)
        throw new InvalidOperationException("The parent is missing.");

      _parent.ReplaceItem(this, value);
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

    /// <summary>
    /// Returns the indented JSON for this token.
    /// </summary>
    /// <returns>
    /// The indented JSON for this token.
    /// </returns>
    public override string ToString()
    {
      return ToString(Formatting.Indented);
    }

    /// <summary>
    /// Returns the JSON for this token using the given formatting and converters.
    /// </summary>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    /// <returns>The JSON for this token using the given formatting and converters.</returns>
    public string ToString(Formatting formatting, params JsonConverter[] converters)
    {
      using (StringWriter sw = new StringWriter(CultureInfo.InvariantCulture))
      {
        JsonTextWriter jw = new JsonTextWriter(sw);
        jw.Formatting = formatting;

        WriteTo(jw, converters);

        return sw.ToString();
      }
    }

    private static JValue EnsureValue(JToken value)
    {
      if (value == null)
        throw new ArgumentNullException("value");

      if (value is JProperty)
        value = ((JProperty)value).Value;

      JValue v = value as JValue;

      return v;
    }

    private static string GetType(JToken token)
    {
      ValidationUtils.ArgumentNotNull(token, "token");

      if (token is JProperty)
        token = ((JProperty)token).Value;

      return token.Type.ToString();
    }

    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
    {
      return (Array.IndexOf(validTypes, o.Type) != -1) || (nullable && (o.Type == JTokenType.Null || o.Type == JTokenType.Undefined));
    }

    #region Cast from operators
    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Boolean"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator bool(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, BooleanTypes, false))
        throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToBoolean(v.Value, CultureInfo.InvariantCulture);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.DateTimeOffset"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator DateTimeOffset(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, DateTimeTypes, false))
        throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value is DateTimeOffset)
        return (DateTimeOffset)v.Value;
      if (v.Value is string)
        return DateTimeOffset.Parse((string)v.Value);
      return new DateTimeOffset(Convert.ToDateTime(v.Value, CultureInfo.InvariantCulture));
    }
#endif

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Boolean}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator bool?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, BooleanTypes, true))
        throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (bool?)Convert.ToBoolean(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Int64"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator long(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToInt64(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator DateTime?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, DateTimeTypes, true))
        throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (DateTime?)Convert.ToDateTime(v.Value, CultureInfo.InvariantCulture) : null;
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator DateTimeOffset?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, DateTimeTypes, true))
        throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value == null)
        return null;
      if (v.Value is DateTimeOffset)
        return (DateTimeOffset?)v.Value;
      if (v.Value is string)
        return DateTimeOffset.Parse((string)v.Value);
      return new DateTimeOffset(Convert.ToDateTime(v.Value, CultureInfo.InvariantCulture));
    }
#endif

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator decimal?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (decimal?)Convert.ToDecimal(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Double}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator double?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (double?)Convert.ToDouble(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Char}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator char?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, CharTypes, true))
        throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (char?)Convert.ToChar(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Int32"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator int(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToInt32(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Int16"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator short(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToInt16(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.UInt16"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator ushort(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToUInt16(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Char"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator char(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, CharTypes, false))
        throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToChar(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Byte"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator byte(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToByte(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator int?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (int?)Convert.ToInt32(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Int16}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator short?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (short?)Convert.ToInt16(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{UInt16}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator ushort?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (ushort?)Convert.ToUInt16(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Byte}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator byte?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (byte?)Convert.ToByte(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.DateTime"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator DateTime(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, DateTimeTypes, false))
        throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToDateTime(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Int64}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator long?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (long?)Convert.ToInt64(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{Single}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator float?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (float?)Convert.ToSingle(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Decimal"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator decimal(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToDecimal(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{UInt32}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator uint?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (uint?)Convert.ToUInt32(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="Nullable{UInt64}"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator ulong?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, true))
        throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value != null) ? (ulong?)Convert.ToUInt64(v.Value, CultureInfo.InvariantCulture) : null;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Double"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator double(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToDouble(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Single"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator float(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToSingle(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.String"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator string(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, StringTypes, true))
        throw new ArgumentException("Can not convert {0} to String.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value == null)
        return null;
      if (v.Value is byte[])
        return Convert.ToBase64String((byte[]) v.Value);

      return Convert.ToString(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.UInt32"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator uint(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToUInt32(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.UInt64"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    [CLSCompliant(false)]
    public static explicit operator ulong(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, NumberTypes, false))
        throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return Convert.ToUInt64(v.Value, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="T:System.Byte[]"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator byte[](JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, BytesTypes, false))
        throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value is string)
        return Convert.FromBase64String(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
      return (byte[])v.Value;
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Guid"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator Guid(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, GuidTypes, false))
        throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value is Guid) ? (Guid)v.Value : new Guid(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Guid"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator Guid?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, GuidTypes, true))
        throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value == null)
        return null;

      return (v.Value is Guid) ? (Guid)v.Value : new Guid(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.TimeSpan"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator TimeSpan(JToken value)
    {
      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, TimeSpanTypes, false))
        throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      return (v.Value is TimeSpan) ? (TimeSpan)v.Value : ConvertUtils.ParseTimeSpan(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.TimeSpan"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator TimeSpan?(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, TimeSpanTypes, true))
        throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value == null)
        return null;

      return (v.Value is TimeSpan) ? (TimeSpan)v.Value : ConvertUtils.ParseTimeSpan(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Performs an explicit conversion from <see cref="Newtonsoft.Json.Linq.JToken"/> to <see cref="System.Uri"/>.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>The result of the conversion.</returns>
    public static explicit operator Uri(JToken value)
    {
      if (value == null)
        return null;

      JValue v = EnsureValue(value);
      if (v == null || !ValidateToken(v, UriTypes, true))
        throw new ArgumentException("Can not convert {0} to Uri.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));

      if (v.Value == null)
        return null;

      return (v.Value is Uri) ? (Uri)v.Value : new Uri(Convert.ToString(v.Value, CultureInfo.InvariantCulture));
    }
    #endregion

    #region Cast to operators
    /// <summary>
    /// Performs an implicit conversion from <see cref="Boolean"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(bool value)
    {
      return new JValue(value);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Performs an implicit conversion from <see cref="DateTimeOffset"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(DateTimeOffset value)
    {
      return new JValue(value);
    }
#endif

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Boolean}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(bool? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Int64}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(long value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{DateTime}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(DateTime? value)
    {
      return new JValue(value);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{DateTimeOffset}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(DateTimeOffset? value)
    {
      return new JValue(value);
    }
#endif

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Decimal}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(decimal? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Double}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(double? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Int16"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(short value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="UInt16"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(ushort value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Int32"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(int value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Int32}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(int? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="DateTime"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(DateTime value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Int64}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(long? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Single}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(float? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Decimal"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(decimal value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Int16}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(short? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{UInt16}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(ushort? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{UInt32}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(uint? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{UInt64}"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(ulong? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Double"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(double value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Single"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(float value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="String"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(string value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="UInt32"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(uint value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="UInt64"/> to <see cref="JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    [CLSCompliant(false)]
    public static implicit operator JToken(ulong value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="T:System.Byte[]"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(byte[] value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="T:System.Uri"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(Uri value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="T:System.TimeSpan"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(TimeSpan value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{TimeSpan}"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(TimeSpan? value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="T:System.Guid"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(Guid value)
    {
      return new JValue(value);
    }

    /// <summary>
    /// Performs an implicit conversion from <see cref="Nullable{Guid}"/> to <see cref="Newtonsoft.Json.Linq.JToken"/>.
    /// </summary>
    /// <param name="value">The value to create a <see cref="JValue"/> from.</param>
    /// <returns>The <see cref="JValue"/> initialized with the specified value.</returns>
    public static implicit operator JToken(Guid? value)
    {
      return new JValue(value);
    }
    #endregion

    IEnumerator IEnumerable.GetEnumerator()
    {
      return ((IEnumerable<JToken>)this).GetEnumerator();
    }

    IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
    {
      return Children().GetEnumerator();
    }

    internal abstract int GetDeepHashCode();

    IJEnumerable<JToken> IJEnumerable<JToken>.this[object key]
    {
      get { return this[key]; }
    }

    /// <summary>
    /// Creates an <see cref="JsonReader"/> for this token.
    /// </summary>
    /// <returns>An <see cref="JsonReader"/> that can be used to read this token and its descendants.</returns>
    public JsonReader CreateReader()
    {
      return new JTokenReader(this);
    }

    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
    {
      ValidationUtils.ArgumentNotNull(o, "o");
      ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");

      JToken token;
      using (JTokenWriter jsonWriter = new JTokenWriter())
      {
        jsonSerializer.Serialize(jsonWriter, o);
        token = jsonWriter.Token;
      }

      return token;
    }

    /// <summary>
    /// Creates a <see cref="JToken"/> from an object.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JToken"/>.</param>
    /// <returns>A <see cref="JToken"/> with the value of the specified object</returns>
    public static JToken FromObject(object o)
    {
      return FromObjectInternal(o, new JsonSerializer());
    }

    /// <summary>
    /// Creates a <see cref="JToken"/> from an object using the specified <see cref="JsonSerializer"/>.
    /// </summary>
    /// <param name="o">The object that will be used to create <see cref="JToken"/>.</param>
    /// <param name="jsonSerializer">The <see cref="JsonSerializer"/> that will be used when reading the object.</param>
    /// <returns>A <see cref="JToken"/> with the value of the specified object</returns>
    public static JToken FromObject(object o, JsonSerializer jsonSerializer)
    {
      return FromObjectInternal(o, jsonSerializer);
    }

    /// <summary>
    /// Creates the specified .NET type from the <see cref="JToken"/>.
    /// </summary>
    /// <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
    /// <returns>The new object created from the JSON value.</returns>
    public T ToObject<T>()
    {
      return (T)ToObject(typeof(T));
    }

    /// <summary>
    /// Creates the specified .NET type from the <see cref="JToken"/>.
    /// </summary>
    /// <param name="objectType">The object type that the token will be deserialized to.</param>
    /// <returns>The new object created from the JSON value.</returns>
    public object ToObject(Type objectType)
    {
      return ToObject(objectType, false);
    }

    private object ToObject(Type objectType, bool isNullable)
    {
      TypeCode typeCode = ConvertUtils.GetTypeCode(objectType);

      switch (typeCode)
      {
        case TypeCode.Object:
          if (!isNullable && ReflectionUtils.IsNullableType(objectType))
            return ToObject(Nullable.GetUnderlyingType(objectType), true);

          // fall back to standard JsonSerializer
          break;
        case TypeCode.Boolean:
          if (isNullable)
            return (bool?) this;

          return (bool) this;
        case TypeCode.Char:
          if (isNullable)
            return (char?) this;

          return (char) this;
        case TypeCode.SByte:
          if (isNullable)
            return (sbyte?) this;

          return (sbyte) this;
        case TypeCode.Byte:
          if (isNullable)
            return (byte?) this;

          return (byte) this;
        case TypeCode.Int16:
          if (isNullable)
            return (short?) this;

          return (short) this;
        case TypeCode.UInt16:
          if (isNullable)
            return (ushort?) this;

          return (ushort) this;
        case TypeCode.Int32:
          if (isNullable)
            return (int?) this;

          return (int) this;
        case TypeCode.UInt32:
          if (isNullable)
            return (uint?) this;

          return (uint) this;
        case TypeCode.Int64:
          if (isNullable)
            return (long?) this;

          return (long) this;
        case TypeCode.UInt64:
          if (isNullable)
            return (ulong?) this;

          return (ulong) this;
        case TypeCode.Single:
          if (isNullable)
            return (float?) this;

          return (float) this;
        case TypeCode.Double:
          if (isNullable)
            return (double?) this;

          return (double) this;
        case TypeCode.Decimal:
          if (isNullable)
            return (decimal?) this;

          return (decimal) this;
        case TypeCode.DateTime:
          if (isNullable)
            return (DateTime?) this;

          return (DateTime) this;
        case TypeCode.String:
          return (string) this;
      }

#if !PocketPC && !NET20
      if (objectType == typeof (DateTimeOffset))
      {
        if (isNullable)
          return (DateTimeOffset?) this;

        return (DateTimeOffset) this;
      }
#endif
      if (objectType == typeof (Guid))
      {
        if (isNullable)
          return (Guid?) this;

        return (Guid) this;
      }
      if (objectType == typeof (Uri))
      {
        return (Uri) this;
      }
      if (objectType == typeof (TimeSpan))
      {
        if (isNullable)
          return (TimeSpan?) this;

        return (TimeSpan) this;
      }

      return ToObject(objectType, new JsonSerializer());
    }

    /// <summary>
    /// Creates the specified .NET type from the <see cref="JToken"/> using the specified <see cref="JsonSerializer"/>.
    /// </summary>
    /// <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
    /// <param name="jsonSerializer">The <see cref="JsonSerializer"/> that will be used when creating the object.</param>
    /// <returns>The new object created from the JSON value.</returns>
    public T ToObject<T>(JsonSerializer jsonSerializer)
    {
      return (T)ToObject(typeof(T), jsonSerializer);
    }

    /// <summary>
    /// Creates the specified .NET type from the <see cref="JToken"/> using the specified <see cref="JsonSerializer"/>.
    /// </summary>
    /// <param name="objectType">The object type that the token will be deserialized to.</param>
    /// <param name="jsonSerializer">The <see cref="JsonSerializer"/> that will be used when creating the object.</param>
    /// <returns>The new object created from the JSON value.</returns>
    public object ToObject(Type objectType, JsonSerializer jsonSerializer)
    {
      ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");

      using (JTokenReader jsonReader = new JTokenReader(this))
      {
        return jsonSerializer.Deserialize(jsonReader, objectType);
      }
    }

    /// <summary>
    /// Creates a <see cref="JToken"/> from a <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">An <see cref="JsonReader"/> positioned at the token to read into this <see cref="JToken"/>.</param>
    /// <returns>
    /// An <see cref="JToken"/> that contains the token and its descendant tokens
    /// that were read from the reader. The runtime type of the token is determined
    /// by the token type of the first token encountered in the reader.
    /// </returns>
    public static JToken ReadFrom(JsonReader reader)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      if (reader.TokenType == JsonToken.None)
      {
        if (!reader.Read())
          throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
      }

      if (reader.TokenType == JsonToken.StartObject)
        return JObject.Load(reader);

      if (reader.TokenType == JsonToken.StartArray)
        return JArray.Load(reader);

      if (reader.TokenType == JsonToken.PropertyName)
        return JProperty.Load(reader);

      if (reader.TokenType == JsonToken.StartConstructor)
        return JConstructor.Load(reader);

      if (!JsonReader.IsStartToken(reader.TokenType))
        return new JValue(reader.Value);

      throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
    }

    /// <summary>
    /// Load a <see cref="JToken"/> from a string that contains JSON.
    /// </summary>
    /// <param name="json">A <see cref="String"/> that contains JSON.</param>
    /// <returns>A <see cref="JToken"/> populated from the string that contains JSON.</returns>
    public static JToken Parse(string json)
    {
      JsonReader reader = new JsonTextReader(new StringReader(json));

      JToken t = Load(reader);

      if (reader.Read() && reader.TokenType != JsonToken.Comment)
        throw JsonReaderException.Create(reader, "Additional text found in JSON string after parsing content.");

      return t;
    }

    /// <summary>
    /// Creates a <see cref="JToken"/> from a <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">An <see cref="JsonReader"/> positioned at the token to read into this <see cref="JToken"/>.</param>
    /// <returns>
    /// An <see cref="JToken"/> that contains the token and its descendant tokens
    /// that were read from the reader. The runtime type of the token is determined
    /// by the token type of the first token encountered in the reader.
    /// </returns>
    public static JToken Load(JsonReader reader)
    {
      return ReadFrom(reader);
    }

    internal void SetLineInfo(IJsonLineInfo lineInfo)
    {
      if (lineInfo == null || !lineInfo.HasLineInfo())
        return;

      SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
    }

    internal void SetLineInfo(int lineNumber, int linePosition)
    {
      _lineNumber = lineNumber;
      _linePosition = linePosition;
    }

    bool IJsonLineInfo.HasLineInfo()
    {
      return (_lineNumber != null && _linePosition != null);
    }

    int IJsonLineInfo.LineNumber
    {
      get { return _lineNumber ?? 0; }
    }

    int IJsonLineInfo.LinePosition
    {
      get { return _linePosition ?? 0; }
    }

    /// <summary>
    /// Selects the token that matches the object path.
    /// </summary>
    /// <param name="path">
    /// The object path from the current <see cref="JToken"/> to the <see cref="JToken"/>
    /// to be returned. This must be a string of property names or array indexes separated
    /// by periods, such as <code>Tables[0].DefaultView[0].Price</code> in C# or
    /// <code>Tables(0).DefaultView(0).Price</code> in Visual Basic.
    /// </param>
    /// <returns>The <see cref="JToken"/> that matches the object path or a null reference if no matching token is found.</returns>
    public JToken SelectToken(string path)
    {
      return SelectToken(path, false);
    }

    /// <summary>
    /// Selects the token that matches the object path.
    /// </summary>
    /// <param name="path">
    /// The object path from the current <see cref="JToken"/> to the <see cref="JToken"/>
    /// to be returned. This must be a string of property names or array indexes separated
    /// by periods, such as <code>Tables[0].DefaultView[0].Price</code> in C# or
    /// <code>Tables(0).DefaultView(0).Price</code> in Visual Basic.
    /// </param>
    /// <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no token is found.</param>
    /// <returns>The <see cref="JToken"/> that matches the object path.</returns>
    public JToken SelectToken(string path, bool errorWhenNoMatch)
    {
      JPath p = new JPath(path);
      return p.Evaluate(this, errorWhenNoMatch);
    }

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    /// <summary>
    /// Returns the <see cref="T:System.Dynamic.DynamicMetaObject"/> responsible for binding operations performed on this object.
    /// </summary>
    /// <param name="parameter">The expression tree representation of the runtime value.</param>
    /// <returns>
    /// The <see cref="T:System.Dynamic.DynamicMetaObject"/> to bind this object.
    /// </returns>
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter)
    {
      return new DynamicProxyMetaObject<JToken>(parameter, this, new DynamicProxy<JToken>(), true);
    }

    /// <summary>
    /// Returns the <see cref="T:System.Dynamic.DynamicMetaObject"/> responsible for binding operations performed on this object.
    /// </summary>
    /// <param name="parameter">The expression tree representation of the runtime value.</param>
    /// <returns>
    /// The <see cref="T:System.Dynamic.DynamicMetaObject"/> to bind this object.
    /// </returns>
    DynamicMetaObject IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
    {
      return GetMetaObject(parameter);
    }
#endif

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    object ICloneable.Clone()
    {
      return DeepClone();
    }
#endif

    /// <summary>
    /// Creates a new instance of the <see cref="JToken"/>. All child tokens are recursively cloned.
    /// </summary>
    /// <returns>A new instance of the <see cref="JToken"/>.</returns>
    public JToken DeepClone()
    {
      return CloneToken();
    }
  }
}
#endregion Linq_JToken.cs

/// ********   File: \Linq\JTokenEqualityComparer.cs
#region Linq_JTokenEqualityComparer.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Compares tokens to determine whether they are equal.
  /// </summary>
  public class JTokenEqualityComparer : IEqualityComparer<JToken>
  {
    /// <summary>
    /// Determines whether the specified objects are equal.
    /// </summary>
    /// <param name="x">The first object of type <see cref="JToken"/> to compare.</param>
    /// <param name="y">The second object of type <see cref="JToken"/> to compare.</param>
    /// <returns>
    /// true if the specified objects are equal; otherwise, false.
    /// </returns>
    public bool Equals(JToken x, JToken y)
    {
      return JToken.DeepEquals(x, y);
    }

    /// <summary>
    /// Returns a hash code for the specified object.
    /// </summary>
    /// <param name="obj">The <see cref="T:System.Object"/> for which a hash code is to be returned.</param>
    /// <returns>A hash code for the specified object.</returns>
    /// <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj"/> is a reference type and <paramref name="obj"/> is null.</exception>
    public int GetHashCode(JToken obj)
    {
      if (obj == null)
        return 0;

      return obj.GetDeepHashCode();
    }
  }
}
#endregion Linq_JTokenEqualityComparer.cs

/// ********   File: \Linq\JTokenReader.cs
#region Linq_JTokenReader.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
  /// </summary>
  public class JTokenReader : JsonReader, IJsonLineInfo
  {
    private readonly JToken _root;
    private JToken _parent;
    private JToken _current;

    /// <summary>
    /// Initializes a new instance of the <see cref="JTokenReader"/> class.
    /// </summary>
    /// <param name="token">The token to read from.</param>
    public JTokenReader(JToken token)
    {
      ValidationUtils.ArgumentNotNull(token, "token");

      _root = token;
      _current = token;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
    /// </returns>
    public override byte[] ReadAsBytes()
    {
      return ReadAsBytesInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Decimal}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override decimal? ReadAsDecimal()
    {
      return ReadAsDecimalInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Int32}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override int? ReadAsInt32()
    {
      return ReadAsInt32Internal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="String"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override string ReadAsString()
    {
      return ReadAsStringInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTime? ReadAsDateTime()
    {
      return ReadAsDateTimeInternal();
    }

#if !NET20
    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{DateTimeOffset}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTimeOffset? ReadAsDateTimeOffset()
    {
      return ReadAsDateTimeOffsetInternal();
    }
#endif

    internal override bool ReadInternal()
    {
      if (CurrentState != State.Start)
      {
        JContainer container = _current as JContainer;
        if (container != null && _parent != container)
          return ReadInto(container);
        else
          return ReadOver(_current);
      }

      SetToken(_current);
      return true;
    }

    /// <summary>
    /// Reads the next JSON token from the stream.
    /// </summary>
    /// <returns>
    /// true if the next token was read successfully; false if there are no more tokens to read.
    /// </returns>
    public override bool Read()
    {
      _readType = ReadType.Read;

      return ReadInternal();
    }

    private bool ReadOver(JToken t)
    {
      if (t == _root)
        return ReadToEnd();

      JToken next = t.Next;
      if ((next == null || next == t) || t == t.Parent.Last)
      {
        if (t.Parent == null)
          return ReadToEnd();

        return SetEnd(t.Parent);
      }
      else
      {
        _current = next;
        SetToken(_current);
        return true;
      }
    }

    private bool ReadToEnd()
    {
      SetToken(JsonToken.None);
      return false;
    }

    private bool IsEndElement
    {
      get { return (_current == _parent); }
    }

    private JsonToken? GetEndToken(JContainer c)
    {
      switch (c.Type)
      {
        case JTokenType.Object:
          return JsonToken.EndObject;
        case JTokenType.Array:
          return JsonToken.EndArray;
        case JTokenType.Constructor:
          return JsonToken.EndConstructor;
        case JTokenType.Property:
          return null;
        default:
          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type.");
      }
    }

    private bool ReadInto(JContainer c)
    {
      JToken firstChild = c.First;
      if (firstChild == null)
      {
        return SetEnd(c);
      }
      else
      {
        SetToken(firstChild);
        _current = firstChild;
        _parent = c;
        return true;
      }
    }

    private bool SetEnd(JContainer c)
    {
      JsonToken? endToken = GetEndToken(c);
      if (endToken != null)
      {
        SetToken(endToken.Value);
        _current = c;
        _parent = c;
        return true;
      }
      else
      {
        return ReadOver(c);
      }
    }

    private void SetToken(JToken token)
    {
      switch (token.Type)
      {
        case JTokenType.Object:
          SetToken(JsonToken.StartObject);
          break;
        case JTokenType.Array:
          SetToken(JsonToken.StartArray);
          break;
        case JTokenType.Constructor:
          SetToken(JsonToken.StartConstructor);
          break;
        case JTokenType.Property:
          SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
          break;
        case JTokenType.Comment:
          SetToken(JsonToken.Comment, ((JValue)token).Value);
          break;
        case JTokenType.Integer:
          SetToken(JsonToken.Integer, ((JValue)token).Value);
          break;
        case JTokenType.Float:
          SetToken(JsonToken.Float, ((JValue)token).Value);
          break;
        case JTokenType.String:
          SetToken(JsonToken.String, ((JValue)token).Value);
          break;
        case JTokenType.Boolean:
          SetToken(JsonToken.Boolean, ((JValue)token).Value);
          break;
        case JTokenType.Null:
          SetToken(JsonToken.Null, ((JValue)token).Value);
          break;
        case JTokenType.Undefined:
          SetToken(JsonToken.Undefined, ((JValue)token).Value);
          break;
        case JTokenType.Date:
          SetToken(JsonToken.Date, ((JValue)token).Value);
          break;
        case JTokenType.Raw:
          SetToken(JsonToken.Raw, ((JValue)token).Value);
          break;
        case JTokenType.Bytes:
          SetToken(JsonToken.Bytes, ((JValue)token).Value);
          break;
        case JTokenType.Guid:
          SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
          break;
        case JTokenType.Uri:
          SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
          break;
        case JTokenType.TimeSpan:
          SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
          break;
        default:
          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
      }
    }

    private string SafeToString(object value)
    {
      return (value != null) ? value.ToString() : null;
    }

    bool IJsonLineInfo.HasLineInfo()
    {
      if (CurrentState == State.Start)
        return false;

      IJsonLineInfo info = IsEndElement ? null : _current;
      return (info != null && info.HasLineInfo());
    }

    int IJsonLineInfo.LineNumber
    {
      get
      {
        if (CurrentState == State.Start)
          return 0;

        IJsonLineInfo info = IsEndElement ? null : _current;
        if (info != null)
          return info.LineNumber;
        
        return 0;
      }
    }

    int IJsonLineInfo.LinePosition
    {
      get
      {
        if (CurrentState == State.Start)
          return 0;

        IJsonLineInfo info = IsEndElement ? null : _current;
        if (info != null)
          return info.LinePosition;

        return 0;
      }
    }
  }
}
#endregion Linq_JTokenReader.cs

/// ********   File: \Linq\JTokenType.cs
#region Linq_JTokenType.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Specifies the type of token.
  /// </summary>
  public enum JTokenType
  {
    /// <summary>
    /// No token type has been set.
    /// </summary>
    None,
    /// <summary>
    /// A JSON object.
    /// </summary>
    Object,
    /// <summary>
    /// A JSON array.
    /// </summary>
    Array,
    /// <summary>
    /// A JSON constructor.
    /// </summary>
    Constructor,
    /// <summary>
    /// A JSON object property.
    /// </summary>
    Property,
    /// <summary>
    /// A comment.
    /// </summary>
    Comment,
    /// <summary>
    /// An integer value.
    /// </summary>
    Integer,
    /// <summary>
    /// A float value.
    /// </summary>
    Float,
    /// <summary>
    /// A string value.
    /// </summary>
    String,
    /// <summary>
    /// A boolean value.
    /// </summary>
    Boolean,
    /// <summary>
    /// A null value.
    /// </summary>
    Null,
    /// <summary>
    /// An undefined value.
    /// </summary>
    Undefined,
    /// <summary>
    /// A date value.
    /// </summary>
    Date,
    /// <summary>
    /// A raw JSON value.
    /// </summary>
    Raw,
    /// <summary>
    /// A collection of bytes value.
    /// </summary>
    Bytes,
    /// <summary>
    /// A Guid value.
    /// </summary>
    Guid,
    /// <summary>
    /// A Uri value.
    /// </summary>
    Uri,
    /// <summary>
    /// A TimeSpan value.
    /// </summary>
    TimeSpan
  }
}
#endregion Linq_JTokenType.cs

/// ********   File: \Linq\JTokenWriter.cs
#region Linq_JTokenWriter.cs

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
  /// </summary>
  public class JTokenWriter : JsonWriter
  {
    private JContainer _token;
    private JContainer _parent;
    // used when writer is writing single value and the value has no containing parent
    private JValue _value;

    /// <summary>
    /// Gets the token being writen.
    /// </summary>
    /// <value>The token being writen.</value>
    public JToken Token
    {
      get
      {
        if (_token != null)
          return _token;

        return _value;
      }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JTokenWriter"/> class writing to the given <see cref="JContainer"/>.
    /// </summary>
    /// <param name="container">The container being written to.</param>
    public JTokenWriter(JContainer container)
    {
      ValidationUtils.ArgumentNotNull(container, "container");

      _token = container;
      _parent = container;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JTokenWriter"/> class.
    /// </summary>
    public JTokenWriter()
    {
    }

    /// <summary>
    /// Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
    /// </summary>
    public override void Flush()
    {
    }

    /// <summary>
    /// Closes this stream and the underlying stream.
    /// </summary>
    public override void Close()
    {
      base.Close();
    }

    /// <summary>
    /// Writes the beginning of a Json object.
    /// </summary>
    public override void WriteStartObject()
    {
      base.WriteStartObject();

      AddParent(new JObject());
    }

    private void AddParent(JContainer container)
    {
      if (_parent == null)
        _token = container;
      else
        _parent.AddAndSkipParentCheck(container);

      _parent = container;
    }

    private void RemoveParent()
    {
      _parent = _parent.Parent;

      if (_parent != null && _parent.Type == JTokenType.Property)
        _parent = _parent.Parent;
    }

    /// <summary>
    /// Writes the beginning of a Json array.
    /// </summary>
    public override void WriteStartArray()
    {
      base.WriteStartArray();

      AddParent(new JArray());
    }

    /// <summary>
    /// Writes the start of a constructor with the given name.
    /// </summary>
    /// <param name="name">The name of the constructor.</param>
    public override void WriteStartConstructor(string name)
    {
      base.WriteStartConstructor(name);

      AddParent(new JConstructor(name));
    }

    /// <summary>
    /// Writes the end.
    /// </summary>
    /// <param name="token">The token.</param>
    protected override void WriteEnd(JsonToken token)
    {
      RemoveParent();
    }

    /// <summary>
    /// Writes the property name of a name/value pair on a Json object.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    public override void WritePropertyName(string name)
    {
      base.WritePropertyName(name);

      AddParent(new JProperty(name));
    }

    private void AddValue(object value, JsonToken token)
    {
      AddValue(new JValue(value), token);
    }

    internal void AddValue(JValue value, JsonToken token)
    {
      if (_parent != null)
      {
        _parent.Add(value);

        if (_parent.Type == JTokenType.Property)
          _parent = _parent.Parent;
      }
      else
      {
        _value = value;
      }
    }

    #region WriteValue methods
    /// <summary>
    /// Writes a null value.
    /// </summary>
    public override void WriteNull()
    {
      base.WriteNull();
      AddValue(null, JsonToken.Null);
    }

    /// <summary>
    /// Writes an undefined value.
    /// </summary>
    public override void WriteUndefined()
    {
      base.WriteUndefined();
      AddValue(null, JsonToken.Undefined);
    }

    /// <summary>
    /// Writes raw JSON.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public override void WriteRaw(string json)
    {
      base.WriteRaw(json);
      AddValue(new JRaw(json), JsonToken.Raw);
    }

    /// <summary>
    /// Writes out a comment <code>/*...*/</code> containing the specified text.
    /// </summary>
    /// <param name="text">Text to place inside the comment.</param>
    public override void WriteComment(string text)
    {
      base.WriteComment(text);
      AddValue(JValue.CreateComment(text), JsonToken.Comment);
    }

    /// <summary>
    /// Writes a <see cref="String"/> value.
    /// </summary>
    /// <param name="value">The <see cref="String"/> value to write.</param>
    public override void WriteValue(string value)
    {
      base.WriteValue(value);
      AddValue(value ?? string.Empty, JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Int32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int32"/> value to write.</param>
    public override void WriteValue(int value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt32"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(uint value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Int64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int64"/> value to write.</param>
    public override void WriteValue(long value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt64"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ulong value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Single"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Single"/> value to write.</param>
    public override void WriteValue(float value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Double"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Double"/> value to write.</param>
    public override void WriteValue(double value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Boolean"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Boolean"/> value to write.</param>
    public override void WriteValue(bool value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Boolean);
    }

    /// <summary>
    /// Writes a <see cref="Int16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int16"/> value to write.</param>
    public override void WriteValue(short value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt16"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ushort value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Char"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Char"/> value to write.</param>
    public override void WriteValue(char value)
    {
      base.WriteValue(value);
      string s = null;
#if !(NETFX_CORE || PORTABLE)
      s = value.ToString(CultureInfo.InvariantCulture);
#else
      s = value.ToString();
#endif
      AddValue(s, JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Byte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Byte"/> value to write.</param>
    public override void WriteValue(byte value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="SByte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="SByte"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(sbyte value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Decimal"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Decimal"/> value to write.</param>
    public override void WriteValue(decimal value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="DateTime"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to write.</param>
    public override void WriteValue(DateTime value)
    {
      base.WriteValue(value);
      value = JsonConvert.EnsureDateTime(value, DateTimeZoneHandling);
      AddValue(value, JsonToken.Date);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Writes a <see cref="DateTimeOffset"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to write.</param>
    public override void WriteValue(DateTimeOffset value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Date);
    }
#endif

    /// <summary>
    /// Writes a <see cref="T:Byte[]"/> value.
    /// </summary>
    /// <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
    public override void WriteValue(byte[] value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.Bytes);
    }

    /// <summary>
    /// Writes a <see cref="TimeSpan"/> value.
    /// </summary>
    /// <param name="value">The <see cref="TimeSpan"/> value to write.</param>
    public override void WriteValue(TimeSpan value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Guid"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to write.</param>
    public override void WriteValue(Guid value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Uri"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Uri"/> value to write.</param>
    public override void WriteValue(Uri value)
    {
      base.WriteValue(value);
      AddValue(value, JsonToken.String);
    }
    #endregion
  }
}

#endregion Linq_JTokenWriter.cs

/// ********   File: \Linq\JValue.cs
#region Linq_JValue.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif

namespace Newtonsoft.Json.Linq
{
  /// <summary>
  /// Represents a value in JSON (string, integer, date, etc).
  /// </summary>
  public class JValue : JToken, IEquatable<JValue>, IFormattable, IComparable, IComparable<JValue>
  {
    private JTokenType _valueType;
    private object _value;

    internal JValue(object value, JTokenType type)
    {
      _value = value;
      _valueType = type;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class from another <see cref="JValue"/> object.
    /// </summary>
    /// <param name="other">A <see cref="JValue"/> object to copy from.</param>
    public JValue(JValue other)
      : this(other.Value, other.Type)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(long value)
      : this(value, JTokenType.Integer)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(char value)
      : this(value, JTokenType.String)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    [CLSCompliant(false)]
    public JValue(ulong value)
      : this(value, JTokenType.Integer)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(double value)
      : this(value, JTokenType.Float)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(float value)
      : this(value, JTokenType.Float)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(DateTime value)
      : this(value, JTokenType.Date)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(bool value)
      : this(value, JTokenType.Boolean)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(string value)
      : this(value, JTokenType.String)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(Guid value)
      : this(value, JTokenType.Guid)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(Uri value)
      : this(value, (value != null) ? JTokenType.Uri : JTokenType.Null)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(TimeSpan value)
      : this(value, JTokenType.TimeSpan)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JValue"/> class with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    public JValue(object value)
      : this(value, GetValueType(null, value))
    {
    }

    internal override bool DeepEquals(JToken node)
    {
      JValue other = node as JValue;
      if (other == null)
        return false;
      if (other == this)
        return true;

      return ValuesEquals(this, other);
    }

    /// <summary>
    /// Gets a value indicating whether this token has childen tokens.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this token has child values; otherwise, <c>false</c>.
    /// </value>
    public override bool HasValues
    {
      get { return false; }
    }

    private static int Compare(JTokenType valueType, object objA, object objB)
    {
      if (objA == null && objB == null)
        return 0;
      if (objA != null && objB == null)
        return 1;
      if (objA == null && objB != null)
        return -1;

      switch (valueType)
      {
        case JTokenType.Integer:
          if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
            return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
          else if (objA is float || objB is float || objA is double || objB is double)
            return CompareFloat(objA, objB);
          else
            return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
        case JTokenType.Float:
          return CompareFloat(objA, objB);
        case JTokenType.Comment:
        case JTokenType.String:
        case JTokenType.Raw:
          string s1 = Convert.ToString(objA, CultureInfo.InvariantCulture);
          string s2 = Convert.ToString(objB, CultureInfo.InvariantCulture);

          return string.CompareOrdinal(s1, s2);
        case JTokenType.Boolean:
          bool b1 = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
          bool b2 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);

          return b1.CompareTo(b2);
        case JTokenType.Date:
#if !NET20
          if (objA is DateTime)
          {
#endif
            DateTime date1 = (DateTime)objA;
            DateTime date2;

#if !NET20
            if (objB is DateTimeOffset)
              date2 = ((DateTimeOffset)objB).DateTime;
            else
#endif
              date2 = Convert.ToDateTime(objB, CultureInfo.InvariantCulture);

            return date1.CompareTo(date2);
#if !NET20
          }
          else
          {
            DateTimeOffset date1 = (DateTimeOffset) objA;
            DateTimeOffset date2;

            if (objB is DateTimeOffset)
              date2 = (DateTimeOffset)objB;
            else
              date2 = new DateTimeOffset(Convert.ToDateTime(objB, CultureInfo.InvariantCulture));

            return date1.CompareTo(date2);
          }
#endif
        case JTokenType.Bytes:
          if (!(objB is byte[]))
            throw new ArgumentException("Object must be of type byte[].");

          byte[] bytes1 = objA as byte[];
          byte[] bytes2 = objB as byte[];
          if (bytes1 == null)
            return -1;
          if (bytes2 == null)
            return 1;

          return MiscellaneousUtils.ByteArrayCompare(bytes1, bytes2);
        case JTokenType.Guid:
          if (!(objB is Guid))
            throw new ArgumentException("Object must be of type Guid.");

          Guid guid1 = (Guid) objA;
          Guid guid2 = (Guid) objB;

          return guid1.CompareTo(guid2);
        case JTokenType.Uri:
          if (!(objB is Uri))
            throw new ArgumentException("Object must be of type Uri.");

          Uri uri1 = (Uri)objA;
          Uri uri2 = (Uri)objB;

          return Comparer<string>.Default.Compare(uri1.ToString(), uri2.ToString());
        case JTokenType.TimeSpan:
          if (!(objB is TimeSpan))
            throw new ArgumentException("Object must be of type TimeSpan.");

          TimeSpan ts1 = (TimeSpan)objA;
          TimeSpan ts2 = (TimeSpan)objB;

          return ts1.CompareTo(ts2);
        default:
          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture, valueType));
      }
    }

    private static int CompareFloat(object objA, object objB)
    {
      double d1 = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
      double d2 = Convert.ToDouble(objB, CultureInfo.InvariantCulture);

      // take into account possible floating point errors
      if (MathUtils.ApproxEquals(d1, d2))
        return 0;

      return d1.CompareTo(d2);
    }

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    private static bool Operation(ExpressionType operation, object objA, object objB, out object result)
    {
      if (objA is string || objB is string)
      {
        if (operation == ExpressionType.Add || operation == ExpressionType.AddAssign)
        {
          result = ((objA != null) ? objA.ToString() : null) + ((objB != null) ? objB.ToString() : null);
          return true;
        }
      }

      if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
      {
        if (objA == null || objB == null)
        {
          result = null;
          return true;
        }

        decimal d1 = Convert.ToDecimal(objA, CultureInfo.InvariantCulture);
        decimal d2 = Convert.ToDecimal(objB, CultureInfo.InvariantCulture);

        switch (operation)
        {
          case ExpressionType.Add:
          case ExpressionType.AddAssign:
            result = d1 + d2;
            return true;
          case ExpressionType.Subtract:
          case ExpressionType.SubtractAssign:
            result = d1 - d2;
            return true;
          case ExpressionType.Multiply:
          case ExpressionType.MultiplyAssign:
            result = d1 * d2;
            return true;
          case ExpressionType.Divide:
          case ExpressionType.DivideAssign:
            result = d1 / d2;
            return true;
        }
      }
      else if (objA is float || objB is float || objA is double || objB is double)
      {
        if (objA == null || objB == null)
        {
          result = null;
          return true;
        }

        double d1 = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
        double d2 = Convert.ToDouble(objB, CultureInfo.InvariantCulture);

        switch (operation)
        {
          case ExpressionType.Add:
          case ExpressionType.AddAssign:
            result = d1 + d2;
            return true;
          case ExpressionType.Subtract:
          case ExpressionType.SubtractAssign:
            result = d1 - d2;
            return true;
          case ExpressionType.Multiply:
          case ExpressionType.MultiplyAssign:
            result = d1 * d2;
            return true;
          case ExpressionType.Divide:
          case ExpressionType.DivideAssign:
            result = d1 / d2;
            return true;
        }
      }
      else if (objA is int || objA is uint || objA is long || objA is short || objA is ushort || objA is sbyte || objA is byte ||
        objB is int || objB is uint || objB is long || objB is short || objB is ushort || objB is sbyte || objB is byte)
      {
        if (objA == null || objB == null)
        {
          result = null;
          return true;
        }

        long l1 = Convert.ToInt64(objA, CultureInfo.InvariantCulture);
        long l2 = Convert.ToInt64(objB, CultureInfo.InvariantCulture);

        switch (operation)
        {
          case ExpressionType.Add:
          case ExpressionType.AddAssign:
            result = l1 + l2;
            return true;
          case ExpressionType.Subtract:
          case ExpressionType.SubtractAssign:
            result = l1 - l2;
            return true;
          case ExpressionType.Multiply:
          case ExpressionType.MultiplyAssign:
            result = l1 * l2;
            return true;
          case ExpressionType.Divide:
          case ExpressionType.DivideAssign:
            result = l1 / l2;
            return true;
        }
      }

      result = null;
      return false;
    }
#endif

    internal override JToken CloneToken()
    {
      return new JValue(this);
    }

    /// <summary>
    /// Creates a <see cref="JValue"/> comment with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>A <see cref="JValue"/> comment with the given value.</returns>
    public static JValue CreateComment(string value)
    {
      return new JValue(value, JTokenType.Comment);
    }

    /// <summary>
    /// Creates a <see cref="JValue"/> string with the given value.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <returns>A <see cref="JValue"/> string with the given value.</returns>
    public static JValue CreateString(string value)
    {
      return new JValue(value, JTokenType.String);
    }

    private static JTokenType GetValueType(JTokenType? current, object value)
    {
      if (value == null)
        return JTokenType.Null;
#if !(NETFX_CORE || PORTABLE)
      else if (value == DBNull.Value)
        return JTokenType.Null;
#endif
      else if (value is string)
        return GetStringValueType(current);
      else if (value is long || value is int || value is short || value is sbyte
        || value is ulong || value is uint || value is ushort || value is byte)
        return JTokenType.Integer;
      else if (value is Enum)
        return JTokenType.Integer;
      else if (value is double || value is float || value is decimal)
        return JTokenType.Float;
      else if (value is DateTime)
        return JTokenType.Date;
#if !PocketPC && !NET20
      else if (value is DateTimeOffset)
        return JTokenType.Date;
#endif
      else if (value is byte[])
        return JTokenType.Bytes;
      else if (value is bool)
        return JTokenType.Boolean;
      else if (value is Guid)
        return JTokenType.Guid;
      else if (value is Uri)
        return JTokenType.Uri;
      else if (value is TimeSpan)
        return JTokenType.TimeSpan;

      throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
    }

    private static JTokenType GetStringValueType(JTokenType? current)
    {
      if (current == null)
        return JTokenType.String;

      switch (current.Value)
      {
        case JTokenType.Comment:
        case JTokenType.String:
        case JTokenType.Raw:
          return current.Value;
        default:
          return JTokenType.String;
      }
    }

    /// <summary>
    /// Gets the node type for this <see cref="JToken"/>.
    /// </summary>
    /// <value>The type.</value>
    public override JTokenType Type
    {
      get { return _valueType; }
    }

    /// <summary>
    /// Gets or sets the underlying token value.
    /// </summary>
    /// <value>The underlying token value.</value>
    public object Value
    {
      get { return _value; }
      set
      {
        Type currentType = (_value != null) ? _value.GetType() : null;
        Type newType = (value != null) ? value.GetType() : null;

        if (currentType != newType)
          _valueType = GetValueType(_valueType, value);

        _value = value;
      }
    }

    /// <summary>
    /// Writes this token to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="converters">A collection of <see cref="JsonConverter"/> which will be used when writing the token.</param>
    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
    {
      if (converters != null && converters.Length > 0 && _value != null)
      {
        JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
        if (matchingConverter != null)
        {
          matchingConverter.WriteJson(writer, _value, new JsonSerializer());
          return;
        }
      }

      switch (_valueType)
      {
        case JTokenType.Comment:
          writer.WriteComment((_value != null) ? _value.ToString() : null);
          return;
        case JTokenType.Raw:
          writer.WriteRawValue((_value != null) ? _value.ToString() : null);
          return;
        case JTokenType.Null:
          writer.WriteNull();
          return;
        case JTokenType.Undefined:
          writer.WriteUndefined();
          return;
        case JTokenType.Integer:
          writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
          return;
        case JTokenType.Float:
          if (_value is decimal)
            writer.WriteValue((decimal)_value);
          else if (_value is double)
            writer.WriteValue((double)_value);
          else if (_value is float)
            writer.WriteValue((float)_value);
          else
            writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
          return;
        case JTokenType.String:
          writer.WriteValue((_value != null) ? _value.ToString() : null);
          return;
        case JTokenType.Boolean:
          writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
          return;
        case JTokenType.Date:
#if !PocketPC && !NET20
          if (_value is DateTimeOffset)
            writer.WriteValue((DateTimeOffset)_value);
          else
#endif
            writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
          return;
        case JTokenType.Bytes:
          writer.WriteValue((byte[])_value);
          return;
        case JTokenType.Guid:
        case JTokenType.Uri:
        case JTokenType.TimeSpan:
          writer.WriteValue((_value != null) ? _value.ToString() : null);
          return;
      }

      throw MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", _valueType, "Unexpected token type.");
    }

    internal override int GetDeepHashCode()
    {
      int valueHashCode = (_value != null) ? _value.GetHashCode() : 0;

      return _valueType.GetHashCode() ^ valueHashCode;
    }

    private static bool ValuesEquals(JValue v1, JValue v2)
    {
      return (v1 == v2 || (v1._valueType == v2._valueType && Compare(v1._valueType, v1._value, v2._value) == 0));
    }

    /// <summary>
    /// Indicates whether the current object is equal to another object of the same type.
    /// </summary>
    /// <returns>
    /// true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
    /// </returns>
    /// <param name="other">An object to compare with this object.</param>
    public bool Equals(JValue other)
    {
      if (other == null)
        return false;

      return ValuesEquals(this, other);
    }

    /// <summary>
    /// Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
    /// </summary>
    /// <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
    /// <returns>
    /// true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
    /// </returns>
    /// <exception cref="T:System.NullReferenceException">
    /// The <paramref name="obj"/> parameter is null.
    /// </exception>
    public override bool Equals(object obj)
    {
      if (obj == null)
        return false;

      JValue otherValue = obj as JValue;
      if (otherValue != null)
        return Equals(otherValue);

      return base.Equals(obj);
    }

    /// <summary>
    /// Serves as a hash function for a particular type.
    /// </summary>
    /// <returns>
    /// A hash code for the current <see cref="T:System.Object"/>.
    /// </returns>
    public override int GetHashCode()
    {
      if (_value == null)
        return 0;

      return _value.GetHashCode();
    }

    /// <summary>
    /// Returns a <see cref="System.String"/> that represents this instance.
    /// </summary>
    /// <returns>
    /// A <see cref="System.String"/> that represents this instance.
    /// </returns>
    public override string ToString()
    {
      if (_value == null)
        return string.Empty;

      return _value.ToString();
    }

    /// <summary>
    /// Returns a <see cref="System.String"/> that represents this instance.
    /// </summary>
    /// <param name="format">The format.</param>
    /// <returns>
    /// A <see cref="System.String"/> that represents this instance.
    /// </returns>
    public string ToString(string format)
    {
      return ToString(format, CultureInfo.CurrentCulture);
    }

    /// <summary>
    /// Returns a <see cref="System.String"/> that represents this instance.
    /// </summary>
    /// <param name="formatProvider">The format provider.</param>
    /// <returns>
    /// A <see cref="System.String"/> that represents this instance.
    /// </returns>
    public string ToString(IFormatProvider formatProvider)
    {
      return ToString(null, formatProvider);
    }

    /// <summary>
    /// Returns a <see cref="System.String"/> that represents this instance.
    /// </summary>
    /// <param name="format">The format.</param>
    /// <param name="formatProvider">The format provider.</param>
    /// <returns>
    /// A <see cref="System.String"/> that represents this instance.
    /// </returns>
    public string ToString(string format, IFormatProvider formatProvider)
    {
      if (_value == null)
        return string.Empty;

      IFormattable formattable = _value as IFormattable;
      if (formattable != null)
        return formattable.ToString(format, formatProvider);
      else
        return _value.ToString();
    }

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    /// <summary>
    /// Returns the <see cref="T:System.Dynamic.DynamicMetaObject"/> responsible for binding operations performed on this object.
    /// </summary>
    /// <param name="parameter">The expression tree representation of the runtime value.</param>
    /// <returns>
    /// The <see cref="T:System.Dynamic.DynamicMetaObject"/> to bind this object.
    /// </returns>
    protected override DynamicMetaObject GetMetaObject(Expression parameter)
    {
      return new DynamicProxyMetaObject<JValue>(parameter, this, new JValueDynamicProxy(), true);
    }

    private class JValueDynamicProxy : DynamicProxy<JValue>
    {
      public override bool TryConvert(JValue instance, ConvertBinder binder, out object result)
      {
        if (binder.Type == typeof(JValue))
        {
          result = instance;
          return true;
        }

        object value = instance.Value;

        if (value == null)
        {
          result = null;
          return ReflectionUtils.IsNullable(binder.Type);
        }

        result = ConvertUtils.Convert(instance.Value, CultureInfo.InvariantCulture, binder.Type);
        return true;
      }

      public override bool TryBinaryOperation(JValue instance, BinaryOperationBinder binder, object arg, out object result)
      {
        object compareValue = (arg is JValue) ? ((JValue) arg).Value : arg;

        switch (binder.Operation)
        {
          case ExpressionType.Equal:
            result = (Compare(instance.Type, instance.Value, compareValue) == 0);
            return true;
          case ExpressionType.NotEqual:
            result = (Compare(instance.Type, instance.Value, compareValue) != 0);
            return true;
          case ExpressionType.GreaterThan:
            result = (Compare(instance.Type, instance.Value, compareValue) > 0);
            return true;
          case ExpressionType.GreaterThanOrEqual:
            result = (Compare(instance.Type, instance.Value, compareValue) >= 0);
            return true;
          case ExpressionType.LessThan:
            result = (Compare(instance.Type, instance.Value, compareValue) < 0);
            return true;
          case ExpressionType.LessThanOrEqual:
            result = (Compare(instance.Type, instance.Value, compareValue) <= 0);
            return true;
          case ExpressionType.Add:
          case ExpressionType.AddAssign:
          case ExpressionType.Subtract:
          case ExpressionType.SubtractAssign:
          case ExpressionType.Multiply:
          case ExpressionType.MultiplyAssign:
          case ExpressionType.Divide:
          case ExpressionType.DivideAssign:
            if (Operation(binder.Operation, instance.Value, compareValue, out result))
            {
              result = new JValue(result);
              return true;
            }
            break;
        }

        result = null;
        return false;
      }
    }
#endif

    int IComparable.CompareTo(object obj)
    {
      if (obj == null)
        return 1;

      object otherValue = (obj is JValue) ? ((JValue) obj).Value : obj;

      return Compare(_valueType, _value, otherValue);
    }

    /// <summary>
    /// Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
    /// </summary>
    /// <param name="obj">An object to compare with this instance.</param>
    /// <returns>
    /// A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
    /// Value
    /// Meaning
    /// Less than zero
    /// This instance is less than <paramref name="obj"/>.
    /// Zero
    /// This instance is equal to <paramref name="obj"/>.
    /// Greater than zero
    /// This instance is greater than <paramref name="obj"/>.
    /// </returns>
    /// <exception cref="T:System.ArgumentException">
    /// 	<paramref name="obj"/> is not the same type as this instance.
    /// </exception>
    public int CompareTo(JValue obj)
    {
      if (obj == null)
        return 1;

      return Compare(_valueType, _value, obj._value);
    }
  }
}
#endregion Linq_JValue.cs

/// ********   File: \Schema\Extensions.cs
#region Schema_Extensions.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Contains the JSON schema extension methods.
  /// </summary>
  public static class Extensions
  {
    /// <summary>
    /// Determines whether the <see cref="JToken"/> is valid.
    /// </summary>
    /// <param name="source">The source <see cref="JToken"/> to test.</param>
    /// <param name="schema">The schema to test with.</param>
    /// <returns>
    /// 	<c>true</c> if the specified <see cref="JToken"/> is valid; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsValid(this JToken source, JsonSchema schema)
    {
      bool valid = true;
      source.Validate(schema, (sender, args) => { valid = false; });
      return valid;
    }

    /// <summary>
    /// Determines whether the <see cref="JToken"/> is valid.
    /// </summary>
    /// <param name="source">The source <see cref="JToken"/> to test.</param>
    /// <param name="schema">The schema to test with.</param>
    /// <param name="errorMessages">When this method returns, contains any error messages generated while validating. </param>
    /// <returns>
    /// 	<c>true</c> if the specified <see cref="JToken"/> is valid; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsValid(this JToken source, JsonSchema schema, out IList<string> errorMessages)
    {
      IList<string> errors = new List<string>();

      source.Validate(schema, (sender, args) => errors.Add(args.Message));

      errorMessages = errors;
      return (errorMessages.Count == 0);
    }

    /// <summary>
    /// Validates the specified <see cref="JToken"/>.
    /// </summary>
    /// <param name="source">The source <see cref="JToken"/> to test.</param>
    /// <param name="schema">The schema to test with.</param>
    public static void Validate(this JToken source, JsonSchema schema)
    {
      source.Validate(schema, null);
    }

    /// <summary>
    /// Validates the specified <see cref="JToken"/>.
    /// </summary>
    /// <param name="source">The source <see cref="JToken"/> to test.</param>
    /// <param name="schema">The schema to test with.</param>
    /// <param name="validationEventHandler">The validation event handler.</param>
    public static void Validate(this JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler)
    {
      ValidationUtils.ArgumentNotNull(source, "source");
      ValidationUtils.ArgumentNotNull(schema, "schema");

      using (JsonValidatingReader reader = new JsonValidatingReader(source.CreateReader()))
      {
        reader.Schema = schema;
        if (validationEventHandler != null)
          reader.ValidationEventHandler += validationEventHandler;

        while (reader.Read())
        {
        }
      }
    }
  }
}

#endregion Schema_Extensions.cs

/// ********   File: \Schema\JsonSchema.cs
#region Schema_JsonSchema.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// An in-memory representation of a JSON Schema.
  /// </summary>
  public class JsonSchema
  {
    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public string Id { get; set; }
    /// <summary>
    /// Gets or sets the title.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Gets or sets whether the object is required.
    /// </summary>
    public bool? Required { get; set; }
    /// <summary>
    /// Gets or sets whether the object is read only.
    /// </summary>
    public bool? ReadOnly { get; set; }
    /// <summary>
    /// Gets or sets whether the object is visible to users.
    /// </summary>
    public bool? Hidden { get; set; }
    /// <summary>
    /// Gets or sets whether the object is transient.
    /// </summary>
    public bool? Transient { get; set; }
    /// <summary>
    /// Gets or sets the description of the object.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Gets or sets the types of values allowed by the object.
    /// </summary>
    /// <value>The type.</value>
    public JsonSchemaType? Type { get; set; }
    /// <summary>
    /// Gets or sets the pattern.
    /// </summary>
    /// <value>The pattern.</value>
    public string Pattern { get; set; }
    /// <summary>
    /// Gets or sets the minimum length.
    /// </summary>
    /// <value>The minimum length.</value>
    public int? MinimumLength { get; set; }
    /// <summary>
    /// Gets or sets the maximum length.
    /// </summary>
    /// <value>The maximum length.</value>
    public int? MaximumLength { get; set; }
    /// <summary>
    /// Gets or sets a number that the value should be divisble by.
    /// </summary>
    /// <value>A number that the value should be divisble by.</value>
    public double? DivisibleBy { get; set; }
    /// <summary>
    /// Gets or sets the minimum.
    /// </summary>
    /// <value>The minimum.</value>
    public double? Minimum { get; set; }
    /// <summary>
    /// Gets or sets the maximum.
    /// </summary>
    /// <value>The maximum.</value>
    public double? Maximum { get; set; }
    /// <summary>
    /// Gets or sets a flag indicating whether the value can not equal the number defined by the "minimum" attribute.
    /// </summary>
    /// <value>A flag indicating whether the value can not equal the number defined by the "minimum" attribute.</value>
    public bool? ExclusiveMinimum { get; set; }
    /// <summary>
    /// Gets or sets a flag indicating whether the value can not equal the number defined by the "maximum" attribute.
    /// </summary>
    /// <value>A flag indicating whether the value can not equal the number defined by the "maximum" attribute.</value>
    public bool? ExclusiveMaximum { get; set; }
    /// <summary>
    /// Gets or sets the minimum number of items.
    /// </summary>
    /// <value>The minimum number of items.</value>
    public int? MinimumItems { get; set; }
    /// <summary>
    /// Gets or sets the maximum number of items.
    /// </summary>
    /// <value>The maximum number of items.</value>
    public int? MaximumItems { get; set; }
    /// <summary>
    /// Gets or sets the <see cref="JsonSchema"/> of items.
    /// </summary>
    /// <value>The <see cref="JsonSchema"/> of items.</value>
    public IList<JsonSchema> Items { get; set; }
    /// <summary>
    /// Gets or sets the <see cref="JsonSchema"/> of properties.
    /// </summary>
    /// <value>The <see cref="JsonSchema"/> of properties.</value>
    public IDictionary<string, JsonSchema> Properties { get; set; }
    /// <summary>
    /// Gets or sets the <see cref="JsonSchema"/> of additional properties.
    /// </summary>
    /// <value>The <see cref="JsonSchema"/> of additional properties.</value>
    public JsonSchema AdditionalProperties { get; set; }
    /// <summary>
    /// Gets or sets the pattern properties.
    /// </summary>
    /// <value>The pattern properties.</value>
    public IDictionary<string, JsonSchema> PatternProperties { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether additional properties are allowed.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if additional properties are allowed; otherwise, <c>false</c>.
    /// </value>
    public bool AllowAdditionalProperties { get; set; }
    /// <summary>
    /// Gets or sets the required property if this property is present.
    /// </summary>
    /// <value>The required property if this property is present.</value>
    public string Requires { get; set; }
    /// <summary>
    /// Gets or sets the identity.
    /// </summary>
    /// <value>The identity.</value>
    public IList<string> Identity { get; set; }
    /// <summary>
    /// Gets or sets the a collection of valid enum values allowed.
    /// </summary>
    /// <value>A collection of valid enum values allowed.</value>
    public IList<JToken> Enum { get; set; }
    /// <summary>
    /// Gets or sets a collection of options.
    /// </summary>
    /// <value>A collection of options.</value>
    public IDictionary<JToken, string> Options { get; set; }
    /// <summary>
    /// Gets or sets disallowed types.
    /// </summary>
    /// <value>The disallow types.</value>
    public JsonSchemaType? Disallow { get; set; }
    /// <summary>
    /// Gets or sets the default value.
    /// </summary>
    /// <value>The default value.</value>
    public JToken Default { get; set; }
    /// <summary>
    /// Gets or sets the extend <see cref="JsonSchema"/>.
    /// </summary>
    /// <value>The extended <see cref="JsonSchema"/>.</value>
    public JsonSchema Extends { get; set; }
    /// <summary>
    /// Gets or sets the format.
    /// </summary>
    /// <value>The format.</value>
    public string Format { get; set; }

    private readonly string _internalId = Guid.NewGuid().ToString("N");

    internal string InternalId
    {
      get { return _internalId; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchema"/> class.
    /// </summary>
    public JsonSchema()
    {
      AllowAdditionalProperties = true;
    }

    /// <summary>
    /// Reads a <see cref="JsonSchema"/> from the specified <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> containing the JSON Schema to read.</param>
    /// <returns>The <see cref="JsonSchema"/> object representing the JSON Schema.</returns>
    public static JsonSchema Read(JsonReader reader)
    {
      return Read(reader, new JsonSchemaResolver());
    }

    /// <summary>
    /// Reads a <see cref="JsonSchema"/> from the specified <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> containing the JSON Schema to read.</param>
    /// <param name="resolver">The <see cref="JsonSchemaResolver"/> to use when resolving schema references.</param>
    /// <returns>The <see cref="JsonSchema"/> object representing the JSON Schema.</returns>
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");
      ValidationUtils.ArgumentNotNull(resolver, "resolver");

      JsonSchemaBuilder builder = new JsonSchemaBuilder(resolver);
      return builder.Parse(reader);
    }

    /// <summary>
    /// Load a <see cref="JsonSchema"/> from a string that contains schema JSON.
    /// </summary>
    /// <param name="json">A <see cref="String"/> that contains JSON.</param>
    /// <returns>A <see cref="JsonSchema"/> populated from the string that contains JSON.</returns>
    public static JsonSchema Parse(string json)
    {
      return Parse(json, new JsonSchemaResolver());
    }

    /// <summary>
    /// Parses the specified json.
    /// </summary>
    /// <param name="json">The json.</param>
    /// <param name="resolver">The resolver.</param>
    /// <returns>A <see cref="JsonSchema"/> populated from the string that contains JSON.</returns>
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver)
    {
      ValidationUtils.ArgumentNotNull(json, "json");

      JsonReader reader = new JsonTextReader(new StringReader(json));

      return Read(reader, resolver);
    }

    /// <summary>
    /// Writes this schema to a <see cref="JsonWriter"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    public void WriteTo(JsonWriter writer)
    {
      WriteTo(writer, new JsonSchemaResolver());
    }

    /// <summary>
    /// Writes this schema to a <see cref="JsonWriter"/> using the specified <see cref="JsonSchemaResolver"/>.
    /// </summary>
    /// <param name="writer">A <see cref="JsonWriter"/> into which this method will write.</param>
    /// <param name="resolver">The resolver used.</param>
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver)
    {
      ValidationUtils.ArgumentNotNull(writer, "writer");
      ValidationUtils.ArgumentNotNull(resolver, "resolver");

      JsonSchemaWriter schemaWriter = new JsonSchemaWriter(writer, resolver);
      schemaWriter.WriteSchema(this);
    }

    /// <summary>
    /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
    /// </returns>
    public override string ToString()
    {
      StringWriter writer = new StringWriter(CultureInfo.InvariantCulture);
      JsonTextWriter jsonWriter = new JsonTextWriter(writer);
      jsonWriter.Formatting = Formatting.Indented;

      WriteTo(jsonWriter);

      return writer.ToString();
    }
  }
}
#endregion Schema_JsonSchema.cs

/// ********   File: \Schema\JsonSchemaBuilder.cs
#region Schema_JsonSchemaBuilder.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaBuilder
  {
    private JsonReader _reader;
    private readonly IList<JsonSchema> _stack;
    private readonly JsonSchemaResolver _resolver;
    private JsonSchema _currentSchema;

    private void Push(JsonSchema value)
    {
      _currentSchema = value;
      _stack.Add(value);
      _resolver.LoadedSchemas.Add(value);
    }

    private JsonSchema Pop()
    {
      JsonSchema poppedSchema = _currentSchema;
      _stack.RemoveAt(_stack.Count - 1);
      _currentSchema = _stack.LastOrDefault();

      return poppedSchema;
    }

    private JsonSchema CurrentSchema
    {
      get { return _currentSchema; }
    }

    public JsonSchemaBuilder(JsonSchemaResolver resolver)
    {
      _stack = new List<JsonSchema>();
      _resolver = resolver;
    }

    internal JsonSchema Parse(JsonReader reader)
    {
      _reader = reader;

      if (reader.TokenType == JsonToken.None)
        _reader.Read();

      return BuildSchema();
    }

    private JsonSchema BuildSchema()
    {
      if (_reader.TokenType != JsonToken.StartObject)
        throw JsonReaderException.Create(_reader, "Expected StartObject while parsing schema object, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

      _reader.Read();
      // empty schema object
      if (_reader.TokenType == JsonToken.EndObject)
      {
        Push(new JsonSchema());
        return Pop();
      }

      string propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
      _reader.Read();
      
      // schema reference
      if (propertyName == JsonSchemaConstants.ReferencePropertyName)
      {
        string id = (string)_reader.Value;

        // skip to the end of the current object
        while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
        {
            if (_reader.TokenType == JsonToken.StartObject)
              throw JsonReaderException.Create(_reader, "Found StartObject within the schema reference with the Id '{0}'".FormatWith(CultureInfo.InvariantCulture, id));
        }

        JsonSchema referencedSchema = _resolver.GetSchema(id);
        if (referencedSchema == null)
          throw new JsonException("Could not resolve schema reference for Id '{0}'.".FormatWith(CultureInfo.InvariantCulture, id));

        return referencedSchema;
      }

      // regular ol' schema object
      Push(new JsonSchema());

      ProcessSchemaProperty(propertyName);

      while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
      {
        propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
        _reader.Read();

        ProcessSchemaProperty(propertyName);
      }

      return Pop();
    }

    private void ProcessSchemaProperty(string propertyName)
    {
      switch (propertyName)
      {
        case JsonSchemaConstants.TypePropertyName:
          CurrentSchema.Type = ProcessType();
          break;
        case JsonSchemaConstants.IdPropertyName:
          CurrentSchema.Id = (string) _reader.Value;
          break;
        case JsonSchemaConstants.TitlePropertyName:
          CurrentSchema.Title = (string) _reader.Value;
          break;
        case JsonSchemaConstants.DescriptionPropertyName:
          CurrentSchema.Description = (string)_reader.Value;
          break;
        case JsonSchemaConstants.PropertiesPropertyName:
          ProcessProperties();
          break;
        case JsonSchemaConstants.ItemsPropertyName:
          ProcessItems();
          break;
        case JsonSchemaConstants.AdditionalPropertiesPropertyName:
          ProcessAdditionalProperties();
          break;
        case JsonSchemaConstants.PatternPropertiesPropertyName:
          ProcessPatternProperties();
          break;
        case JsonSchemaConstants.RequiredPropertyName:
          CurrentSchema.Required = (bool)_reader.Value;
          break;
        case JsonSchemaConstants.RequiresPropertyName:
          CurrentSchema.Requires = (string) _reader.Value;
          break;
        case JsonSchemaConstants.IdentityPropertyName:
          ProcessIdentity();
          break;
        case JsonSchemaConstants.MinimumPropertyName:
          CurrentSchema.Minimum = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.MaximumPropertyName:
          CurrentSchema.Maximum = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.ExclusiveMinimumPropertyName:
          CurrentSchema.ExclusiveMinimum = (bool)_reader.Value;
          break;
        case JsonSchemaConstants.ExclusiveMaximumPropertyName:
          CurrentSchema.ExclusiveMaximum = (bool)_reader.Value;
          break;
        case JsonSchemaConstants.MaximumLengthPropertyName:
          CurrentSchema.MaximumLength = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.MinimumLengthPropertyName:
          CurrentSchema.MinimumLength = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.MaximumItemsPropertyName:
          CurrentSchema.MaximumItems = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.MinimumItemsPropertyName:
          CurrentSchema.MinimumItems = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.DivisibleByPropertyName:
          CurrentSchema.DivisibleBy = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
          break;
        case JsonSchemaConstants.DisallowPropertyName:
          CurrentSchema.Disallow = ProcessType();
          break;
        case JsonSchemaConstants.DefaultPropertyName:
          ProcessDefault();
          break;
        case JsonSchemaConstants.HiddenPropertyName:
          CurrentSchema.Hidden = (bool) _reader.Value;
          break;
        case JsonSchemaConstants.ReadOnlyPropertyName:
          CurrentSchema.ReadOnly = (bool) _reader.Value;
          break;
        case JsonSchemaConstants.FormatPropertyName:
          CurrentSchema.Format = (string) _reader.Value;
          break;
        case JsonSchemaConstants.PatternPropertyName:
          CurrentSchema.Pattern = (string) _reader.Value;
          break;
        case JsonSchemaConstants.OptionsPropertyName:
          ProcessOptions();
          break;
        case JsonSchemaConstants.EnumPropertyName:
          ProcessEnum();
          break;
        case JsonSchemaConstants.ExtendsPropertyName:
          ProcessExtends();
          break;
        default:
          _reader.Skip();
          break;
      }
    }

    private void ProcessExtends()
    {
      CurrentSchema.Extends = BuildSchema();
    }

    private void ProcessEnum()
    {
      if (_reader.TokenType != JsonToken.StartArray)
        throw JsonReaderException.Create(_reader, "Expected StartArray token while parsing enum values, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

      CurrentSchema.Enum = new List<JToken>();

      while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
      {
        JToken value = JToken.ReadFrom(_reader);
        CurrentSchema.Enum.Add(value);
      }
    }

    private void ProcessOptions()
    {
      CurrentSchema.Options = new Dictionary<JToken, string>(new JTokenEqualityComparer());

      switch (_reader.TokenType)
      {
        case JsonToken.StartArray:
          while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
          {
            if (_reader.TokenType != JsonToken.StartObject)
              throw JsonReaderException.Create(_reader, "Expect object token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

            string label = null;
            JToken value = null;

            while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
            {
              string propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
              _reader.Read();

              switch (propertyName)
              {
                case JsonSchemaConstants.OptionValuePropertyName:
                  value = JToken.ReadFrom(_reader);
                  break;
                case JsonSchemaConstants.OptionLabelPropertyName:
                  label = (string) _reader.Value;
                  break;
                default:
                  throw JsonReaderException.Create(_reader, "Unexpected property in JSON schema option: {0}.".FormatWith(CultureInfo.InvariantCulture, propertyName));
              }
            }

            if (value == null)
              throw new JsonException("No value specified for JSON schema option.");

            if (CurrentSchema.Options.ContainsKey(value))
              throw new JsonException("Duplicate value in JSON schema option collection: {0}".FormatWith(CultureInfo.InvariantCulture, value));

            CurrentSchema.Options.Add(value, label);
          }
          break;
        default:
          throw JsonReaderException.Create(_reader, "Expected array token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));
      }
    }

    private void ProcessDefault()
    {
      CurrentSchema.Default = JToken.ReadFrom(_reader);
    }

    private void ProcessIdentity()
    {
      CurrentSchema.Identity = new List<string>();

      switch (_reader.TokenType)
      {
        case JsonToken.String:
          CurrentSchema.Identity.Add(_reader.Value.ToString());
          break;
        case JsonToken.StartArray:
          while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
          {
            if (_reader.TokenType != JsonToken.String)
              throw JsonReaderException.Create(_reader, "Exception JSON property name string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

            CurrentSchema.Identity.Add(_reader.Value.ToString());
          }
          break;
        default:
          throw JsonReaderException.Create(_reader, "Expected array or JSON property name string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));
      }
    }

    private void ProcessAdditionalProperties()
    {
      if (_reader.TokenType == JsonToken.Boolean)
        CurrentSchema.AllowAdditionalProperties = (bool)_reader.Value;
      else
        CurrentSchema.AdditionalProperties = BuildSchema();
    }

    private void ProcessPatternProperties()
    {
      Dictionary<string, JsonSchema> patternProperties = new Dictionary<string, JsonSchema>();

      if (_reader.TokenType != JsonToken.StartObject)
        throw JsonReaderException.Create(_reader, "Expected StartObject token.");

      while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
      {
        string propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
        _reader.Read();

        if (patternProperties.ContainsKey(propertyName))
          throw new JsonException("Property {0} has already been defined in schema.".FormatWith(CultureInfo.InvariantCulture, propertyName));

        patternProperties.Add(propertyName, BuildSchema());
      }

      CurrentSchema.PatternProperties = patternProperties;
    }

    private void ProcessItems()
    {
      CurrentSchema.Items = new List<JsonSchema>();

      switch (_reader.TokenType)
      {
        case JsonToken.StartObject:
          CurrentSchema.Items.Add(BuildSchema());
          break;
        case JsonToken.StartArray:
          while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
          {
            CurrentSchema.Items.Add(BuildSchema());
          }
          break;
        default:
          throw JsonReaderException.Create(_reader, "Expected array or JSON schema object token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));
      }
    }

    private void ProcessProperties()
    {
      IDictionary<string, JsonSchema> properties = new Dictionary<string, JsonSchema>();

      if (_reader.TokenType != JsonToken.StartObject)
        throw JsonReaderException.Create(_reader, "Expected StartObject token while parsing schema properties, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

      while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
      {
        string propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
        _reader.Read();

        if (properties.ContainsKey(propertyName))
          throw new JsonException("Property {0} has already been defined in schema.".FormatWith(CultureInfo.InvariantCulture, propertyName));

        properties.Add(propertyName, BuildSchema());
      }

      CurrentSchema.Properties = properties;
    }

    private JsonSchemaType? ProcessType()
    {
      switch (_reader.TokenType)
      {
        case JsonToken.String:
          return MapType(_reader.Value.ToString());
        case JsonToken.StartArray:
          // ensure type is in blank state before ORing values
          JsonSchemaType? type = JsonSchemaType.None;

          while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
          {
            if (_reader.TokenType != JsonToken.String)
              throw JsonReaderException.Create(_reader, "Exception JSON schema type string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));

            type = type | MapType(_reader.Value.ToString());
          }

          return type;
        default:
          throw JsonReaderException.Create(_reader, "Expected array or JSON schema type string token, got {0}.".FormatWith(CultureInfo.InvariantCulture, _reader.TokenType));
      }
    }

    internal static JsonSchemaType MapType(string type)
    {
      JsonSchemaType mappedType;
      if (!JsonSchemaConstants.JsonSchemaTypeMapping.TryGetValue(type, out mappedType))
        throw new JsonException("Invalid JSON schema type: {0}".FormatWith(CultureInfo.InvariantCulture, type));

      return mappedType;
    }

    internal static string MapType(JsonSchemaType type)
    {
      return JsonSchemaConstants.JsonSchemaTypeMapping.Single(kv => kv.Value == type).Key;
    }
  }
}
#endregion Schema_JsonSchemaBuilder.cs

/// ********   File: \Schema\JsonSchemaConstants.cs
#region Schema_JsonSchemaConstants.cs

namespace Newtonsoft.Json.Schema
{
  internal static class JsonSchemaConstants
  {
    public const string TypePropertyName = "type";
    public const string PropertiesPropertyName = "properties";
    public const string ItemsPropertyName = "items";
    public const string RequiredPropertyName = "required";
    public const string PatternPropertiesPropertyName = "patternProperties";
    public const string AdditionalPropertiesPropertyName = "additionalProperties";
    public const string RequiresPropertyName = "requires";
    public const string IdentityPropertyName = "identity";
    public const string MinimumPropertyName = "minimum";
    public const string MaximumPropertyName = "maximum";
    public const string ExclusiveMinimumPropertyName = "exclusiveMinimum";
    public const string ExclusiveMaximumPropertyName = "exclusiveMaximum";
    public const string MinimumItemsPropertyName = "minItems";
    public const string MaximumItemsPropertyName = "maxItems";
    public const string PatternPropertyName = "pattern";
    public const string MaximumLengthPropertyName = "maxLength";
    public const string MinimumLengthPropertyName = "minLength";
    public const string EnumPropertyName = "enum";
    public const string OptionsPropertyName = "options";
    public const string ReadOnlyPropertyName = "readonly";
    public const string TitlePropertyName = "title";
    public const string DescriptionPropertyName = "description";
    public const string FormatPropertyName = "format";
    public const string DefaultPropertyName = "default";
    public const string TransientPropertyName = "transient";
    public const string DivisibleByPropertyName = "divisibleBy";
    public const string HiddenPropertyName = "hidden";
    public const string DisallowPropertyName = "disallow";
    public const string ExtendsPropertyName = "extends";
    public const string IdPropertyName = "id";

    public const string OptionValuePropertyName = "value";
    public const string OptionLabelPropertyName = "label";

    public const string ReferencePropertyName = "$ref";

    public static readonly IDictionary<string, JsonSchemaType> JsonSchemaTypeMapping = new Dictionary<string, JsonSchemaType>
    {
      {"string", JsonSchemaType.String},
      {"object", JsonSchemaType.Object},
      {"integer", JsonSchemaType.Integer},
      {"number", JsonSchemaType.Float},
      {"null", JsonSchemaType.Null},
      {"boolean", JsonSchemaType.Boolean},
      {"array", JsonSchemaType.Array},
      {"any", JsonSchemaType.Any}
    };
  }
}

#endregion Schema_JsonSchemaConstants.cs

/// ********   File: \Schema\JsonSchemaException.cs
#region Schema_JsonSchemaException.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Returns detailed information about the schema exception.
  /// </summary>
#if !(SILVERLIGHT || WINDOWS_PHONE || NETFX_CORE || PORTABLE)
  [Serializable]
#endif
  public class JsonSchemaException : JsonException
  {
    /// <summary>
    /// Gets the line number indicating where the error occurred.
    /// </summary>
    /// <value>The line number indicating where the error occurred.</value>
    public int LineNumber { get; private set; }

    /// <summary>
    /// Gets the line position indicating where the error occurred.
    /// </summary>
    /// <value>The line position indicating where the error occurred.</value>
    public int LinePosition { get; private set; }

    /// <summary>
    /// Gets the path to the JSON where the error occurred.
    /// </summary>
    /// <value>The path to the JSON where the error occurred.</value>
    public string Path { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaException"/> class.
    /// </summary>
    public JsonSchemaException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaException"/> class
    /// with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public JsonSchemaException(string message)
      : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaException"/> class
    /// with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    public JsonSchemaException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

 #if !(WINDOWS_PHONE || SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaException"/> class.
    /// </summary>
    /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
    /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
    /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
    public JsonSchemaException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
    }
#endif

    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition)
      : base(message, innerException)
    {
      Path = path;
      LineNumber = lineNumber;
      LinePosition = linePosition;
    }
  }
}
#endregion Schema_JsonSchemaException.cs

/// ********   File: \Schema\JsonSchemaGenerator.cs
#region Schema_JsonSchemaGenerator.cs

#if NETFX_CORE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Generates a <see cref="JsonSchema"/> from a specified <see cref="Type"/>.
  /// </summary>
  public class JsonSchemaGenerator
  {
    /// <summary>
    /// Gets or sets how undefined schemas are handled by the serializer.
    /// </summary>
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; set; }

    private IContractResolver _contractResolver;
    /// <summary>
    /// Gets or sets the contract resolver.
    /// </summary>
    /// <value>The contract resolver.</value>
    public IContractResolver ContractResolver
    {
      get
      {
        if (_contractResolver == null)
          return DefaultContractResolver.Instance;

        return _contractResolver;
      }
      set { _contractResolver = value; }
    }

    private class TypeSchema
    {
      public Type Type { get; private set; }
      public JsonSchema Schema { get; private set;}

      public TypeSchema(Type type, JsonSchema schema)
      {
        ValidationUtils.ArgumentNotNull(type, "type");
        ValidationUtils.ArgumentNotNull(schema, "schema");

        Type = type;
        Schema = schema;
      }
    }

    private JsonSchemaResolver _resolver;
    private readonly IList<TypeSchema> _stack = new List<TypeSchema>();
    private JsonSchema _currentSchema;

    private JsonSchema CurrentSchema
    {
      get { return _currentSchema; }
    }

    private void Push(TypeSchema typeSchema)
    {
      _currentSchema = typeSchema.Schema;
      _stack.Add(typeSchema);
      _resolver.LoadedSchemas.Add(typeSchema.Schema);
    }

    private TypeSchema Pop()
    {
      TypeSchema popped = _stack[_stack.Count - 1];
      _stack.RemoveAt(_stack.Count - 1);
      TypeSchema newValue = _stack.LastOrDefault();
      if (newValue != null)
      {
        _currentSchema = newValue.Schema;
      }
      else
      {
        _currentSchema = null;
      }

      return popped;
    }

    /// <summary>
    /// Generate a <see cref="JsonSchema"/> from the specified type.
    /// </summary>
    /// <param name="type">The type to generate a <see cref="JsonSchema"/> from.</param>
    /// <returns>A <see cref="JsonSchema"/> generated from the specified type.</returns>
    public JsonSchema Generate(Type type)
    {
      return Generate(type, new JsonSchemaResolver(), false);
    }

    /// <summary>
    /// Generate a <see cref="JsonSchema"/> from the specified type.
    /// </summary>
    /// <param name="type">The type to generate a <see cref="JsonSchema"/> from.</param>
    /// <param name="resolver">The <see cref="JsonSchemaResolver"/> used to resolve schema references.</param>
    /// <returns>A <see cref="JsonSchema"/> generated from the specified type.</returns>
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver)
    {
      return Generate(type, resolver, false);
    }

    /// <summary>
    /// Generate a <see cref="JsonSchema"/> from the specified type.
    /// </summary>
    /// <param name="type">The type to generate a <see cref="JsonSchema"/> from.</param>
    /// <param name="rootSchemaNullable">Specify whether the generated root <see cref="JsonSchema"/> will be nullable.</param>
    /// <returns>A <see cref="JsonSchema"/> generated from the specified type.</returns>
    public JsonSchema Generate(Type type, bool rootSchemaNullable)
    {
      return Generate(type, new JsonSchemaResolver(), rootSchemaNullable);
    }

    /// <summary>
    /// Generate a <see cref="JsonSchema"/> from the specified type.
    /// </summary>
    /// <param name="type">The type to generate a <see cref="JsonSchema"/> from.</param>
    /// <param name="resolver">The <see cref="JsonSchemaResolver"/> used to resolve schema references.</param>
    /// <param name="rootSchemaNullable">Specify whether the generated root <see cref="JsonSchema"/> will be nullable.</param>
    /// <returns>A <see cref="JsonSchema"/> generated from the specified type.</returns>
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable)
    {
      ValidationUtils.ArgumentNotNull(type, "type");
      ValidationUtils.ArgumentNotNull(resolver, "resolver");

      _resolver = resolver;

      return GenerateInternal(type, (!rootSchemaNullable) ? Required.Always : Required.Default, false);
    }

    private string GetTitle(Type type)
    {
      JsonContainerAttribute containerAttribute = JsonTypeReflector.GetJsonContainerAttribute(type);

      if (containerAttribute != null && !string.IsNullOrEmpty(containerAttribute.Title))
        return containerAttribute.Title;

      return null;
    }

    private string GetDescription(Type type)
    {
      JsonContainerAttribute containerAttribute = JsonTypeReflector.GetJsonContainerAttribute(type);

      if (containerAttribute != null && !string.IsNullOrEmpty(containerAttribute.Description))
        return containerAttribute.Description;

#if !(NETFX_CORE || PORTABLE)
      DescriptionAttribute descriptionAttribute = ReflectionUtils.GetAttribute<DescriptionAttribute>(type);
      if (descriptionAttribute != null)
        return descriptionAttribute.Description;
#endif

      return null;
    }

    private string GetTypeId(Type type, bool explicitOnly)
    {
      JsonContainerAttribute containerAttribute = JsonTypeReflector.GetJsonContainerAttribute(type);

      if (containerAttribute != null && !string.IsNullOrEmpty(containerAttribute.Id))
        return containerAttribute.Id;

      if (explicitOnly)
        return null;

      switch (UndefinedSchemaIdHandling)
      {
        case UndefinedSchemaIdHandling.UseTypeName:
          return type.FullName;
        case UndefinedSchemaIdHandling.UseAssemblyQualifiedName:
          return type.AssemblyQualifiedName;
        default:
          return null;
      }
    }

    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required)
    {
      ValidationUtils.ArgumentNotNull(type, "type");

      string resolvedId = GetTypeId(type, false);
      string explicitId = GetTypeId(type, true);

      if (!string.IsNullOrEmpty(resolvedId))
      {
        JsonSchema resolvedSchema = _resolver.GetSchema(resolvedId);
        if (resolvedSchema != null)
        {
          // resolved schema is not null but referencing member allows nulls
          // change resolved schema to allow nulls. hacky but what are ya gonna do?
          if (valueRequired != Required.Always && !HasFlag(resolvedSchema.Type, JsonSchemaType.Null))
            resolvedSchema.Type |= JsonSchemaType.Null;
          if (required && resolvedSchema.Required != true)
            resolvedSchema.Required = true;

          return resolvedSchema;
        }
      }

      // test for unresolved circular reference
      if (_stack.Any(tc => tc.Type == type))
      {
        throw new JsonException("Unresolved circular reference for type '{0}'. Explicitly define an Id for the type using a JsonObject/JsonArray attribute or automatically generate a type Id using the UndefinedSchemaIdHandling property.".FormatWith(CultureInfo.InvariantCulture, type));
      }

      JsonContract contract = ContractResolver.ResolveContract(type);
      JsonConverter converter;
      if ((converter = contract.Converter) != null || (converter = contract.InternalConverter) != null)
      {
        JsonSchema converterSchema = converter.GetSchema();
        if (converterSchema != null)
          return converterSchema;
      }

      Push(new TypeSchema(type, new JsonSchema()));

      if (explicitId != null)
        CurrentSchema.Id = explicitId;

      if (required)
        CurrentSchema.Required = true;
      CurrentSchema.Title = GetTitle(type);
      CurrentSchema.Description = GetDescription(type);

      if (converter != null)
      {
        // todo: Add GetSchema to JsonConverter and use here?
        CurrentSchema.Type = JsonSchemaType.Any;
      }
      else
      {
        switch (contract.ContractType)
        {
          case JsonContractType.Object:
            CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
            CurrentSchema.Id = GetTypeId(type, false);
            GenerateObjectSchema(type, (JsonObjectContract) contract);
            break;
          case JsonContractType.Array:
            CurrentSchema.Type = AddNullType(JsonSchemaType.Array, valueRequired);

            CurrentSchema.Id = GetTypeId(type, false);

            JsonArrayAttribute arrayAttribute = JsonTypeReflector.GetJsonContainerAttribute(type) as JsonArrayAttribute;
            bool allowNullItem = (arrayAttribute == null || arrayAttribute.AllowNullItems);

            Type collectionItemType = ReflectionUtils.GetCollectionItemType(type);
            if (collectionItemType != null)
            {
              CurrentSchema.Items = new List<JsonSchema>();
              CurrentSchema.Items.Add(GenerateInternal(collectionItemType, (!allowNullItem) ? Required.Always : Required.Default, false));
            }
            break;
          case JsonContractType.Primitive:
            CurrentSchema.Type = GetJsonSchemaType(type, valueRequired);

            if (CurrentSchema.Type == JsonSchemaType.Integer && type.IsEnum() && !type.IsDefined(typeof (FlagsAttribute), true))
            {
              CurrentSchema.Enum = new List<JToken>();
              CurrentSchema.Options = new Dictionary<JToken, string>();

              EnumValues<long> enumValues = EnumUtils.GetNamesAndValues<long>(type);
              foreach (EnumValue<long> enumValue in enumValues)
              {
                JToken value = JToken.FromObject(enumValue.Value);

                CurrentSchema.Enum.Add(value);
                CurrentSchema.Options.Add(value, enumValue.Name);
              }
            }
            break;
          case JsonContractType.String:
            JsonSchemaType schemaType = (!ReflectionUtils.IsNullable(contract.UnderlyingType))
                                          ? JsonSchemaType.String
                                          : AddNullType(JsonSchemaType.String, valueRequired);

            CurrentSchema.Type = schemaType;
            break;
          case JsonContractType.Dictionary:
            CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);

            Type keyType;
            Type valueType;
            ReflectionUtils.GetDictionaryKeyValueTypes(type, out keyType, out valueType);

            if (keyType != null)
            {
              // can be converted to a string
              if (ConvertUtils.IsConvertible(keyType))
              {
                CurrentSchema.AdditionalProperties = GenerateInternal(valueType, Required.Default, false);
              }
            }
            break;
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
          case JsonContractType.Serializable:
            CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
            CurrentSchema.Id = GetTypeId(type, false);
            GenerateISerializableContract(type, (JsonISerializableContract) contract);
            break;
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
          case JsonContractType.Dynamic:
#endif
          case JsonContractType.Linq:
            CurrentSchema.Type = JsonSchemaType.Any;
            break;
          default:
            throw new JsonException("Unexpected contract type: {0}".FormatWith(CultureInfo.InvariantCulture, contract));
        }
      }

      return Pop().Schema;
    }

    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired)
    {
      if (valueRequired != Required.Always)
        return type | JsonSchemaType.Null;

      return type;
    }

    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
    {
      return ((value & flag) == flag);
    }

    private void GenerateObjectSchema(Type type, JsonObjectContract contract)
    {
      CurrentSchema.Properties = new Dictionary<string, JsonSchema>();
      foreach (JsonProperty property in contract.Properties)
      {
        if (!property.Ignored)
        {
          bool optional = property.NullValueHandling == NullValueHandling.Ignore ||
                          HasFlag(property.DefaultValueHandling.GetValueOrDefault(), DefaultValueHandling.Ignore) ||
                          property.ShouldSerialize != null ||
                          property.GetIsSpecified != null;

          JsonSchema propertySchema = GenerateInternal(property.PropertyType, property.Required, !optional);

          if (property.DefaultValue != null)
            propertySchema.Default = JToken.FromObject(property.DefaultValue);

          CurrentSchema.Properties.Add(property.PropertyName, propertySchema);
        }
      }

      if (type.IsSealed())
        CurrentSchema.AllowAdditionalProperties = false;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract)
    {
      CurrentSchema.AllowAdditionalProperties = true;
    }
#endif

    internal static bool HasFlag(JsonSchemaType? value, JsonSchemaType flag)
    {
      // default value is Any
      if (value == null)
        return true;

      bool match = ((value & flag) == flag);
      if (match)
        return true;

      // integer is a subset of float
      if (value == JsonSchemaType.Float && flag == JsonSchemaType.Integer)
        return true;

      return false;
    }

    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired)
    {
      JsonSchemaType schemaType = JsonSchemaType.None;
      if (valueRequired != Required.Always && ReflectionUtils.IsNullable(type))
      {
        schemaType = JsonSchemaType.Null;
        if (ReflectionUtils.IsNullableType(type))
          type = Nullable.GetUnderlyingType(type);
      }

      TypeCode typeCode = ConvertUtils.GetTypeCode(type);

      switch (typeCode)
      {
        case TypeCode.Empty:
        case TypeCode.Object:
          return schemaType | JsonSchemaType.String;
#if !(NETFX_CORE || PORTABLE)
        case TypeCode.DBNull:
          return schemaType | JsonSchemaType.Null;
#endif
        case TypeCode.Boolean:
          return schemaType | JsonSchemaType.Boolean;
        case TypeCode.Char:
          return schemaType | JsonSchemaType.String;
        case TypeCode.SByte:
        case TypeCode.Byte:
        case TypeCode.Int16:
        case TypeCode.UInt16:
        case TypeCode.Int32:
        case TypeCode.UInt32:
        case TypeCode.Int64:
        case TypeCode.UInt64:
          return schemaType | JsonSchemaType.Integer;
        case TypeCode.Single:
        case TypeCode.Double:
        case TypeCode.Decimal:
          return schemaType | JsonSchemaType.Float;
        // convert to string?
        case TypeCode.DateTime:
          return schemaType | JsonSchemaType.String;
        case TypeCode.String:
          return schemaType | JsonSchemaType.String;
        default:
          throw new JsonException("Unexpected type code '{0}' for type '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeCode, type));
      }
    }
  }
}

#endregion Schema_JsonSchemaGenerator.cs

/// ********   File: \Schema\JsonSchemaModel.cs
#region Schema_JsonSchemaModel.cs

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaModel
  {
    public bool Required { get; set; }
    public JsonSchemaType Type { get; set; }
    public int? MinimumLength { get; set; }
    public int? MaximumLength { get; set; }
    public double? DivisibleBy { get; set; }
    public double? Minimum { get; set; }
    public double? Maximum { get; set; }
    public bool ExclusiveMinimum { get; set; }
    public bool ExclusiveMaximum { get; set; }
    public int? MinimumItems { get; set; }
    public int? MaximumItems { get; set; }
    public IList<string> Patterns { get; set; }
    public IList<JsonSchemaModel> Items { get; set; }
    public IDictionary<string, JsonSchemaModel> Properties { get; set; }
    public IDictionary<string, JsonSchemaModel> PatternProperties { get; set; }
    public JsonSchemaModel AdditionalProperties { get; set; }
    public bool AllowAdditionalProperties { get; set; }
    public IList<JToken> Enum { get; set; }
    public JsonSchemaType Disallow { get; set; }

    public JsonSchemaModel()
    {
      Type = JsonSchemaType.Any;
      AllowAdditionalProperties = true;
      Required = false;
    }

    public static JsonSchemaModel Create(IList<JsonSchema> schemata)
    {
      JsonSchemaModel model = new JsonSchemaModel();

      foreach (JsonSchema schema in schemata)
      {
        Combine(model, schema);
      }

      return model;
    }

    private static void Combine(JsonSchemaModel model, JsonSchema schema)
    {
      // Version 3 of the Draft JSON Schema has the default value of Not Required
      model.Required = model.Required || (schema.Required ?? false);
      model.Type = model.Type & (schema.Type ?? JsonSchemaType.Any);

      model.MinimumLength = MathUtils.Max(model.MinimumLength, schema.MinimumLength);
      model.MaximumLength = MathUtils.Min(model.MaximumLength, schema.MaximumLength);

      // not sure what is the best way to combine divisibleBy
      model.DivisibleBy = MathUtils.Max(model.DivisibleBy, schema.DivisibleBy);

      model.Minimum = MathUtils.Max(model.Minimum, schema.Minimum);
      model.Maximum = MathUtils.Max(model.Maximum, schema.Maximum);
      model.ExclusiveMinimum = model.ExclusiveMinimum || (schema.ExclusiveMinimum ?? false);
      model.ExclusiveMaximum = model.ExclusiveMaximum || (schema.ExclusiveMaximum ?? false);

      model.MinimumItems = MathUtils.Max(model.MinimumItems, schema.MinimumItems);
      model.MaximumItems = MathUtils.Min(model.MaximumItems, schema.MaximumItems);
      model.AllowAdditionalProperties = model.AllowAdditionalProperties && schema.AllowAdditionalProperties;
      if (schema.Enum != null)
      {
        if (model.Enum == null)
          model.Enum = new List<JToken>();

        model.Enum.AddRangeDistinct(schema.Enum, new JTokenEqualityComparer());
      }
      model.Disallow = model.Disallow | (schema.Disallow ?? JsonSchemaType.None);

      if (schema.Pattern != null)
      {
        if (model.Patterns == null)
          model.Patterns = new List<string>();

        model.Patterns.AddDistinct(schema.Pattern);
      }
    }
  }
}
#endregion Schema_JsonSchemaModel.cs

/// ********   File: \Schema\JsonSchemaModelBuilder.cs
#region Schema_JsonSchemaModelBuilder.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaModelBuilder
  {
    private JsonSchemaNodeCollection _nodes = new JsonSchemaNodeCollection();
    private Dictionary<JsonSchemaNode, JsonSchemaModel> _nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
    private JsonSchemaNode _node ;

    public JsonSchemaModel Build(JsonSchema schema)
    {
      _nodes = new JsonSchemaNodeCollection();
      _node = AddSchema(null, schema);

      _nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
      JsonSchemaModel model = BuildNodeModel(_node);

      return model;
    }

    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema)
    {
      string newId;
      if (existingNode != null)
      {
        if (existingNode.Schemas.Contains(schema))
          return existingNode;

        newId = JsonSchemaNode.GetId(existingNode.Schemas.Union(new[] { schema }));
      }
      else
      {
        newId = JsonSchemaNode.GetId(new[] { schema });
      }

      if (_nodes.Contains(newId))
        return _nodes[newId];

      JsonSchemaNode currentNode = (existingNode != null)
        ? existingNode.Combine(schema)
        : new JsonSchemaNode(schema);

      _nodes.Add(currentNode);

      AddProperties(schema.Properties, currentNode.Properties);

      AddProperties(schema.PatternProperties, currentNode.PatternProperties);

      if (schema.Items != null)
      {
        for (int i = 0; i < schema.Items.Count; i++)
        {
          AddItem(currentNode, i, schema.Items[i]);
        }
      }

      if (schema.AdditionalProperties != null)
        AddAdditionalProperties(currentNode, schema.AdditionalProperties);

      if (schema.Extends != null)
        currentNode = AddSchema(currentNode, schema.Extends);

      return currentNode;
    }

    public void AddProperties(IDictionary<string, JsonSchema> source, IDictionary<string, JsonSchemaNode> target)
    {
      if (source != null)
      {
        foreach (KeyValuePair<string, JsonSchema> property in source)
        {
          AddProperty(target, property.Key, property.Value);
        }
      }
    }

    public void AddProperty(IDictionary<string, JsonSchemaNode> target, string propertyName, JsonSchema schema)
    {
      JsonSchemaNode propertyNode;
      target.TryGetValue(propertyName, out propertyNode);

      target[propertyName] = AddSchema(propertyNode, schema);
    }

    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema)
    {
      JsonSchemaNode existingItemNode = (parentNode.Items.Count > index)
                                  ? parentNode.Items[index]
                                  : null;

      JsonSchemaNode newItemNode = AddSchema(existingItemNode, schema);
      
      if (!(parentNode.Items.Count > index))
      {
        parentNode.Items.Add(newItemNode);
      }
      else
      {
        parentNode.Items[index] = newItemNode;
      }
    }

    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema)
    {
      parentNode.AdditionalProperties = AddSchema(parentNode.AdditionalProperties, schema);
    }

    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node)
    {
      JsonSchemaModel model;
      if (_nodeModels.TryGetValue(node, out model))
        return model;
      
      model = JsonSchemaModel.Create(node.Schemas);
      _nodeModels[node] = model;

      foreach (KeyValuePair<string, JsonSchemaNode> property in node.Properties)
      {
        if (model.Properties == null)
          model.Properties = new Dictionary<string, JsonSchemaModel>();

        model.Properties[property.Key] = BuildNodeModel(property.Value);
      }
      foreach (KeyValuePair<string, JsonSchemaNode> property in node.PatternProperties)
      {
        if (model.PatternProperties == null)
          model.PatternProperties = new Dictionary<string, JsonSchemaModel>();

        model.PatternProperties[property.Key] = BuildNodeModel(property.Value);
      }
      foreach (JsonSchemaNode t in node.Items)
      {
        if (model.Items == null)
          model.Items = new List<JsonSchemaModel>();

        model.Items.Add(BuildNodeModel(t));
      }
      if (node.AdditionalProperties != null)
        model.AdditionalProperties = BuildNodeModel(node.AdditionalProperties);

      return model;
    }
  }
}
#endregion Schema_JsonSchemaModelBuilder.cs

/// ********   File: \Schema\JsonSchemaNode.cs
#region Schema_JsonSchemaNode.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaNode
  {
    public string Id { get; private set; }
    public ReadOnlyCollection<JsonSchema> Schemas { get; private set; }
    public Dictionary<string, JsonSchemaNode> Properties { get; private set; }
    public Dictionary<string, JsonSchemaNode> PatternProperties { get; private set; }
    public List<JsonSchemaNode> Items { get; private set; }
    public JsonSchemaNode AdditionalProperties { get; set; }

    public JsonSchemaNode(JsonSchema schema)
    {
      Schemas = new ReadOnlyCollection<JsonSchema>(new []{ schema });
      Properties = new Dictionary<string, JsonSchemaNode>();
      PatternProperties = new Dictionary<string, JsonSchemaNode>();
      Items = new List<JsonSchemaNode>();

      Id = GetId(Schemas);
    }

    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema)
    {
      Schemas = new ReadOnlyCollection<JsonSchema>(source.Schemas.Union(new[] { schema }).ToList());
      Properties = new Dictionary<string, JsonSchemaNode>(source.Properties);
      PatternProperties = new Dictionary<string, JsonSchemaNode>(source.PatternProperties);
      Items = new List<JsonSchemaNode>(source.Items);
      AdditionalProperties = source.AdditionalProperties;

      Id = GetId(Schemas);
    }

    public JsonSchemaNode Combine(JsonSchema schema)
    {
      return new JsonSchemaNode(this, schema);
    }

    public static string GetId(IEnumerable<JsonSchema> schemata)
    {
      return string.Join("-", schemata.Select(s => s.InternalId).OrderBy(id => id, StringComparer.Ordinal).ToArray());
    }
  }
}
#endregion Schema_JsonSchemaNode.cs

/// ********   File: \Schema\JsonSchemaNodeCollection.cs
#region Schema_JsonSchemaNodeCollection.cs

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaNodeCollection : KeyedCollection<string, JsonSchemaNode>
  {
    protected override string GetKeyForItem(JsonSchemaNode item)
    {
      return item.Id;
    }
  }
}
#endregion Schema_JsonSchemaNodeCollection.cs

/// ********   File: \Schema\JsonSchemaResolver.cs
#region Schema_JsonSchemaResolver.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Resolves <see cref="JsonSchema"/> from an id.
  /// </summary>
  public class JsonSchemaResolver
  {
    /// <summary>
    /// Gets or sets the loaded schemas.
    /// </summary>
    /// <value>The loaded schemas.</value>
    public IList<JsonSchema> LoadedSchemas { get; protected set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaResolver"/> class.
    /// </summary>
    public JsonSchemaResolver()
    {
      LoadedSchemas = new List<JsonSchema>();
    }

    /// <summary>
    /// Gets a <see cref="JsonSchema"/> for the specified id.
    /// </summary>
    /// <param name="id">The id.</param>
    /// <returns>A <see cref="JsonSchema"/> for the specified id.</returns>
    public virtual JsonSchema GetSchema(string id)
    {
      JsonSchema schema = LoadedSchemas.SingleOrDefault(s => s.Id == id);
      return schema;
    }
  }
}
#endregion Schema_JsonSchemaResolver.cs

/// ********   File: \Schema\JsonSchemaType.cs
#region Schema_JsonSchemaType.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// The value types allowed by the <see cref="JsonSchema"/>.
  /// </summary>
  [Flags]
  public enum JsonSchemaType
  {
    /// <summary>
    /// No type specified.
    /// </summary>
    None = 0,
    /// <summary>
    /// String type.
    /// </summary>
    String = 1,
    /// <summary>
    /// Float type.
    /// </summary>
    Float = 2,
    /// <summary>
    /// Integer type.
    /// </summary>
    Integer = 4,
    /// <summary>
    /// Boolean type.
    /// </summary>
    Boolean = 8,
    /// <summary>
    /// Object type.
    /// </summary>
    Object = 16,
    /// <summary>
    /// Array type.
    /// </summary>
    Array = 32,
    /// <summary>
    /// Null type.
    /// </summary>
    Null = 64,
    /// <summary>
    /// Any type.
    /// </summary>
    Any = String | Float | Integer | Boolean | Object | Array | Null
  }
}
#endregion Schema_JsonSchemaType.cs

/// ********   File: \Schema\JsonSchemaWriter.cs
#region Schema_JsonSchemaWriter.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Schema
{
  internal class JsonSchemaWriter
  {
    private readonly JsonWriter _writer;
    private readonly JsonSchemaResolver _resolver;

    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver)
    {
      ValidationUtils.ArgumentNotNull(writer, "writer");
      _writer = writer;
      _resolver = resolver;
    }

    private void ReferenceOrWriteSchema(JsonSchema schema)
    {
      if (schema.Id != null && _resolver.GetSchema(schema.Id) != null)
      {
        _writer.WriteStartObject();
        _writer.WritePropertyName(JsonSchemaConstants.ReferencePropertyName);
        _writer.WriteValue(schema.Id);
        _writer.WriteEndObject();
      }
      else
      {
        WriteSchema(schema);
      }
    }

    public void WriteSchema(JsonSchema schema)
    {
      ValidationUtils.ArgumentNotNull(schema, "schema");

      if (!_resolver.LoadedSchemas.Contains(schema))
        _resolver.LoadedSchemas.Add(schema);

      _writer.WriteStartObject();
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.IdPropertyName, schema.Id);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.TitlePropertyName, schema.Title);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.DescriptionPropertyName, schema.Description);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.RequiredPropertyName, schema.Required);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.ReadOnlyPropertyName, schema.ReadOnly);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.HiddenPropertyName, schema.Hidden);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.TransientPropertyName, schema.Transient);
      if (schema.Type != null)
        WriteType(JsonSchemaConstants.TypePropertyName, _writer, schema.Type.Value);
      if (!schema.AllowAdditionalProperties)
      {
        _writer.WritePropertyName(JsonSchemaConstants.AdditionalPropertiesPropertyName);
        _writer.WriteValue(schema.AllowAdditionalProperties);
      }
      else
      {
        if (schema.AdditionalProperties != null)
        {
          _writer.WritePropertyName(JsonSchemaConstants.AdditionalPropertiesPropertyName);
          ReferenceOrWriteSchema(schema.AdditionalProperties);
        }
      }
      WriteSchemaDictionaryIfNotNull(_writer, JsonSchemaConstants.PropertiesPropertyName, schema.Properties);
      WriteSchemaDictionaryIfNotNull(_writer, JsonSchemaConstants.PatternPropertiesPropertyName, schema.PatternProperties);
      WriteItems(schema);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MinimumPropertyName, schema.Minimum);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MaximumPropertyName, schema.Maximum);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.ExclusiveMinimumPropertyName, schema.ExclusiveMinimum);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.ExclusiveMaximumPropertyName, schema.ExclusiveMaximum);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MinimumLengthPropertyName, schema.MinimumLength);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MaximumLengthPropertyName, schema.MaximumLength);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MinimumItemsPropertyName, schema.MinimumItems);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.MaximumItemsPropertyName, schema.MaximumItems);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.DivisibleByPropertyName, schema.DivisibleBy);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.FormatPropertyName, schema.Format);
      WritePropertyIfNotNull(_writer, JsonSchemaConstants.PatternPropertyName, schema.Pattern);
      if (schema.Enum != null)
      {
        _writer.WritePropertyName(JsonSchemaConstants.EnumPropertyName);
        _writer.WriteStartArray();
        foreach (JToken token in schema.Enum)
        {
          token.WriteTo(_writer);
        }
        _writer.WriteEndArray();
      }
      if (schema.Default != null)
      {
        _writer.WritePropertyName(JsonSchemaConstants.DefaultPropertyName);
        schema.Default.WriteTo(_writer);
      }
      if (schema.Options != null)
      {
        _writer.WritePropertyName(JsonSchemaConstants.OptionsPropertyName);
        _writer.WriteStartArray();
        foreach (KeyValuePair<JToken, string> option in schema.Options)
        {
          _writer.WriteStartObject();
          _writer.WritePropertyName(JsonSchemaConstants.OptionValuePropertyName);
          option.Key.WriteTo(_writer);
          if (option.Value != null)
          {
            _writer.WritePropertyName(JsonSchemaConstants.OptionLabelPropertyName);
            _writer.WriteValue(option.Value);
          }
          _writer.WriteEndObject();
        }
        _writer.WriteEndArray();
      }
      if (schema.Disallow != null)
        WriteType(JsonSchemaConstants.DisallowPropertyName, _writer, schema.Disallow.Value);
      if (schema.Extends != null)
      {
        _writer.WritePropertyName(JsonSchemaConstants.ExtendsPropertyName);
        ReferenceOrWriteSchema(schema.Extends);
      }
      _writer.WriteEndObject();
    }

    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary<string, JsonSchema> properties)
    {
      if (properties != null)
      {
        writer.WritePropertyName(propertyName);
        writer.WriteStartObject();
        foreach (KeyValuePair<string, JsonSchema> property in properties)
        {
          writer.WritePropertyName(property.Key);
          ReferenceOrWriteSchema(property.Value);
        }
        writer.WriteEndObject();
      }
    }

    private void WriteItems(JsonSchema schema)
    {
      if (CollectionUtils.IsNullOrEmpty(schema.Items))
        return;

      _writer.WritePropertyName(JsonSchemaConstants.ItemsPropertyName);

      if (schema.Items.Count == 1)
      {
        ReferenceOrWriteSchema(schema.Items[0]);
        return;
      }

      _writer.WriteStartArray();
      foreach (JsonSchema itemSchema in schema.Items)
      {
        ReferenceOrWriteSchema(itemSchema);
      }
      _writer.WriteEndArray();
    }

    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type)
    {
      IList<JsonSchemaType> types;
      if (System.Enum.IsDefined(typeof(JsonSchemaType), type))
        types = new List<JsonSchemaType> { type };
      else
        types = EnumUtils.GetFlagsValues(type).Where(v => v != JsonSchemaType.None).ToList();

      if (types.Count == 0)
        return;

      writer.WritePropertyName(propertyName);

      if (types.Count == 1)
      {
        writer.WriteValue(JsonSchemaBuilder.MapType(types[0]));
        return;
      }

      writer.WriteStartArray();
      foreach (JsonSchemaType jsonSchemaType in types)
      {
        writer.WriteValue(JsonSchemaBuilder.MapType(jsonSchemaType));
      }
      writer.WriteEndArray();
    }

    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value)
    {
      if (value != null)
      {
        writer.WritePropertyName(propertyName);
        writer.WriteValue(value);
      }
    }
  }
}

#endregion Schema_JsonSchemaWriter.cs

/// ********   File: \Schema\UndefinedSchemaIdHandling.cs
#region Schema_UndefinedSchemaIdHandling.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Specifies undefined schema Id handling options for the <see cref="JsonSchemaGenerator"/>.
  /// </summary>
  public enum UndefinedSchemaIdHandling
  {
    /// <summary>
    /// Do not infer a schema Id.
    /// </summary>
    None = 0,
    /// <summary>
    /// Use the .NET type name as the schema Id.
    /// </summary>
    UseTypeName = 1,
    /// <summary>
    /// Use the assembly qualified .NET type name as the schema Id.
    /// </summary>
    UseAssemblyQualifiedName = 2,
  }
}
#endregion Schema_UndefinedSchemaIdHandling.cs

/// ********   File: \Schema\ValidationEventArgs.cs
#region Schema_ValidationEventArgs.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Returns detailed information related to the <see cref="ValidationEventHandler"/>.
  /// </summary>
  public class ValidationEventArgs : EventArgs
  {
    private readonly JsonSchemaException _ex;

    internal ValidationEventArgs(JsonSchemaException ex)
    {
      ValidationUtils.ArgumentNotNull(ex, "ex");
      _ex = ex;
    }

    /// <summary>
    /// Gets the <see cref="JsonSchemaException"/> associated with the validation error.
    /// </summary>
    /// <value>The JsonSchemaException associated with the validation error.</value>
    public JsonSchemaException Exception
    {
      get { return _ex; }
    }

    /// <summary>
    /// Gets the path of the JSON location where the validation error occurred.
    /// </summary>
    /// <value>The path of the JSON location where the validation error occurred.</value>
    public string Path
    {
      get { return _ex.Path; }
    }

    /// <summary>
    /// Gets the text description corresponding to the validation error.
    /// </summary>
    /// <value>The text description.</value>
    public string Message
    {
      get { return _ex.Message; }
    }
  }
}
#endregion Schema_ValidationEventArgs.cs

/// ********   File: \Schema\ValidationEventHandler.cs
#region Schema_ValidationEventHandler.cs

namespace Newtonsoft.Json.Schema
{
  /// <summary>
  /// Represents the callback method that will handle JSON schema validation events and the <see cref="ValidationEventArgs"/>.
  /// </summary>
  public delegate void ValidationEventHandler(object sender, ValidationEventArgs e);
}
#endregion Schema_ValidationEventHandler.cs

/// ********   File: \Serialization\CachedAttributeGetter.cs
#region Serialization_CachedAttributeGetter.cs

#if NETFX_CORE || PORTABLE
#endif

namespace Newtonsoft.Json.Serialization
{
  internal static class CachedAttributeGetter<T> where T : Attribute
  {
    private static readonly ThreadSafeStore<ICustomAttributeProvider, T> TypeAttributeCache = new ThreadSafeStore<ICustomAttributeProvider, T>(JsonTypeReflector.GetAttribute<T>);

    public static T GetAttribute(ICustomAttributeProvider type)
    {
      return TypeAttributeCache.Get(type);
    }
  }
}

#endregion Serialization_CachedAttributeGetter.cs

/// ********   File: \Serialization\CamelCasePropertyNamesContractResolver.cs
#region Serialization_CamelCasePropertyNamesContractResolver.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Resolves member mappings for a type, camel casing property names.
  /// </summary>
  public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="CamelCasePropertyNamesContractResolver"/> class.
    /// </summary>
    public CamelCasePropertyNamesContractResolver()
      : base(true)
    {
    }

    /// <summary>
    /// Resolves the name of the property.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <returns>The property name camel cased.</returns>
    protected internal override string ResolvePropertyName(string propertyName)
    {
      // lower case the first letter of the passed in name
      return StringUtils.ToCamelCase(propertyName);
    }
  }
}
#endregion Serialization_CamelCasePropertyNamesContractResolver.cs

/// ********   File: \Serialization\DefaultContractResolver.cs
#region Serialization_DefaultContractResolver.cs

#if !(NET35 || NET20 || SILVERLIGHT || WINDOWS_PHONE || PORTABLE)
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif
#if !(NETFX_CORE || PORTABLE)
#endif
#if NETFX_CORE || PORTABLE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
  internal struct ResolverContractKey : IEquatable<ResolverContractKey>
  {
    private readonly Type _resolverType;
    private readonly Type _contractType;

    public ResolverContractKey(Type resolverType, Type contractType)
    {
      _resolverType = resolverType;
      _contractType = contractType;
    }

    public override int GetHashCode()
    {
      return _resolverType.GetHashCode() ^ _contractType.GetHashCode();
    }

    public override bool Equals(object obj)
    {
      if (!(obj is ResolverContractKey))
        return false;

      return Equals((ResolverContractKey)obj);
    }

    public bool Equals(ResolverContractKey other)
    {
      return (_resolverType == other._resolverType && _contractType == other._contractType);
    }
  }

  /// <summary>
  /// Used by <see cref="JsonSerializer"/> to resolves a <see cref="JsonContract"/> for a given <see cref="Type"/>.
  /// </summary>
  public class DefaultContractResolver : IContractResolver
  {
    private static readonly IContractResolver _instance = new DefaultContractResolver(true);
    internal static IContractResolver Instance
    {
        get { return _instance; }
    }
    private static readonly IList<JsonConverter> BuiltInConverters = new List<JsonConverter>
      {
#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
        new EntityKeyMemberConverter(),
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
        new ExpandoObjectConverter(),
#endif
#if (!(SILVERLIGHT || PORTABLE) || WINDOWS_PHONE)
        new XmlNodeConverter(),
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        new BinaryConverter(),
        new DataSetConverter(),
        new DataTableConverter(),
#endif
#if NETFX_CORE
        new JsonValueConverter(),
#endif
        new KeyValuePairConverter(),
        new BsonObjectIdConverter()
      };

    private static Dictionary<ResolverContractKey, JsonContract> _sharedContractCache;
    private static readonly object _typeContractCacheLock = new object();

    private Dictionary<ResolverContractKey, JsonContract> _instanceContractCache;
    private readonly bool _sharedCache;

    /// <summary>
    /// Gets a value indicating whether members are being get and set using dynamic code generation.
    /// This value is determined by the runtime permissions available.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
    /// </value>
    public bool DynamicCodeGeneration
    {
      get { return JsonTypeReflector.DynamicCodeGeneration; }
    }

#if !NETFX_CORE
    /// <summary>
    /// Gets or sets the default members search flags.
    /// </summary>
    /// <value>The default members search flags.</value>
    public BindingFlags DefaultMembersSearchFlags { get; set; }
#else
    private BindingFlags DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
#endif

    /// <summary>
    /// Gets or sets a value indicating whether compiler generated members should be serialized.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
    /// </value>
    public bool SerializeCompilerGeneratedMembers { get; set; }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Gets or sets a value indicating whether to ignore the <see cref="ISerializable"/> interface when serializing and deserializing types.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if the <see cref="ISerializable"/> interface will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
    /// </value>
    public bool IgnoreSerializableInterface { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether to ignore the <see cref="SerializableAttribute"/> attribute when serializing and deserializing types.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if the <see cref="SerializableAttribute"/> attribute will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
    /// </value>
    public bool IgnoreSerializableAttribute { get; set; }
#endif

    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultContractResolver"/> class.
    /// </summary>
    public DefaultContractResolver()
      : this(false)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultContractResolver"/> class.
    /// </summary>
    /// <param name="shareCache">
    /// If set to <c>true</c> the <see cref="DefaultContractResolver"/> will use a cached shared with other resolvers of the same type.
    /// Sharing the cache will significantly performance because expensive reflection will only happen once but could cause unexpected
    /// behavior if different instances of the resolver are suppose to produce different results. When set to false it is highly
    /// recommended to reuse <see cref="DefaultContractResolver"/> instances with the <see cref="JsonSerializer"/>.
    /// </param>
    public DefaultContractResolver(bool shareCache)
    {
#if !NETFX_CORE
      DefaultMembersSearchFlags = BindingFlags.Public | BindingFlags.Instance;
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      IgnoreSerializableAttribute = true;
#endif

      _sharedCache = shareCache;
    }

    private Dictionary<ResolverContractKey, JsonContract> GetCache()
    {
      if (_sharedCache)
        return _sharedContractCache;
      else
        return _instanceContractCache;
    }

    private void UpdateCache(Dictionary<ResolverContractKey, JsonContract> cache)
    {
      if (_sharedCache)
        _sharedContractCache = cache;
      else
        _instanceContractCache = cache;
    }

    /// <summary>
    /// Resolves the contract for a given type.
    /// </summary>
    /// <param name="type">The type to resolve a contract for.</param>
    /// <returns>The contract for a given type.</returns>
    public virtual JsonContract ResolveContract(Type type)
    {
      if (type == null)
        throw new ArgumentNullException("type");

      JsonContract contract;
      ResolverContractKey key = new ResolverContractKey(GetType(), type);
      Dictionary<ResolverContractKey, JsonContract> cache = GetCache();
      if (cache == null || !cache.TryGetValue(key, out contract))
      {
        contract = CreateContract(type);

        // avoid the possibility of modifying the cache dictionary while another thread is accessing it
        lock (_typeContractCacheLock)
        {
          cache = GetCache();
          Dictionary<ResolverContractKey, JsonContract> updatedCache =
            (cache != null)
              ? new Dictionary<ResolverContractKey, JsonContract>(cache)
              : new Dictionary<ResolverContractKey, JsonContract>();
          updatedCache[key] = contract;

          UpdateCache(updatedCache);
        }
      }

      return contract;
    }

    /// <summary>
    /// Gets the serializable members for the type.
    /// </summary>
    /// <param name="objectType">The type to get serializable members for.</param>
    /// <returns>The serializable members for the type.</returns>
    protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
    {
      bool ignoreSerializableAttribute;
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      ignoreSerializableAttribute = IgnoreSerializableAttribute;
#else
      ignoreSerializableAttribute = true;
#endif

      MemberSerialization memberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, ignoreSerializableAttribute);

      List<MemberInfo> allMembers = ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)
        .Where(m => !ReflectionUtils.IsIndexedProperty(m)).ToList();

      List<MemberInfo> serializableMembers = new List<MemberInfo>();
      
      if (memberSerialization != MemberSerialization.Fields)
      {
#if !PocketPC && !NET20
        DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(objectType);
#endif

        List<MemberInfo> defaultMembers = ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags)
         .Where(m => !ReflectionUtils.IsIndexedProperty(m)).ToList();
        
        foreach (MemberInfo member in allMembers)
        {
          // exclude members that are compiler generated if set
          if (SerializeCompilerGeneratedMembers || !member.IsDefined(typeof (CompilerGeneratedAttribute), true))
          {
            if (defaultMembers.Contains(member))
            {
              // add all members that are found by default member search
              serializableMembers.Add(member);
            }
            else
            {
              // add members that are explicitly marked with JsonProperty/DataMember attribute
              // or are a field if serializing just fields
              if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(member.GetCustomAttributeProvider()) != null)
                serializableMembers.Add(member);
#if !PocketPC && !NET20
              else if (dataContractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>(member.GetCustomAttributeProvider()) != null)
                serializableMembers.Add(member);
#endif
              else if (memberSerialization == MemberSerialization.Fields && member.MemberType() == MemberTypes.Field)
                serializableMembers.Add(member);
            }
          }
        }

#if !PocketPC && !SILVERLIGHT && !NET20
        Type match;
        // don't include EntityKey on entities objects... this is a bit hacky
        if (objectType.AssignableToTypeName("System.Data.Objects.DataClasses.EntityObject", out match))
          serializableMembers = serializableMembers.Where(ShouldSerializeEntityMember).ToList();
#endif
      }
      else
      {
        // serialize all fields
        foreach (MemberInfo member in allMembers)
        {
          if (member.MemberType() == MemberTypes.Field)
            serializableMembers.Add(member);
        }
      }

      return serializableMembers;
    }

#if !PocketPC && !SILVERLIGHT && !NET20
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
    {
      PropertyInfo propertyInfo = memberInfo as PropertyInfo;
      if (propertyInfo != null)
      {
        if (propertyInfo.PropertyType.IsGenericType() && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1")
          return false;
      }

      return true;
    }
#endif

    /// <summary>
    /// Creates a <see cref="JsonObjectContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonObjectContract"/> for the given type.</returns>
    protected virtual JsonObjectContract CreateObjectContract(Type objectType)
    {
      JsonObjectContract contract = new JsonObjectContract(objectType);
      InitializeContract(contract);

      bool ignoreSerializableAttribute;
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      ignoreSerializableAttribute = IgnoreSerializableAttribute;
#else
      ignoreSerializableAttribute = true;
#endif

      contract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(contract.NonNullableUnderlyingType, ignoreSerializableAttribute);
      contract.Properties.AddRange(CreateProperties(contract.NonNullableUnderlyingType, contract.MemberSerialization));

      JsonObjectAttribute attribute = JsonTypeReflector.GetJsonObjectAttribute(contract.NonNullableUnderlyingType);
      if (attribute != null)
        contract.ItemRequired = attribute._itemRequired;

      ConstructorInfo overrideConstructor = GetAttributeConstructor(contract.NonNullableUnderlyingType);
        
      // check if a JsonConstructorAttribute has been defined and use that
      if (overrideConstructor != null)
      {
        contract.OverrideConstructor = overrideConstructor;
        contract.ConstructorParameters.AddRange(CreateConstructorParameters(overrideConstructor, contract.Properties));
      }
      else if (contract.MemberSerialization == MemberSerialization.Fields)
      {
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        // mimic DataContractSerializer behaviour when populating fields by overriding default creator to create an uninitialized object
        // note that this is only possible when the application is fully trusted so fall back to using the default constructor (if available) in partial trust
        if (JsonTypeReflector.FullyTrusted)
          contract.DefaultCreator = contract.GetUninitializedObject;
#endif
      }
      else if (contract.DefaultCreator == null || contract.DefaultCreatorNonPublic)
      {
        ConstructorInfo constructor = GetParametrizedConstructor(contract.NonNullableUnderlyingType);
        if (constructor != null)
        {
          contract.ParametrizedConstructor = constructor;
          contract.ConstructorParameters.AddRange(CreateConstructorParameters(constructor, contract.Properties));
        }
      }
      return contract;
    }

    private ConstructorInfo GetAttributeConstructor(Type objectType)
    {
      IList<ConstructorInfo> markedConstructors = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Where(c => c.IsDefined(typeof(JsonConstructorAttribute), true)).ToList();

      if (markedConstructors.Count > 1)
        throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
      else if (markedConstructors.Count == 1)
        return markedConstructors[0];

      // little hack to get Version objects to deserialize correctly
      if (objectType == typeof(Version))
        return objectType.GetConstructor(new [] { typeof(int), typeof(int), typeof(int), typeof(int) });

      return null;
    }

    private ConstructorInfo GetParametrizedConstructor(Type objectType)
    {
      IList<ConstructorInfo> constructors = objectType.GetConstructors(BindingFlags.Public | BindingFlags.Instance).ToList();

      if (constructors.Count == 1)
        return constructors[0];
      else
        return null;
    }

    /// <summary>
    /// Creates the constructor parameters.
    /// </summary>
    /// <param name="constructor">The constructor to create properties for.</param>
    /// <param name="memberProperties">The type's member properties.</param>
    /// <returns>Properties for the given <see cref="ConstructorInfo"/>.</returns>
    protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
    {
      var constructorParameters = constructor.GetParameters();

      JsonPropertyCollection parameterCollection = new JsonPropertyCollection(constructor.DeclaringType);

      foreach (ParameterInfo parameterInfo in constructorParameters)
      {
        // it is possible to generate a ParameterInfo with a null name using Reflection.Emit
        // protect against an ArgumentNullException from GetClosestMatchProperty by testing for null here
        JsonProperty matchingMemberProperty = (parameterInfo.Name != null) ? memberProperties.GetClosestMatchProperty(parameterInfo.Name) : null;

        // type must match as well as name
        if (matchingMemberProperty != null && matchingMemberProperty.PropertyType != parameterInfo.ParameterType)
          matchingMemberProperty = null;

        JsonProperty property = CreatePropertyFromConstructorParameter(matchingMemberProperty, parameterInfo);

        if (property != null)
        {
          parameterCollection.AddProperty(property);
        }
      }

      return parameterCollection;
    }

    /// <summary>
    /// Creates a <see cref="JsonProperty"/> for the given <see cref="ParameterInfo"/>.
    /// </summary>
    /// <param name="matchingMemberProperty">The matching member property.</param>
    /// <param name="parameterInfo">The constructor parameter.</param>
    /// <returns>A created <see cref="JsonProperty"/> for the given <see cref="ParameterInfo"/>.</returns>
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
    {
      JsonProperty property = new JsonProperty();
      property.PropertyType = parameterInfo.ParameterType;

      bool allowNonPublicAccess;
      SetPropertySettingsFromAttributes(property, parameterInfo.GetCustomAttributeProvider(), parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out allowNonPublicAccess);

      property.Readable = false;
      property.Writable = true;

      // "inherit" values from matching member property if unset on parameter
      if (matchingMemberProperty != null)
      {
        property.PropertyName = (property.PropertyName != parameterInfo.Name) ? property.PropertyName : matchingMemberProperty.PropertyName;
        property.Converter = property.Converter ?? matchingMemberProperty.Converter;
        property.MemberConverter = property.MemberConverter ?? matchingMemberProperty.MemberConverter;

        if (!property._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
          property.DefaultValue = matchingMemberProperty.DefaultValue;

        property._required = property._required ?? matchingMemberProperty._required;
        property.IsReference = property.IsReference ?? matchingMemberProperty.IsReference;
        property.NullValueHandling = property.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
        property.DefaultValueHandling = property.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
        property.ReferenceLoopHandling = property.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
        property.ObjectCreationHandling = property.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
        property.TypeNameHandling = property.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
      }

      return property;
    }

    /// <summary>
    /// Resolves the default <see cref="JsonConverter" /> for the contract.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>The contract's default <see cref="JsonConverter" />.</returns>
    protected virtual JsonConverter ResolveContractConverter(Type objectType)
    {
      return JsonTypeReflector.GetJsonConverter(objectType.GetCustomAttributeProvider(), objectType);
    }

    private Func<object> GetDefaultCreator(Type createdType)
    {
      return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
    }

#if !PocketPC && !NET20
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework", MessageId = "System.Runtime.Serialization.DataContractAttribute.#get_IsReference()")]
#endif
    private void InitializeContract(JsonContract contract)
    {
      JsonContainerAttribute containerAttribute = JsonTypeReflector.GetJsonContainerAttribute(contract.NonNullableUnderlyingType);
      if (containerAttribute != null)
      {
        contract.IsReference = containerAttribute._isReference;
      }
#if !PocketPC && !NET20
      else
      {
        DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType);
        // doesn't have a null value
        if (dataContractAttribute != null && dataContractAttribute.IsReference)
          contract.IsReference = true;
      }
#endif

      contract.Converter = ResolveContractConverter(contract.NonNullableUnderlyingType);

      // then see whether object is compadible with any of the built in converters
      contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.NonNullableUnderlyingType);

      if (ReflectionUtils.HasDefaultConstructor(contract.CreatedType, true)
        || contract.CreatedType.IsValueType())
      {
        contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);

        contract.DefaultCreatorNonPublic = (!contract.CreatedType.IsValueType() &&
                                            ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null);
      }

      ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
    }

    private void ResolveCallbackMethods(JsonContract contract, Type t)
    {
      if (t.BaseType() != null)
        ResolveCallbackMethods(contract, t.BaseType());

      MethodInfo onSerializing;
      MethodInfo onSerialized;
      MethodInfo onDeserializing;
      MethodInfo onDeserialized;
      MethodInfo onError;

      GetCallbackMethodsForType(t, out onSerializing, out onSerialized, out onDeserializing, out onDeserialized, out onError);

      if (onSerializing != null)
      {
#if NETFX_CORE
        if (!t.IsGenericType() || (t.GetGenericTypeDefinition() != typeof(ConcurrentDictionary<,>)))
          contract.OnSerializing = onSerializing;
#else
        contract.OnSerializing = onSerializing;
#endif
      }

      if (onSerialized != null)
        contract.OnSerialized = onSerialized;

      if (onDeserializing != null)
        contract.OnDeserializing = onDeserializing;

      if (onDeserialized != null)
      {
        // ConcurrentDictionary throws an error here so don't use its OnDeserialized - http://json.codeplex.com/discussions/257093
#if !(NET35 || NET20 || SILVERLIGHT || WINDOWS_PHONE || PORTABLE)
        if (!t.IsGenericType() || (t.GetGenericTypeDefinition() != typeof(ConcurrentDictionary<,>)))
          contract.OnDeserialized = onDeserialized;
#else
        contract.OnDeserialized = onDeserialized;
#endif
      }

      if (onError != null)
        contract.OnError = onError;
    }

    private void GetCallbackMethodsForType(Type type, out MethodInfo onSerializing, out MethodInfo onSerialized, out MethodInfo onDeserializing, out MethodInfo onDeserialized, out MethodInfo onError)
    {
      onSerializing = null;
      onSerialized = null;
      onDeserializing = null;
      onDeserialized = null;
      onError = null;

      foreach (MethodInfo method in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
      {
        // compact framework errors when getting parameters for a generic method
        // lame, but generic methods should not be callbacks anyway
        if (method.ContainsGenericParameters)
          continue;

        Type prevAttributeType = null;
        ParameterInfo[] parameters = method.GetParameters();

        if (IsValidCallback(method, parameters, typeof(OnSerializingAttribute), onSerializing, ref prevAttributeType))
        {
          onSerializing = method;
        }
        if (IsValidCallback(method, parameters, typeof(OnSerializedAttribute), onSerialized, ref prevAttributeType))
        {
          onSerialized = method;
        }
        if (IsValidCallback(method, parameters, typeof(OnDeserializingAttribute), onDeserializing, ref prevAttributeType))
        {
          onDeserializing = method;
        }
        if (IsValidCallback(method, parameters, typeof(OnDeserializedAttribute), onDeserialized, ref prevAttributeType))
        {
          onDeserialized = method;
        }
        if (IsValidCallback(method, parameters, typeof(OnErrorAttribute), onError, ref prevAttributeType))
        {
          onError = method;
        }
      }
    }

    /// <summary>
    /// Creates a <see cref="JsonDictionaryContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonDictionaryContract"/> for the given type.</returns>
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
    {
      JsonDictionaryContract contract = new JsonDictionaryContract(objectType);
      InitializeContract(contract);

      contract.PropertyNameResolver = ResolvePropertyName;

      return contract;
    }

    /// <summary>
    /// Creates a <see cref="JsonArrayContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonArrayContract"/> for the given type.</returns>
    protected virtual JsonArrayContract CreateArrayContract(Type objectType)
    {
      JsonArrayContract contract = new JsonArrayContract(objectType);
      InitializeContract(contract);

      return contract;
    }

    /// <summary>
    /// Creates a <see cref="JsonPrimitiveContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonPrimitiveContract"/> for the given type.</returns>
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
    {
      JsonPrimitiveContract contract = new JsonPrimitiveContract(objectType);
      InitializeContract(contract);

      return contract;
    }

    /// <summary>
    /// Creates a <see cref="JsonLinqContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonLinqContract"/> for the given type.</returns>
    protected virtual JsonLinqContract CreateLinqContract(Type objectType)
    {
      JsonLinqContract contract = new JsonLinqContract(objectType);
      InitializeContract(contract);

      return contract;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Creates a <see cref="JsonISerializableContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonISerializableContract"/> for the given type.</returns>
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
    {
      JsonISerializableContract contract = new JsonISerializableContract(objectType);
      InitializeContract(contract);

      ConstructorInfo constructorInfo = contract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new[] { typeof(SerializationInfo), typeof(StreamingContext) }, null);
      if (constructorInfo != null)
      {
        MethodCall<object, object> methodCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(constructorInfo);

        contract.ISerializableCreator = (args => methodCall(null, args));
      }

      return contract;
    }
#endif

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    /// <summary>
    /// Creates a <see cref="JsonDynamicContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonDynamicContract"/> for the given type.</returns>
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType)
    {
      JsonDynamicContract contract = new JsonDynamicContract(objectType);
      InitializeContract(contract);

      contract.PropertyNameResolver = ResolvePropertyName;
      contract.Properties.AddRange(CreateProperties(objectType, MemberSerialization.OptOut));

      return contract;
    }
#endif

    /// <summary>
    /// Creates a <see cref="JsonStringContract"/> for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonStringContract"/> for the given type.</returns>
    protected virtual JsonStringContract CreateStringContract(Type objectType)
    {
      JsonStringContract contract = new JsonStringContract(objectType);
      InitializeContract(contract);

      return contract;
    }

    /// <summary>
    /// Determines which contract type is created for the given type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>A <see cref="JsonContract"/> for the given type.</returns>
    protected virtual JsonContract CreateContract(Type objectType)
    {
      Type t = ReflectionUtils.EnsureNotNullableType(objectType);

      if (JsonConvert.IsJsonPrimitiveType(t))
        return CreatePrimitiveContract(objectType);

      if (JsonTypeReflector.GetJsonObjectAttribute(t) != null)
        return CreateObjectContract(objectType);

      if (JsonTypeReflector.GetJsonArrayAttribute(t) != null)
        return CreateArrayContract(objectType);

      if (JsonTypeReflector.GetJsonDictionaryAttribute(t) != null)
        return CreateDictionaryContract(objectType);

      if (t == typeof(JToken) || t.IsSubclassOf(typeof(JToken)))
        return CreateLinqContract(objectType);

      if (CollectionUtils.IsDictionaryType(t))
        return CreateDictionaryContract(objectType);

      if (typeof(IEnumerable).IsAssignableFrom(t))
        return CreateArrayContract(objectType);

      if (CanConvertToString(t))
        return CreateStringContract(objectType);

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (!IgnoreSerializableInterface && typeof(ISerializable).IsAssignableFrom(t))
        return CreateISerializableContract(objectType);
#endif

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
      if (typeof(IDynamicMetaObjectProvider).IsAssignableFrom(t))
        return CreateDynamicContract(objectType);
#endif

      return CreateObjectContract(objectType);
    }

    internal static bool CanConvertToString(Type type)
    {
#if !(NETFX_CORE || PORTABLE)
      TypeConverter converter = ConvertUtils.GetConverter(type);

      // use the objectType's TypeConverter if it has one and can convert to a string
      if (converter != null
#if !SILVERLIGHT
 && !(converter is ComponentConverter)
 && !(converter is ReferenceConverter)
#endif
 && converter.GetType() != typeof(TypeConverter))
      {
        if (converter.CanConvertTo(typeof(string)))
          return true;
      }
#endif

      if (type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
        return true;

#if SILVERLIGHT || PocketPC
      if (type == typeof(Guid) || type == typeof(Uri) || type == typeof(TimeSpan))
        return true;
#endif

      return false;
    }

    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, ref Type prevAttributeType)
    {
      if (!method.IsDefined(attributeType, false))
        return false;

      if (currentCallback != null)
        throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));

      if (prevAttributeType != null)
        throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));

      if (method.IsVirtual)
        throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));

      if (method.ReturnType != typeof(void))
        throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));

      if (attributeType == typeof(OnErrorAttribute))
      {
        if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext))
          throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
      }
      else
      {
        if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof(StreamingContext))
          throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
      }

      prevAttributeType = attributeType;

      return true;
    }

    internal static string GetClrTypeFullName(Type type)
    {
      if (type.IsGenericTypeDefinition() || !type.ContainsGenericParameters())
        return type.FullName;

      return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", new object[] { type.Namespace, type.Name });
    }

    /// <summary>
    /// Creates properties for the given <see cref="JsonContract"/>.
    /// </summary>
    /// <param name="type">The type to create properties for.</param>
    /// /// <param name="memberSerialization">The member serialization mode for the type.</param>
    /// <returns>Properties for the given <see cref="JsonContract"/>.</returns>
    protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
    {
      List<MemberInfo> members = GetSerializableMembers(type);
      if (members == null)
        throw new JsonSerializationException("Null collection of seralizable members returned.");

      JsonPropertyCollection properties = new JsonPropertyCollection(type);

      foreach (MemberInfo member in members)
      {
        JsonProperty property = CreateProperty(member, memberSerialization);

        if (property != null)
          properties.AddProperty(property);
      }

      IList<JsonProperty> orderedProperties = properties.OrderBy(p => p.Order ?? -1).ToList();
      return orderedProperties;
    }

    /// <summary>
    /// Creates the <see cref="IValueProvider"/> used by the serializer to get and set values from a member.
    /// </summary>
    /// <param name="member">The member.</param>
    /// <returns>The <see cref="IValueProvider"/> used by the serializer to get and set values from a member.</returns>
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
    {
      // warning - this method use to cause errors with Intellitrace. Retest in VS Ultimate after changes
      IValueProvider valueProvider;

#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)
      if (DynamicCodeGeneration)
        valueProvider = new DynamicValueProvider(member);
      else
        valueProvider = new ReflectionValueProvider(member);
#else
      valueProvider = new ReflectionValueProvider(member);
#endif

      return valueProvider;
    }

    /// <summary>
    /// Creates a <see cref="JsonProperty"/> for the given <see cref="MemberInfo"/>.
    /// </summary>
    /// <param name="memberSerialization">The member's parent <see cref="MemberSerialization"/>.</param>
    /// <param name="member">The member to create a <see cref="JsonProperty"/> for.</param>
    /// <returns>A created <see cref="JsonProperty"/> for the given <see cref="MemberInfo"/>.</returns>
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
    {
      JsonProperty property = new JsonProperty();
      property.PropertyType = ReflectionUtils.GetMemberUnderlyingType(member);
      property.DeclaringType = member.DeclaringType;
      property.ValueProvider = CreateMemberValueProvider(member);

      bool allowNonPublicAccess;
      SetPropertySettingsFromAttributes(property, member.GetCustomAttributeProvider(), member.Name, member.DeclaringType, memberSerialization, out allowNonPublicAccess);

      if (memberSerialization != MemberSerialization.Fields)
      {
        property.Readable = ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
        property.Writable = ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, property.HasMemberAttribute);
      }
      else
      {
        // write to readonly fields
        property.Readable = true;
        property.Writable = true;
      }
      property.ShouldSerialize = CreateShouldSerializeTest(member);

      SetIsSpecifiedActions(property, member, allowNonPublicAccess);

      return property;
    }

    private void SetPropertySettingsFromAttributes(JsonProperty property, ICustomAttributeProvider attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess)
    {
#if !PocketPC && !NET20
      DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(declaringType);

      MemberInfo memberInfo = null;
#if !(NETFX_CORE || PORTABLE)
      memberInfo = attributeProvider as MemberInfo;
#else
      memberInfo = attributeProvider.UnderlyingObject as MemberInfo;
#endif

      DataMemberAttribute dataMemberAttribute;
      if (dataContractAttribute != null && memberInfo != null)
        dataMemberAttribute = JsonTypeReflector.GetDataMemberAttribute((MemberInfo) memberInfo);
      else
        dataMemberAttribute = null;
#endif

      JsonPropertyAttribute propertyAttribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
      if (propertyAttribute != null)
        property.HasMemberAttribute = true;

      string mappedName;
      if (propertyAttribute != null && propertyAttribute.PropertyName != null)
        mappedName = propertyAttribute.PropertyName;
#if !PocketPC && !NET20
      else if (dataMemberAttribute != null && dataMemberAttribute.Name != null)
        mappedName = dataMemberAttribute.Name;
#endif
      else
        mappedName = name;

      property.PropertyName = ResolvePropertyName(mappedName);
      property.UnderlyingName = name;

      bool hasMemberAttribute = false;
      if (propertyAttribute != null)
      {
        property._required = propertyAttribute._required;
        property.Order = propertyAttribute._order;
        property.DefaultValueHandling = propertyAttribute._defaultValueHandling;
        hasMemberAttribute = true;
      }
#if !PocketPC && !NET20
      else if (dataMemberAttribute != null)
      {
        property._required = (dataMemberAttribute.IsRequired) ? Required.AllowNull : Required.Default;
        property.Order = (dataMemberAttribute.Order != -1) ? (int?) dataMemberAttribute.Order : null;
        property.DefaultValueHandling = (!dataMemberAttribute.EmitDefaultValue) ? (DefaultValueHandling?) DefaultValueHandling.Ignore : null;
        hasMemberAttribute = true;
      }
#endif

      bool hasJsonIgnoreAttribute =
        JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        || JsonTypeReflector.GetAttribute<NonSerializedAttribute>(attributeProvider) != null
#endif
        ;

      if (memberSerialization != MemberSerialization.OptIn)
      {
       bool hasIgnoreDataMemberAttribute = false;
        
#if !(NET20 || NET35)
        hasIgnoreDataMemberAttribute = (JsonTypeReflector.GetAttribute<IgnoreDataMemberAttribute>(attributeProvider) != null);
#endif

        // ignored if it has JsonIgnore or NonSerialized or IgnoreDataMember attributes
        property.Ignored = (hasJsonIgnoreAttribute || hasIgnoreDataMemberAttribute);
      }
      else
      {
        // ignored if it has JsonIgnore/NonSerialized or does not have DataMember or JsonProperty attributes
        property.Ignored = (hasJsonIgnoreAttribute || !hasMemberAttribute);
      }

      // resolve converter for property
      // the class type might have a converter but the property converter takes presidence
      property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider, property.PropertyType);
      property.MemberConverter = JsonTypeReflector.GetJsonConverter(attributeProvider, property.PropertyType);

      DefaultValueAttribute defaultValueAttribute = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
      if (defaultValueAttribute != null)
        property.DefaultValue = defaultValueAttribute.Value;

      property.NullValueHandling = (propertyAttribute != null) ? propertyAttribute._nullValueHandling : null;
      property.ReferenceLoopHandling = (propertyAttribute != null) ? propertyAttribute._referenceLoopHandling : null;
      property.ObjectCreationHandling = (propertyAttribute != null) ? propertyAttribute._objectCreationHandling : null;
      property.TypeNameHandling = (propertyAttribute != null) ? propertyAttribute._typeNameHandling : null;
      property.IsReference = (propertyAttribute != null) ? propertyAttribute._isReference : null;

      property.ItemIsReference = (propertyAttribute != null) ? propertyAttribute._itemIsReference : null;
      property.ItemConverter =
        (propertyAttribute != null && propertyAttribute.ItemConverterType != null)
          ? JsonConverterAttribute.CreateJsonConverterInstance(propertyAttribute.ItemConverterType)
          : null;
      property.ItemReferenceLoopHandling = (propertyAttribute != null) ? propertyAttribute._itemReferenceLoopHandling : null;
      property.ItemTypeNameHandling = (propertyAttribute != null) ? propertyAttribute._itemTypeNameHandling : null;

      allowNonPublicAccess = false;
      if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
        allowNonPublicAccess = true;
      if (propertyAttribute != null)
        allowNonPublicAccess = true;
      if (memberSerialization == MemberSerialization.Fields)
        allowNonPublicAccess = true;

#if !PocketPC && !NET20
      if (dataMemberAttribute != null)
      {
        allowNonPublicAccess = true;
        property.HasMemberAttribute = true;
      }
#endif
    }

    private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
    {
      MethodInfo shouldSerializeMethod = member.DeclaringType.GetMethod(JsonTypeReflector.ShouldSerializePrefix + member.Name, ReflectionUtils.EmptyTypes);

      if (shouldSerializeMethod == null || shouldSerializeMethod.ReturnType != typeof(bool))
        return null;

      MethodCall<object, object> shouldSerializeCall =
        JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(shouldSerializeMethod);

      return o => (bool)shouldSerializeCall(o);
    }

    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
    {
      MemberInfo specifiedMember = member.DeclaringType.GetProperty(member.Name + JsonTypeReflector.SpecifiedPostfix);
      if (specifiedMember == null)
        specifiedMember = member.DeclaringType.GetField(member.Name + JsonTypeReflector.SpecifiedPostfix);

      if (specifiedMember == null || ReflectionUtils.GetMemberUnderlyingType(specifiedMember) != typeof(bool))
      {
        return;
      }

      Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(specifiedMember);

      property.GetIsSpecified = o => (bool)specifiedPropertyGet(o);

      if (ReflectionUtils.CanSetMemberValue(specifiedMember, allowNonPublicAccess, false))
        property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(specifiedMember);
    }

    /// <summary>
    /// Resolves the name of the property.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <returns>Name of the property.</returns>
    protected internal virtual string ResolvePropertyName(string propertyName)
    {
      return propertyName;
    }

    /// <summary>
    /// Gets the resolved name of the property.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <returns>Name of the property.</returns>
    public string GetResolvedPropertyName(string propertyName)
    {
      // this is a new method rather than changing the visibility of ResolvePropertyName to avoid
      // a breaking change for anyone who has overidden the method
      return ResolvePropertyName(propertyName);
    }
  }
}
#endregion Serialization_DefaultContractResolver.cs

/// ********   File: \Serialization\DefaultReferenceResolver.cs
#region Serialization_DefaultReferenceResolver.cs

namespace Newtonsoft.Json.Serialization
{
  internal class DefaultReferenceResolver : IReferenceResolver
  {
    private int _referenceCount;

    private BidirectionalDictionary<string, object> GetMappings(object context)
    {
      JsonSerializerInternalBase internalSerializer;

      if (context is JsonSerializerInternalBase)
        internalSerializer = (JsonSerializerInternalBase) context;
      else if (context is JsonSerializerProxy)
        internalSerializer = ((JsonSerializerProxy) context).GetInternalSerializer();
      else
        throw new JsonException("The DefaultReferenceResolver can only be used internally.");

      return internalSerializer.DefaultReferenceMappings;
    }

    public object ResolveReference(object context, string reference)
    {
      object value;
      GetMappings(context).TryGetByFirst(reference, out value);
      return value;
    }

    public string GetReference(object context, object value)
    {
      var mappings = GetMappings(context);

      string reference;
      if (!mappings.TryGetBySecond(value, out reference))
      {
        _referenceCount++;
        reference = _referenceCount.ToString(CultureInfo.InvariantCulture);
        mappings.Set(reference, value);
      }

      return reference;
    }

    public void AddReference(object context, string reference, object value)
    {
      GetMappings(context).Set(reference, value);
    }

    public bool IsReferenced(object context, object value)
    {
      string reference;
      return GetMappings(context).TryGetBySecond(value, out reference);
    }
  }
}
#endregion Serialization_DefaultReferenceResolver.cs

/// ********   File: \Serialization\DefaultSerializationBinder.cs
#region Serialization_DefaultSerializationBinder.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// The default serialization binder used when resolving and loading classes from type names.
  /// </summary>
  public class DefaultSerializationBinder : SerializationBinder
  {
    internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

    private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache = new ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);

    private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
    {
      string assemblyName = typeNameKey.AssemblyName;
      string typeName = typeNameKey.TypeName;

      if (assemblyName != null)
      {
        Assembly assembly;

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        // look, I don't like using obsolete methods as much as you do but this is the only way
        // Assembly.Load won't check the GAC for a partial name
#pragma warning disable 618,612
        assembly = Assembly.LoadWithPartialName(assemblyName);
#pragma warning restore 618,612
#elif NETFX_CORE
        assembly = Assembly.Load(new AssemblyName(assemblyName));
#else
        assembly = Assembly.Load(assemblyName);
#endif

        if (assembly == null)
          throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture, assemblyName));

        Type type = assembly.GetType(typeName);
        if (type == null)
          throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));

        return type;
      }
      else
      {
        return Type.GetType(typeName);
      }
    }

    internal struct TypeNameKey : IEquatable<TypeNameKey>
    {
      internal readonly string AssemblyName;
      internal readonly string TypeName;

      public TypeNameKey(string assemblyName, string typeName)
      {
        AssemblyName = assemblyName;
        TypeName = typeName;
      }

      public override int GetHashCode()
      {
        return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
      }

      public override bool Equals(object obj)
      {
        if (!(obj is TypeNameKey))
          return false;

        return Equals((TypeNameKey)obj);
      }

      public bool Equals(TypeNameKey other)
      {
        return (AssemblyName == other.AssemblyName && TypeName == other.TypeName);
      }
    }

    /// <summary>
    /// When overridden in a derived class, controls the binding of a serialized object to a type.
    /// </summary>
    /// <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object.</param>
    /// <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object.</param>
    /// <returns>
    /// The type of the object the formatter creates a new instance of.
    /// </returns>
    public override Type BindToType(string assemblyName, string typeName)
    {
      return _typeCache.Get(new TypeNameKey(assemblyName, typeName));
    }

#if !(NET35 || NET20)
    /// <summary>
    /// When overridden in a derived class, controls the binding of a serialized object to a type.
    /// </summary>
    /// <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
    /// <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly"/> name of the serialized object. </param>
    /// <param name="typeName">Specifies the <see cref="T:System.Type"/> name of the serialized object. </param>
    public override void BindToName(Type serializedType, out string assemblyName, out string typeName)
    {
#if NETFX_CORE
      assemblyName = serializedType.GetTypeInfo().Assembly.FullName;
      typeName = serializedType.FullName;
#elif !SILVERLIGHT
      assemblyName = serializedType.Assembly.FullName;
      typeName = serializedType.FullName;
#else
      assemblyName = null;
      typeName = serializedType.AssemblyQualifiedName;
#endif
    }
#endif
  }
}
#endregion Serialization_DefaultSerializationBinder.cs

/// ********   File: \Serialization\DiagnosticsTraceWriter.cs
#region Serialization_DiagnosticsTraceWriter.cs
#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Represents a trace writer that writes to the application's <see cref="TraceListener"/> instances.
  /// </summary>
  public class DiagnosticsTraceWriter : ITraceWriter
  {
    /// <summary>
    /// Gets the <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.
    /// For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
    /// <code>Warning</code> and <code>Error</code> messages.
    /// </summary>
    /// <value>
    /// The <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.
    /// </value>
    public TraceLevel LevelFilter { get; set; }

    private TraceEventType GetTraceEventType(TraceLevel level)
    {
      switch (level)
      {
        case TraceLevel.Error:
          return TraceEventType.Error;
        case TraceLevel.Warning:
          return TraceEventType.Warning;
        case TraceLevel.Info:
          return TraceEventType.Information;
        case TraceLevel.Verbose:
          return TraceEventType.Verbose;
        default:
          throw new ArgumentOutOfRangeException("level");
      }
    }

    /// <summary>
    /// Writes the specified trace level, message and optional exception.
    /// </summary>
    /// <param name="level">The <see cref="TraceLevel"/> at which to write this trace.</param>
    /// <param name="message">The trace message.</param>
    /// <param name="ex">The trace exception. This parameter is optional.</param>
    public void Trace(TraceLevel level, string message, Exception ex)
    {
      if (level == TraceLevel.Off)
        return;

      TraceEventCache eventCache = new TraceEventCache();
      TraceEventType traceEventType = GetTraceEventType(level);

      foreach (TraceListener listener in DiagnosticsTrace.Listeners)
      {
        if (!listener.IsThreadSafe)
        {
          lock (listener)
          {
            listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
          }
        }
        else
        {
          listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
        }

        if (DiagnosticsTrace.AutoFlush)
          listener.Flush();
      }
    }
  }
}
#endif
#endregion Serialization_DiagnosticsTraceWriter.cs

/// ********   File: \Serialization\DynamicValueProvider.cs
#region Serialization_DynamicValueProvider.cs

#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)
#if NET20
#endif

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Get and set values for a <see cref="MemberInfo"/> using dynamic methods.
  /// </summary>
  public class DynamicValueProvider : IValueProvider
  {
    private readonly MemberInfo _memberInfo;
    private Func<object, object> _getter;
    private Action<object, object> _setter;

    /// <summary>
    /// Initializes a new instance of the <see cref="DynamicValueProvider"/> class.
    /// </summary>
    /// <param name="memberInfo">The member info.</param>
    public DynamicValueProvider(MemberInfo memberInfo)
    {
      ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
      _memberInfo = memberInfo;
    }

    /// <summary>
    /// Sets the value.
    /// </summary>
    /// <param name="target">The target to set the value on.</param>
    /// <param name="value">The value to set on the target.</param>
    public void SetValue(object target, object value)
    {
      try
      {
        if (_setter == null)
          _setter = DynamicReflectionDelegateFactory.Instance.CreateSet<object>(_memberInfo);

#if DEBUG
        // dynamic method doesn't check whether the type is 'legal' to set
        // add this check for unit tests
        if (value == null)
        {
          if (!ReflectionUtils.IsNullable(ReflectionUtils.GetMemberUnderlyingType(_memberInfo)))
            throw new JsonSerializationException("Incompatible value. Cannot set {0} to null.".FormatWith(CultureInfo.InvariantCulture, _memberInfo));
        }
        else if (!ReflectionUtils.GetMemberUnderlyingType(_memberInfo).IsAssignableFrom(value.GetType()))
        {
          throw new JsonSerializationException("Incompatible value. Cannot set {0} to type {1}.".FormatWith(CultureInfo.InvariantCulture, _memberInfo, value.GetType()));
        }
#endif

        _setter(target, value);
      }
      catch (Exception ex)
      {
        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), ex);
      }
    }

    /// <summary>
    /// Gets the value.
    /// </summary>
    /// <param name="target">The target to get the value from.</param>
    /// <returns>The value.</returns>
    public object GetValue(object target)
    {
      try
      {
        if (_getter == null)
          _getter = DynamicReflectionDelegateFactory.Instance.CreateGet<object>(_memberInfo);

        return _getter(target);
      }
      catch (Exception ex)
      {
        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), ex);
      }
    }
  }
}
#endif
#endregion Serialization_DynamicValueProvider.cs

/// ********   File: \Serialization\ErrorContext.cs
#region Serialization_ErrorContext.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Provides information surrounding an error.
  /// </summary>
  public class ErrorContext
  {
    internal ErrorContext(object originalObject, object member, string path, Exception error)
    {
      OriginalObject = originalObject;
      Member = member;
      Error = error;
      Path = path;
    }

    internal bool Traced { get; set; }

    /// <summary>
    /// Gets or sets the error.
    /// </summary>
    /// <value>The error.</value>
    public Exception Error { get; private set; }
    /// <summary>
    /// Gets the original object that caused the error.
    /// </summary>
    /// <value>The original object that caused the error.</value>
    public object OriginalObject { get; private set; }
    /// <summary>
    /// Gets the member that caused the error.
    /// </summary>
    /// <value>The member that caused the error.</value>
    public object Member { get; private set; }
    /// <summary>
    /// Gets the path of the JSON location where the error occurred.
    /// </summary>
    /// <value>The path of the JSON location where the error occurred.</value>
    public string Path { get; private set; }
    /// <summary>
    /// Gets or sets a value indicating whether this <see cref="ErrorContext"/> is handled.
    /// </summary>
    /// <value><c>true</c> if handled; otherwise, <c>false</c>.</value>
    public bool Handled { get; set; }
  }
}
#endregion Serialization_ErrorContext.cs

/// ********   File: \Serialization\ErrorEventArgs.cs
#region Serialization_ErrorEventArgs.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Provides data for the Error event.
  /// </summary>
  public class ErrorEventArgs : EventArgs
  {
    /// <summary>
    /// Gets the current object the error event is being raised against.
    /// </summary>
    /// <value>The current object the error event is being raised against.</value>
    public object CurrentObject { get; private set; }
    /// <summary>
    /// Gets the error context.
    /// </summary>
    /// <value>The error context.</value>
    public ErrorContext ErrorContext { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="ErrorEventArgs"/> class.
    /// </summary>
    /// <param name="currentObject">The current object.</param>
    /// <param name="errorContext">The error context.</param>
    public ErrorEventArgs(object currentObject, ErrorContext errorContext)
    {
      CurrentObject = currentObject;
      ErrorContext = errorContext;
    }
  }
}
#endregion Serialization_ErrorEventArgs.cs

/// ********   File: \Serialization\IContractResolver.cs
#region Serialization_IContractResolver.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Used by <see cref="JsonSerializer"/> to resolves a <see cref="JsonContract"/> for a given <see cref="Type"/>.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverObject" title="IContractResolver Class" />
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverExample" title="IContractResolver Example" />
  /// </example>
  public interface IContractResolver
  {
    /// <summary>
    /// Resolves the contract for a given type.
    /// </summary>
    /// <param name="type">The type to resolve a contract for.</param>
    /// <returns>The contract for a given type.</returns>
    JsonContract ResolveContract(Type type);
  }
}
#endregion Serialization_IContractResolver.cs

/// ********   File: \Serialization\IReferenceResolver.cs
#region Serialization_IReferenceResolver.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Used to resolve references when serializing and deserializing JSON by the <see cref="JsonSerializer"/>.
  /// </summary>
  public interface IReferenceResolver
  {
    /// <summary>
    /// Resolves a reference to its object.
    /// </summary>
    /// <param name="context">The serialization context.</param>
    /// <param name="reference">The reference to resolve.</param>
    /// <returns>The object that</returns>
    object ResolveReference(object context, string reference);
    /// <summary>
    /// Gets the reference for the sepecified object.
    /// </summary>
    /// <param name="context">The serialization context.</param>
    /// <param name="value">The object to get a reference for.</param>
    /// <returns>The reference to the object.</returns>
    string GetReference(object context, object value);
    /// <summary>
    /// Determines whether the specified object is referenced.
    /// </summary>
    /// <param name="context">The serialization context.</param>
    /// <param name="value">The object to test for a reference.</param>
    /// <returns>
    /// 	<c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
    /// </returns>
    bool IsReferenced(object context, object value);
    /// <summary>
    /// Adds a reference to the specified object.
    /// </summary>
    /// <param name="context">The serialization context.</param>
    /// <param name="reference">The reference.</param>
    /// <param name="value">The object to reference.</param>
    void AddReference(object context, string reference, object value);
  }
}
#endregion Serialization_IReferenceResolver.cs

/// ********   File: \Serialization\ITraceWriter.cs
#region Serialization_ITraceWriter.cs
namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Represents a trace writer.
  /// </summary>
  public interface ITraceWriter
  {
    /// <summary>
    /// Gets the <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.
    /// For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
    /// <code>Warning</code> and <code>Error</code> messages.
    /// </summary>
    /// <value>The <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.</value>
    TraceLevel LevelFilter { get; }

    /// <summary>
    /// Writes the specified trace level, message and optional exception.
    /// </summary>
    /// <param name="level">The <see cref="TraceLevel"/> at which to write this trace.</param>
    /// <param name="message">The trace message.</param>
    /// <param name="ex">The trace exception. This parameter is optional.</param>
    void Trace(TraceLevel level, string message, Exception ex);
  }
}
#endregion Serialization_ITraceWriter.cs

/// ********   File: \Serialization\IValueProvider.cs
#region Serialization_IValueProvider.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Provides methods to get and set values.
  /// </summary>
  public interface IValueProvider
  {
    /// <summary>
    /// Sets the value.
    /// </summary>
    /// <param name="target">The target to set the value on.</param>
    /// <param name="value">The value to set on the target.</param>
    void SetValue(object target, object value);

    /// <summary>
    /// Gets the value.
    /// </summary>
    /// <param name="target">The target to get the value from.</param>
    /// <returns>The value.</returns>
    object GetValue(object target);
  }
}
#endregion Serialization_IValueProvider.cs

/// ********   File: \Serialization\JsonArrayContract.cs
#region Serialization_JsonArrayContract.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonArrayContract : JsonContainerContract
  {
    /// <summary>
    /// Gets the <see cref="Type"/> of the collection items.
    /// </summary>
    /// <value>The <see cref="Type"/> of the collection items.</value>
    public Type CollectionItemType { get; private set; }

    /// <summary>
    /// Gets a value indicating whether the collection type is a multidimensional array.
    /// </summary>
    /// <value><c>true</c> if the collection type is a multidimensional array; otherwise, <c>false</c>.</value>
    public bool IsMultidimensionalArray { get; private set; }

    private readonly bool _isCollectionItemTypeNullableType;
    private readonly Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall<object, object> _genericWrapperCreator;

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonArrayContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonArrayContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Array;
      
      if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
      {
        CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
      }
      else if (underlyingType.IsGenericType() && underlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
      {
        _genericCollectionDefinitionType =  typeof (IEnumerable<>);
        CollectionItemType = underlyingType.GetGenericArguments()[0];
      }
      else
      {
        CollectionItemType = ReflectionUtils.GetCollectionItemType(UnderlyingType);
      }

      if (CollectionItemType != null)
        _isCollectionItemTypeNullableType = ReflectionUtils.IsNullableType(CollectionItemType);

      if (IsTypeGenericCollectionInterface(UnderlyingType))
        CreatedType = ReflectionUtils.MakeGenericType(typeof(List<>), CollectionItemType);
#if !(PORTABLE || NET20 || NET35 || WINDOWS_PHONE)
      else if (IsTypeGenericSetnterface(UnderlyingType))
        CreatedType = ReflectionUtils.MakeGenericType(typeof(HashSet<>), CollectionItemType);
#endif

      IsMultidimensionalArray = (UnderlyingType.IsArray && UnderlyingType.GetArrayRank() > 1);
    }

    internal IWrappedCollection CreateWrapper(object list)
    {
      if ((list is IList && (CollectionItemType == null || !_isCollectionItemTypeNullableType))
        || UnderlyingType.IsArray)
        return new CollectionWrapper<object>((IList)list);

      if (_genericCollectionDefinitionType != null)
      {
        EnsureGenericWrapperCreator();
        return (IWrappedCollection) _genericWrapperCreator(null, list);
      }
      else
      {
        IList values = ((IEnumerable) list).Cast<object>().ToList();

        if (CollectionItemType != null)
        {
          Array array = Array.CreateInstance(CollectionItemType, values.Count);
          for (int i = 0; i < values.Count; i++)
          {
            array.SetValue(values[i], i);
          }

          values = array;
        }

        return new CollectionWrapper<object>(values);
      }
    }

    private void EnsureGenericWrapperCreator()
    {
      if (_genericWrapperCreator == null)
      {
        _genericWrapperType = ReflectionUtils.MakeGenericType(typeof (CollectionWrapper<>), CollectionItemType);

        Type constructorArgument;

        if (ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>))
          || _genericCollectionDefinitionType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
          constructorArgument = ReflectionUtils.MakeGenericType(typeof(ICollection<>), CollectionItemType);
        else
          constructorArgument = _genericCollectionDefinitionType;

        ConstructorInfo genericWrapperConstructor = _genericWrapperType.GetConstructor(new[] { constructorArgument });
        _genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(genericWrapperConstructor);
      }
    }

    private bool IsTypeGenericCollectionInterface(Type type)
    {
      if (!type.IsGenericType())
        return false;

      Type genericDefinition = type.GetGenericTypeDefinition();

      return (genericDefinition == typeof(IList<>)
              || genericDefinition == typeof(ICollection<>)
              || genericDefinition == typeof(IEnumerable<>));
    }

#if !(PORTABLE || NET20 || NET35 || WINDOWS_PHONE)
    private bool IsTypeGenericSetnterface(Type type)
    {
      if (!type.IsGenericType())
        return false;

      Type genericDefinition = type.GetGenericTypeDefinition();

      return (genericDefinition == typeof(ISet<>));
    }
#endif
  }
}
#endregion Serialization_JsonArrayContract.cs

/// ********   File: \Serialization\JsonContainerContract.cs
#region Serialization_JsonContainerContract.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonContainerContract : JsonContract
  {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;

    // will be null for containers that don't have an item type (e.g. IList) or for complex objects
    internal JsonContract ItemContract
    {
      get { return _itemContract; }
      set
      {
        _itemContract = value;
        if (_itemContract != null)
        {
          _finalItemContract = (_itemContract.UnderlyingType.IsSealed()) ? _itemContract : null;
        }
        else
        {
          _finalItemContract = null;
        }
      }
    }

    // the final (i.e. can't be inherited from like a sealed class or valuetype) item contract
    internal JsonContract FinalItemContract
    {
      get { return _finalItemContract; }
    }

    /// <summary>
    /// Gets or sets the default collection items <see cref="JsonConverter" />.
    /// </summary>
    /// <value>The converter.</value>
    public JsonConverter ItemConverter { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether the collection items preserve object references.
    /// </summary>
    /// <value><c>true</c> if collection items preserve object references; otherwise, <c>false</c>.</value>
    public bool? ItemIsReference { get; set; }

    /// <summary>
    /// Gets or sets the collection item reference loop handling.
    /// </summary>
    /// <value>The reference loop handling.</value>
    public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

    /// <summary>
    /// Gets or sets the collection item type name handling.
    /// </summary>
    /// <value>The type name handling.</value>
    public TypeNameHandling? ItemTypeNameHandling { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonContainerContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    internal JsonContainerContract(Type underlyingType)
      : base(underlyingType)
    {
      JsonContainerAttribute jsonContainerAttribute = JsonTypeReflector.GetJsonContainerAttribute(underlyingType);

      if (jsonContainerAttribute != null)
      {
        if (jsonContainerAttribute.ItemConverterType != null)
          ItemConverter = JsonConverterAttribute.CreateJsonConverterInstance(jsonContainerAttribute.ItemConverterType);

        ItemIsReference = jsonContainerAttribute._itemIsReference;
        ItemReferenceLoopHandling = jsonContainerAttribute._itemReferenceLoopHandling;
        ItemTypeNameHandling = jsonContainerAttribute._itemTypeNameHandling;
      }
    }
  }
}
#endregion Serialization_JsonContainerContract.cs

/// ********   File: \Serialization\JsonContract.cs
#region Serialization_JsonContract.cs

#if NETFX_CORE
#endif

namespace Newtonsoft.Json.Serialization
{
  internal enum JsonContractType
  {
    None,
    Object,
    Array,
    Primitive,
    String,
    Dictionary,
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    Dynamic,
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    Serializable,
#endif
    Linq
  }

  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public abstract class JsonContract
  {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;

    /// <summary>
    /// Gets the underlying type for the contract.
    /// </summary>
    /// <value>The underlying type for the contract.</value>
    public Type UnderlyingType { get; private set; }

    /// <summary>
    /// Gets or sets the type created during deserialization.
    /// </summary>
    /// <value>The type created during deserialization.</value>
    public Type CreatedType { get; set; }

    /// <summary>
    /// Gets or sets whether this type contract is serialized as a reference.
    /// </summary>
    /// <value>Whether this type contract is serialized as a reference.</value>
    public bool? IsReference { get; set; }

    /// <summary>
    /// Gets or sets the default <see cref="JsonConverter" /> for this contract.
    /// </summary>
    /// <value>The converter.</value>
    public JsonConverter Converter { get; set; }

    // internally specified JsonConverter's to override default behavour
    // checked for after passed in converters and attribute specified converters
    internal JsonConverter InternalConverter { get; set; }

#if !PocketPC
    /// <summary>
    /// Gets or sets the method called immediately after deserialization of the object.
    /// </summary>
    /// <value>The method called immediately after deserialization of the object.</value>
    public MethodInfo OnDeserialized { get; set; }

    /// <summary>
    /// Gets or sets the method called during deserialization of the object.
    /// </summary>
    /// <value>The method called during deserialization of the object.</value>
    public MethodInfo OnDeserializing { get; set; }

    /// <summary>
    /// Gets or sets the method called after serialization of the object graph.
    /// </summary>
    /// <value>The method called after serialization of the object graph.</value>
    public MethodInfo OnSerialized { get; set; }

    /// <summary>
    /// Gets or sets the method called before serialization of the object.
    /// </summary>
    /// <value>The method called before serialization of the object.</value>
    public MethodInfo OnSerializing { get; set; }
#endif

    /// <summary>
    /// Gets or sets the default creator method used to create the object.
    /// </summary>
    /// <value>The default creator method used to create the object.</value>
    public Func<object> DefaultCreator { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether the default creator is non public.
    /// </summary>
    /// <value><c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
    public bool DefaultCreatorNonPublic { get; set; }

    /// <summary>
    /// Gets or sets the method called when an error is thrown during the serialization of the object.
    /// </summary>
    /// <value>The method called when an error is thrown during the serialization of the object.</value>
    public MethodInfo OnError { get; set; }

    internal void InvokeOnSerializing(object o, StreamingContext context)
    {
#if !PocketPC
      if (OnSerializing != null)
        OnSerializing.Invoke(o, new object[] {context});
#endif
    }

    internal void InvokeOnSerialized(object o, StreamingContext context)
    {
#if !PocketPC
      if (OnSerialized != null)
        OnSerialized.Invoke(o, new object[] {context});
#endif
    }

    internal void InvokeOnDeserializing(object o, StreamingContext context)
    {
#if !PocketPC
      if (OnDeserializing != null)
        OnDeserializing.Invoke(o, new object[] {context});
#endif
    }

    internal void InvokeOnDeserialized(object o, StreamingContext context)
    {
#if !PocketPC
      if (OnDeserialized != null)
        OnDeserialized.Invoke(o, new object[] {context});
#endif
    }

    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
    {
      if (OnError != null)
        OnError.Invoke(o, new object[] {context, errorContext});
    }

    internal JsonContract(Type underlyingType)
    {
      ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");

      UnderlyingType = underlyingType;

      IsNullable = ReflectionUtils.IsNullable(underlyingType);
      NonNullableUnderlyingType = (IsNullable && ReflectionUtils.IsNullableType(underlyingType)) ? Nullable.GetUnderlyingType(underlyingType) : underlyingType;

      CreatedType = NonNullableUnderlyingType;

      IsConvertable = ConvertUtils.IsConvertible(NonNullableUnderlyingType);

      if (NonNullableUnderlyingType == typeof(byte[]))
      {
        InternalReadType = ReadType.ReadAsBytes;
      }
      else if (NonNullableUnderlyingType == typeof(int))
      {
        InternalReadType = ReadType.ReadAsInt32;
      }
      else if (NonNullableUnderlyingType == typeof(decimal))
      {
        InternalReadType = ReadType.ReadAsDecimal;
      }
      else if (NonNullableUnderlyingType == typeof(string))
      {
        InternalReadType = ReadType.ReadAsString;
      }
      else if (NonNullableUnderlyingType == typeof(DateTime))
      {
        InternalReadType = ReadType.ReadAsDateTime;
      }
#if !NET20
      else if (NonNullableUnderlyingType == typeof(DateTimeOffset))
      {
        InternalReadType = ReadType.ReadAsDateTimeOffset;
      }
#endif
      else
      {
        InternalReadType = ReadType.Read;
      }
    }
  }
}
#endregion Serialization_JsonContract.cs

/// ********   File: \Serialization\JsonDictionaryContract.cs
#region Serialization_JsonDictionaryContract.cs

#if NET20
#endif

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonDictionaryContract : JsonContainerContract
  {
    /// <summary>
    /// Gets or sets the property name resolver.
    /// </summary>
    /// <value>The property name resolver.</value>
    public Func<string, string> PropertyNameResolver { get; set; }

    /// <summary>
    /// Gets the <see cref="Type"/> of the dictionary keys.
    /// </summary>
    /// <value>The <see cref="Type"/> of the dictionary keys.</value>
    public Type DictionaryKeyType { get; private set; }
    /// <summary>
    /// Gets the <see cref="Type"/> of the dictionary values.
    /// </summary>
    /// <value>The <see cref="Type"/> of the dictionary values.</value>
    public Type DictionaryValueType { get; private set; }

    internal JsonContract KeyContract { get; set; }

    private readonly bool _isDictionaryValueTypeNullableType;
    private readonly Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall<object, object> _genericWrapperCreator;

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonDictionaryContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonDictionaryContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Dictionary;

      Type keyType;
      Type valueType;
      if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IDictionary<,>), out _genericCollectionDefinitionType))
      {
        keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
        valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
      }
      else
      {
        ReflectionUtils.GetDictionaryKeyValueTypes(UnderlyingType, out keyType, out valueType);
      }

      DictionaryKeyType = keyType;
      DictionaryValueType = valueType;

      if (DictionaryValueType != null)
        _isDictionaryValueTypeNullableType = ReflectionUtils.IsNullableType(DictionaryValueType);
      
      if (IsTypeGenericDictionaryInterface(UnderlyingType))
      {
        CreatedType = ReflectionUtils.MakeGenericType(typeof(Dictionary<,>), keyType, valueType);
      }
      else if (UnderlyingType == typeof(IDictionary))
      {
        CreatedType = typeof (Dictionary<object, object>);
      }
    }

    internal IWrappedDictionary CreateWrapper(object dictionary)
    {
      if (dictionary is IDictionary && (DictionaryValueType == null || !_isDictionaryValueTypeNullableType))
        return new DictionaryWrapper<object, object>((IDictionary)dictionary);

      if (_genericWrapperCreator == null)
      {
        _genericWrapperType = ReflectionUtils.MakeGenericType(typeof(DictionaryWrapper<,>), DictionaryKeyType, DictionaryValueType);

        ConstructorInfo genericWrapperConstructor = _genericWrapperType.GetConstructor(new[] { _genericCollectionDefinitionType });
        _genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(genericWrapperConstructor);
      }

      return (IWrappedDictionary)_genericWrapperCreator(null, dictionary);
    }

    private bool IsTypeGenericDictionaryInterface(Type type)
    {
      if (!type.IsGenericType())
        return false;

      Type genericDefinition = type.GetGenericTypeDefinition();

      return (genericDefinition == typeof(IDictionary<,>));
    }
  }
}
#endregion Serialization_JsonDictionaryContract.cs

/// ********   File: \Serialization\JsonDynamicContract.cs
#region Serialization_JsonDynamicContract.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonDynamicContract : JsonContainerContract
  {
    /// <summary>
    /// Gets the object's properties.
    /// </summary>
    /// <value>The object's properties.</value>
    public JsonPropertyCollection Properties { get; private set; }

    /// <summary>
    /// Gets or sets the property name resolver.
    /// </summary>
    /// <value>The property name resolver.</value>
    public Func<string, string> PropertyNameResolver { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonDynamicContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonDynamicContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Dynamic;

      Properties = new JsonPropertyCollection(UnderlyingType);
    }
  }
}
#endif
#endregion Serialization_JsonDynamicContract.cs

/// ********   File: \Serialization\JsonFormatterConverter.cs
#region Serialization_JsonFormatterConverter.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Serialization
{
  internal class JsonFormatterConverter : IFormatterConverter
  {
    private readonly JsonSerializer _serializer;

    public JsonFormatterConverter(JsonSerializer serializer)
    {
      ValidationUtils.ArgumentNotNull(serializer, "serializer");

      _serializer = serializer;
    }

    private T GetTokenValue<T>(object value)
    {
      ValidationUtils.ArgumentNotNull(value, "value");
      
      JValue v = (JValue)value;
      return (T)System.Convert.ChangeType(v.Value, typeof(T), CultureInfo.InvariantCulture);
    }

    public object Convert(object value, Type type)
    {
      ValidationUtils.ArgumentNotNull(value, "value");

      JToken token = value as JToken;
      if (token == null)
        throw new ArgumentException("Value is not a JToken.", "value");

      return _serializer.Deserialize(token.CreateReader(), type);
    }

    public object Convert(object value, TypeCode typeCode)
    {
      ValidationUtils.ArgumentNotNull(value, "value");

      if (value is JValue)
        value = ((JValue) value).Value;

      return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
    }

    public bool ToBoolean(object value)
    {
      return GetTokenValue<bool>(value);
    }

    public byte ToByte(object value)
    {
      return GetTokenValue<byte>(value);
    }

    public char ToChar(object value)
    {
      return GetTokenValue<char>(value);
    }

    public DateTime ToDateTime(object value)
    {
      return GetTokenValue<DateTime>(value);
    }

    public decimal ToDecimal(object value)
    {
      return GetTokenValue<decimal>(value);
    }

    public double ToDouble(object value)
    {
      return GetTokenValue<double>(value);
    }

    public short ToInt16(object value)
    {
      return GetTokenValue<short>(value);
    }

    public int ToInt32(object value)
    {
      return GetTokenValue<int>(value);
    }

    public long ToInt64(object value)
    {
      return GetTokenValue<long>(value);
    }

    public sbyte ToSByte(object value)
    {
      return GetTokenValue<sbyte>(value);
    }

    public float ToSingle(object value)
    {
      return GetTokenValue<float>(value);
    }

    public string ToString(object value)
    {
      return GetTokenValue<string>(value);
    }

    public ushort ToUInt16(object value)
    {
      return GetTokenValue<ushort>(value);
    }

    public uint ToUInt32(object value)
    {
      return GetTokenValue<uint>(value);
    }

    public ulong ToUInt64(object value)
    {
      return GetTokenValue<ulong>(value);
    }
  }
}
#endif
#endregion Serialization_JsonFormatterConverter.cs

/// ********   File: \Serialization\JsonISerializableContract.cs
#region Serialization_JsonISerializableContract.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonISerializableContract : JsonContainerContract
  {
    /// <summary>
    /// Gets or sets the ISerializable object constructor.
    /// </summary>
    /// <value>The ISerializable object constructor.</value>
    public ObjectConstructor<object> ISerializableCreator { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonISerializableContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonISerializableContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Serializable;
    }
  }
}
#endif
#endregion Serialization_JsonISerializableContract.cs

/// ********   File: \Serialization\JsonLinqContract.cs
#region Serialization_JsonLinqContract.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonLinqContract : JsonContract
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonLinqContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonLinqContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Linq;
    }
  }
}
#endregion Serialization_JsonLinqContract.cs

/// ********   File: \Serialization\JsonObjectContract.cs
#region Serialization_JsonObjectContract.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonObjectContract : JsonContainerContract
  {
    /// <summary>
    /// Gets or sets the object member serialization.
    /// </summary>
    /// <value>The member object serialization.</value>
    public MemberSerialization MemberSerialization { get; set; }

    /// <summary>
    /// Gets or sets a value that indicates whether the object's properties are required.
    /// </summary>
    /// <value>
    /// 	A value indicating whether the object's properties are required.
    /// </value>
    public Required? ItemRequired { get; set; }

    /// <summary>
    /// Gets the object's properties.
    /// </summary>
    /// <value>The object's properties.</value>
    public JsonPropertyCollection Properties { get; private set; }

    /// <summary>
    /// Gets the constructor parameters required for any non-default constructor
    /// </summary>
    public JsonPropertyCollection ConstructorParameters { get; private set; }

    /// <summary>
    /// Gets or sets the override constructor used to create the object.
    /// This is set when a constructor is marked up using the
    /// JsonConstructor attribute.
    /// </summary>
    /// <value>The override constructor.</value>
    public ConstructorInfo OverrideConstructor { get; set; }

    /// <summary>
    /// Gets or sets the parametrized constructor used to create the object.
    /// </summary>
    /// <value>The parametrized constructor.</value>
    public ConstructorInfo ParametrizedConstructor { get; set; }

    private bool? _hasRequiredOrDefaultValueProperties;
    internal bool HasRequiredOrDefaultValueProperties
    {
      get
      {
        if (_hasRequiredOrDefaultValueProperties == null)
        {
          _hasRequiredOrDefaultValueProperties = false;

          if (ItemRequired.GetValueOrDefault(Required.Default) != Required.Default)
          {
            _hasRequiredOrDefaultValueProperties = true;
          }
          else
          {
            foreach (JsonProperty property in Properties)
            {
              if (property.Required != Required.Default || ((property.DefaultValueHandling & DefaultValueHandling.Populate) == DefaultValueHandling.Populate) && property.Writable)
              {
                _hasRequiredOrDefaultValueProperties = true;
                break;
              }
            }
          }
        }

        return _hasRequiredOrDefaultValueProperties.Value;
      }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonObjectContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonObjectContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Object;

      Properties = new JsonPropertyCollection(UnderlyingType);
      ConstructorParameters = new JsonPropertyCollection(UnderlyingType);
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
#if !(NET20 || NET35)
    [SecuritySafeCritical]
#endif
    internal object GetUninitializedObject()
    {
      // we should never get here if the environment is not fully trusted, check just in case
      if (!JsonTypeReflector.FullyTrusted)
        throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture, NonNullableUnderlyingType));

      return FormatterServices.GetUninitializedObject(NonNullableUnderlyingType);
    }
#endif
  }
}
#endregion Serialization_JsonObjectContract.cs

/// ********   File: \Serialization\JsonPrimitiveContract.cs
#region Serialization_JsonPrimitiveContract.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonPrimitiveContract : JsonContract
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonPrimitiveContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonPrimitiveContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.Primitive;
    }
  }
}
#endregion Serialization_JsonPrimitiveContract.cs

/// ********   File: \Serialization\JsonProperty.cs
#region Serialization_JsonProperty.cs

#if NET20
#endif

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Maps a JSON property to a .NET member or constructor parameter.
  /// </summary>
  public class JsonProperty
  {
    internal Required? _required;
    internal bool _hasExplicitDefaultValue;
    internal object _defaultValue;

    // use to cache contract during deserialization
    internal JsonContract PropertyContract { get; set; }
    
    /// <summary>
    /// Gets or sets the name of the property.
    /// </summary>
    /// <value>The name of the property.</value>
    public string PropertyName { get; set; }

    /// <summary>
    /// Gets or sets the type that declared this property.
    /// </summary>
    /// <value>The type that declared this property.</value>
    public Type DeclaringType { get; set; }

    /// <summary>
    /// Gets or sets the order of serialization and deserialization of a member.
    /// </summary>
    /// <value>The numeric order of serialization or deserialization.</value>
    public int? Order { get; set; }

    /// <summary>
    /// Gets or sets the name of the underlying member or parameter.
    /// </summary>
    /// <value>The name of the underlying member or parameter.</value>
    public string UnderlyingName { get; set; }

    /// <summary>
    /// Gets the <see cref="IValueProvider"/> that will get and set the <see cref="JsonProperty"/> during serialization.
    /// </summary>
    /// <value>The <see cref="IValueProvider"/> that will get and set the <see cref="JsonProperty"/> during serialization.</value>
    public IValueProvider ValueProvider { get; set; }

    /// <summary>
    /// Gets or sets the type of the property.
    /// </summary>
    /// <value>The type of the property.</value>
    public Type PropertyType { get; set; }

    /// <summary>
    /// Gets or sets the <see cref="JsonConverter" /> for the property.
    /// If set this converter takes presidence over the contract converter for the property type.
    /// </summary>
    /// <value>The converter.</value>
    public JsonConverter Converter { get; set; }

    /// <summary>
    /// Gets the member converter.
    /// </summary>
    /// <value>The member converter.</value>
    public JsonConverter MemberConverter { get; set; }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonProperty"/> is ignored.
    /// </summary>
    /// <value><c>true</c> if ignored; otherwise, <c>false</c>.</value>
    public bool Ignored { get; set; }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonProperty"/> is readable.
    /// </summary>
    /// <value><c>true</c> if readable; otherwise, <c>false</c>.</value>
    public bool Readable { get; set; }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonProperty"/> is writable.
    /// </summary>
    /// <value><c>true</c> if writable; otherwise, <c>false</c>.</value>
    public bool Writable { get; set; }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonProperty"/> has a member attribute.
    /// </summary>
    /// <value><c>true</c> if has a member attribute; otherwise, <c>false</c>.</value>
    public bool HasMemberAttribute { get; set; }

    /// <summary>
    /// Gets the default value.
    /// </summary>
    /// <value>The default value.</value>
    public object DefaultValue
    {
      get
      {
        return _defaultValue;
      }
      set
      {
        _hasExplicitDefaultValue = true;
        _defaultValue = value;
      }
    }

    internal object GetResolvedDefaultValue()
    {
      if (!_hasExplicitDefaultValue && PropertyType != null)
        return ReflectionUtils.GetDefaultValue(PropertyType);

      return _defaultValue;
    }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonProperty"/> is required.
    /// </summary>
    /// <value>A value indicating whether this <see cref="JsonProperty"/> is required.</value>
    public Required Required
    {
      get { return _required ?? Required.Default; }
      set { _required = value; }
    }

    /// <summary>
    /// Gets a value indicating whether this property preserves object references.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if this instance is reference; otherwise, <c>false</c>.
    /// </value>
    public bool? IsReference { get; set; }

    /// <summary>
    /// Gets the property null value handling.
    /// </summary>
    /// <value>The null value handling.</value>
    public NullValueHandling? NullValueHandling { get; set; }

    /// <summary>
    /// Gets the property default value handling.
    /// </summary>
    /// <value>The default value handling.</value>
    public DefaultValueHandling? DefaultValueHandling { get; set; }

    /// <summary>
    /// Gets the property reference loop handling.
    /// </summary>
    /// <value>The reference loop handling.</value>
    public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

    /// <summary>
    /// Gets the property object creation handling.
    /// </summary>
    /// <value>The object creation handling.</value>
    public ObjectCreationHandling? ObjectCreationHandling { get; set; }

    /// <summary>
    /// Gets or sets the type name handling.
    /// </summary>
    /// <value>The type name handling.</value>
    public TypeNameHandling? TypeNameHandling { get; set; }

    /// <summary>
    /// Gets or sets a predicate used to determine whether the property should be serialize.
    /// </summary>
    /// <value>A predicate used to determine whether the property should be serialize.</value>
    public Predicate<object> ShouldSerialize { get; set; }

    /// <summary>
    /// Gets or sets a predicate used to determine whether the property should be serialized.
    /// </summary>
    /// <value>A predicate used to determine whether the property should be serialized.</value>
    public Predicate<object> GetIsSpecified { get; set; }

    /// <summary>
    /// Gets or sets an action used to set whether the property has been deserialized.
    /// </summary>
    /// <value>An action used to set whether the property has been deserialized.</value>
    public Action<object, object> SetIsSpecified { get; set; }

    /// <summary>
    /// Returns a <see cref="String"/> that represents this instance.
    /// </summary>
    /// <returns>
    /// A <see cref="String"/> that represents this instance.
    /// </returns>
    public override string ToString()
    {
      return PropertyName;
    }

    /// <summary>
    /// Gets or sets the converter used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items converter.</value>
    public JsonConverter ItemConverter { get; set; }

    /// <summary>
    /// Gets or sets whether this property's collection items are serialized as a reference.
    /// </summary>
    /// <value>Whether this property's collection items are serialized as a reference.</value>
    public bool? ItemIsReference { get; set; }

    /// <summary>
    /// Gets or sets the the type name handling used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items type name handling.</value>
    public TypeNameHandling? ItemTypeNameHandling { get; set; }

    /// <summary>
    /// Gets or sets the the reference loop handling used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items reference loop handling.</value>
    public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }
  }
}
#endregion Serialization_JsonProperty.cs

/// ********   File: \Serialization\JsonPropertyCollection.cs
#region Serialization_JsonPropertyCollection.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// A collection of <see cref="JsonProperty"/> objects.
  /// </summary>
  public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
  {
    private readonly Type _type;

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonPropertyCollection"/> class.
    /// </summary>
    /// <param name="type">The type.</param>
    public JsonPropertyCollection(Type type)
      : base(StringComparer.Ordinal)
    {
      ValidationUtils.ArgumentNotNull(type, "type");
      _type = type;
    }

    /// <summary>
    /// When implemented in a derived class, extracts the key from the specified element.
    /// </summary>
    /// <param name="item">The element from which to extract the key.</param>
    /// <returns>The key for the specified element.</returns>
    protected override string GetKeyForItem(JsonProperty item)
    {
      return item.PropertyName;
    }

    /// <summary>
    /// Adds a <see cref="JsonProperty"/> object.
    /// </summary>
    /// <param name="property">The property to add to the collection.</param>
    public void AddProperty(JsonProperty property)
    {
      if (Contains(property.PropertyName))
      {
        // don't overwrite existing property with ignored property
        if (property.Ignored)
          return;

        JsonProperty existingProperty = this[property.PropertyName];
        bool duplicateProperty = true;

        if (existingProperty.Ignored)
        {
          // remove ignored property so it can be replaced in collection
          Remove(existingProperty);
          duplicateProperty = false;
        }

        if (property.DeclaringType != null && existingProperty.DeclaringType != null)
        {
          if (property.DeclaringType.IsSubclassOf(existingProperty.DeclaringType))
          {
            // current property is on a derived class and hides the existing
            Remove(existingProperty);
            duplicateProperty = false;
          }
          if (existingProperty.DeclaringType.IsSubclassOf(property.DeclaringType))
          {
            // current property is hidden by the existing so don't add it
            return;
          }
        }

        if (duplicateProperty)
          throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, _type));
      }

      Add(property);
    }

    /// <summary>
    /// Gets the closest matching <see cref="JsonProperty"/> object.
    /// First attempts to get an exact case match of propertyName and then
    /// a case insensitive match.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    /// <returns>A matching property if found.</returns>
    public JsonProperty GetClosestMatchProperty(string propertyName)
    {
      JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
      if (property == null)
        property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);

      return property;
    }

    private bool TryGetValue(string key, out JsonProperty item)
    {
      if (Dictionary == null)
      {
        item = default(JsonProperty);
        return false;
      }

      return Dictionary.TryGetValue(key, out item);
    }

    /// <summary>
    /// Gets a property by property name.
    /// </summary>
    /// <param name="propertyName">The name of the property to get.</param>
    /// <param name="comparisonType">Type property name string comparison.</param>
    /// <returns>A matching property if found.</returns>
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
    {
      // KeyedCollection has an ordinal comparer
      if (comparisonType == StringComparison.Ordinal)
      {
        JsonProperty property;
        if (TryGetValue(propertyName, out property))
          return property;

        return null;
      }

      foreach (JsonProperty property in this)
      {
        if (string.Equals(propertyName, property.PropertyName, comparisonType))
        {
          return property;
        }
      }

      return null;
    }
  }
}
#endregion Serialization_JsonPropertyCollection.cs

/// ********   File: \Serialization\JsonSerializerInternalBase.cs
#region Serialization_JsonSerializerInternalBase.cs

namespace Newtonsoft.Json.Serialization
{
  internal abstract class JsonSerializerInternalBase
  {
    private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
    {
      bool IEqualityComparer<object>.Equals(object x, object y)
      {
        return ReferenceEquals(x, y);
      }

      int IEqualityComparer<object>.GetHashCode(object obj)
      {
#if !(NETFX_CORE || PORTABLE)
        // put objects in a bucket based on their reference
        return RuntimeHelpers.GetHashCode(obj);
#else
        // put all objects in the same bucket so ReferenceEquals is called on all
        return -1;
#endif
      }
    }

    private ErrorContext _currentErrorContext;
    private BidirectionalDictionary<string, object> _mappings;
    private bool _serializing;

    internal readonly JsonSerializer Serializer;
    internal readonly ITraceWriter TraceWriter;

    protected JsonSerializerInternalBase(JsonSerializer serializer)
    {
      ValidationUtils.ArgumentNotNull(serializer, "serializer");

      Serializer = serializer;
      TraceWriter = serializer.TraceWriter;

      // kind of a hack but meh. might clean this up later
      _serializing = (GetType() == typeof (JsonSerializerInternalWriter));
    }

    internal BidirectionalDictionary<string, object> DefaultReferenceMappings
    {
      get
      {
        // override equality comparer for object key dictionary
        // object will be modified as it deserializes and might have mutable hashcode
        if (_mappings == null)
          _mappings = new BidirectionalDictionary<string, object>(
            EqualityComparer<string>.Default,
            new ReferenceEqualsEqualityComparer(),
            "A different value already has the Id '{0}'.",
            "A different Id has already been assigned for value '{0}'.");

        return _mappings;
      }
    }

    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
    {
      if (_currentErrorContext == null)
        _currentErrorContext = new ErrorContext(currentObject, member, path, error);

      if (_currentErrorContext.Error != error)
        throw new InvalidOperationException("Current error context error is different to requested error.");

      return _currentErrorContext;
    }

    protected void ClearErrorContext()
    {
      if (_currentErrorContext == null)
        throw new InvalidOperationException("Could not clear error context. Error context is already null.");

      _currentErrorContext = null;
    }

    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
    {
      ErrorContext errorContext = GetErrorContext(currentObject, keyValue, path, ex);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
      {
        // only write error once
        errorContext.Traced = true;

        string message = (_serializing) ? "Error serializing" : "Error deserializing";
        if (contract != null)
          message += " " + contract.UnderlyingType;
        message += ". " + ex.Message;

        // add line information to non-json.net exception message
        if (!(ex is JsonException))
          message = JsonPosition.FormatMessage(lineInfo, path, message);

        TraceWriter.Trace(TraceLevel.Error, message, ex);
      }

      if (contract != null)
        contract.InvokeOnError(currentObject, Serializer.Context, errorContext);

      if (!errorContext.Handled)
        Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));

      return errorContext.Handled;
    }
  }
}
#endregion Serialization_JsonSerializerInternalBase.cs

/// ********   File: \Serialization\JsonSerializerInternalReader.cs
#region Serialization_JsonSerializerInternalReader.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
  internal class JsonSerializerInternalReader : JsonSerializerInternalBase
  {
    internal enum PropertyPresence
    {
      None,
      Null,
      Value
    }

    private JsonSerializerProxy _internalSerializer;
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    private JsonFormatterConverter _formatterConverter;
#endif

    public JsonSerializerInternalReader(JsonSerializer serializer)
      : base(serializer)
    {
    }

    public void Populate(JsonReader reader, object target)
    {
      ValidationUtils.ArgumentNotNull(target, "target");

      Type objectType = target.GetType();

      JsonContract contract = Serializer.ContractResolver.ResolveContract(objectType);

      if (reader.TokenType == JsonToken.None)
        reader.Read();

      if (reader.TokenType == JsonToken.StartArray)
      {
        if (contract.ContractType == JsonContractType.Array)
          PopulateList(CollectionUtils.CreateCollectionWrapper(target), reader, (JsonArrayContract) contract, null, null);
        else
          throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, objectType));
      }
      else if (reader.TokenType == JsonToken.StartObject)
      {
        CheckedRead(reader);

        string id = null;
        if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), JsonTypeReflector.IdPropertyName, StringComparison.Ordinal))
        {
          CheckedRead(reader);
          id = (reader.Value != null) ? reader.Value.ToString() : null;
          CheckedRead(reader);
        }

        if (contract.ContractType == JsonContractType.Dictionary)
          PopulateDictionary(CollectionUtils.CreateDictionaryWrapper(target), reader, (JsonDictionaryContract) contract, null, id);
        else if (contract.ContractType == JsonContractType.Object)
          PopulateObject(target, reader, (JsonObjectContract) contract, null, id);
        else
          throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, objectType));
      }
      else
      {
        throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
      }
    }

    private JsonContract GetContractSafe(Type type)
    {
      if (type == null)
        return null;

      return Serializer.ContractResolver.ResolveContract(type);
    }

    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
    {
      if (reader == null)
        throw new ArgumentNullException("reader");

      JsonContract contract = GetContractSafe(objectType);

      try
      {
        JsonConverter converter = GetConverter(contract, null, null, null);

        if (reader.TokenType == JsonToken.None && !ReadForType(reader, contract, converter != null))
        {
          if (contract != null && !contract.IsNullable)
            throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

          return null;
        }

        object deserializedValue;

        if (converter != null && converter.CanRead)
          deserializedValue = DeserializeConvertable(converter, reader, objectType, null);
        else
          deserializedValue = CreateValueInternal(reader, objectType, contract, null, null, null, null);

        if (checkAdditionalContent)
        {
          if (reader.Read() && reader.TokenType != JsonToken.Comment)
            throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
        }

        return deserializedValue;
      }
      catch (Exception ex)
      {
        if (IsErrorHandled(null, contract, null, reader as IJsonLineInfo, reader.Path, ex))
        {
          HandleError(reader, false, 0);
          return null;
        }
        else
        {
          throw;
        }
      }
    }

    private JsonSerializerProxy GetInternalSerializer()
    {
      if (_internalSerializer == null)
        _internalSerializer = new JsonSerializerProxy(this);

      return _internalSerializer;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    private JsonFormatterConverter GetFormatterConverter()
    {
      if (_formatterConverter == null)
        _formatterConverter = new JsonFormatterConverter(GetInternalSerializer());

      return _formatterConverter;
    }
#endif

    private JToken CreateJToken(JsonReader reader, JsonContract contract)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      if (contract != null && contract.UnderlyingType == typeof (JRaw))
      {
        return JRaw.Create(reader);
      }
      else
      {
        JToken token;
        using (JTokenWriter writer = new JTokenWriter())
        {
          writer.WriteToken(reader);
          token = writer.Token;
        }

        return token;
      }
    }

    private JToken CreateJObject(JsonReader reader)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      // this is needed because we've already read inside the object, looking for special properties
      JToken token;
      using (JTokenWriter writer = new JTokenWriter())
      {
        writer.WriteStartObject();

        if (reader.TokenType == JsonToken.PropertyName)
          writer.WriteToken(reader, reader.Depth - 1);
        else
          writer.WriteEndObject();

        token = writer.Token;
      }

      return token;
    }

    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
    {
      if (contract != null && contract.ContractType == JsonContractType.Linq)
        return CreateJToken(reader, contract);

      do
      {
        switch (reader.TokenType)
        {
            // populate a typed object or generic dictionary/array
            // depending upon whether an objectType was supplied
          case JsonToken.StartObject:
            return CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
          case JsonToken.StartArray:
            return CreateList(reader, objectType, contract, member, existingValue, null);
          case JsonToken.Integer:
          case JsonToken.Float:
          case JsonToken.Boolean:
          case JsonToken.Date:
          case JsonToken.Bytes:
            return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
          case JsonToken.String:
            // convert empty string to null automatically for nullable types
            if (string.IsNullOrEmpty((string)reader.Value) && objectType != typeof(string) && objectType != typeof(object) && contract != null && contract.IsNullable)
              return null;

            // string that needs to be returned as a byte array should be base 64 decoded
            if (objectType == typeof (byte[]))
              return Convert.FromBase64String((string) reader.Value);

            return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
          case JsonToken.StartConstructor:
            string constructorName = reader.Value.ToString();

            return EnsureType(reader, constructorName, CultureInfo.InvariantCulture, contract, objectType);
          case JsonToken.Null:
          case JsonToken.Undefined:
#if !(NETFX_CORE || PORTABLE)
            if (objectType == typeof (DBNull))
              return DBNull.Value;
#endif

            return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
          case JsonToken.Raw:
            return new JRaw((string) reader.Value);
          case JsonToken.Comment:
            // ignore
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + reader.TokenType);
        }
      } while (reader.Read());

      throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
    }

    internal string GetExpectedDescription(JsonContract contract)
    {
      switch (contract.ContractType)
      {
        case JsonContractType.Object:
        case JsonContractType.Dictionary:
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        case JsonContractType.Serializable:
#endif
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
        case JsonContractType.Dynamic:
#endif
          return @"JSON object (e.g. {""name"":""value""})";
        case JsonContractType.Array:
          return @"JSON array (e.g. [1,2,3])";
        case JsonContractType.Primitive:
          return @"JSON primitive value (e.g. string, number, boolean, null)";
        case JsonContractType.String:
          return @"JSON string value";
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      JsonConverter converter = null;
      if (memberConverter != null)
      {
        // member attribute converter
        converter = memberConverter;
      }
      else if (containerProperty != null && containerProperty.ItemConverter != null)
      {
        converter = containerProperty.ItemConverter;
      }
      else if (containerContract != null && containerContract.ItemConverter != null)
      {
        converter = containerContract.ItemConverter;
      }
      else if (contract != null)
      {
        JsonConverter matchingConverter;
        if (contract.Converter != null)
          // class attribute converter
          converter = contract.Converter;
        else if ((matchingConverter = Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
          // passed in converters
          converter = matchingConverter;
        else if (contract.InternalConverter != null)
          // internally specified converter
          converter = contract.InternalConverter;
      }
      return converter;
    }

    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
    {
      CheckedRead(reader);

      string id;
      object newValue;
      if (ReadSpecialProperties(reader, ref objectType, ref contract, member, containerContract, containerMember, existingValue, out newValue, out id))
        return newValue;

      if (!HasDefinedType(objectType))
        return CreateJObject(reader);

      if (contract == null)
        throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));

      switch (contract.ContractType)
      {
        case JsonContractType.Object:
          bool createdFromNonDefaultConstructor = false;
          JsonObjectContract objectContract = (JsonObjectContract) contract;
          object targetObject;
          if (existingValue != null)
            targetObject = existingValue;
          else
            targetObject = CreateNewObject(reader, objectContract, member, containerMember, id, out createdFromNonDefaultConstructor);

          // don't populate if read from non-default constructor because the object has already been read
          if (createdFromNonDefaultConstructor)
            return targetObject;

          return PopulateObject(targetObject, reader, objectContract, member, id);
        case JsonContractType.Primitive:
          JsonPrimitiveContract primitiveContract = (JsonPrimitiveContract) contract;
          // if the content is inside $value then read past it
          if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), JsonTypeReflector.ValuePropertyName, StringComparison.Ordinal))
          {
            CheckedRead(reader);
            object value = CreateValueInternal(reader, objectType, primitiveContract, member, null, null, existingValue);

            CheckedRead(reader);
            return value;
          }
          break;
        case JsonContractType.Dictionary:
          JsonDictionaryContract dictionaryContract = (JsonDictionaryContract) contract;
          object targetDictionary;
          if (existingValue != null)
            targetDictionary = existingValue;
          else
            targetDictionary = CreateNewDictionary(reader, dictionaryContract);

          return PopulateDictionary(dictionaryContract.CreateWrapper(targetDictionary), reader, dictionaryContract, member, id);
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
        case JsonContractType.Dynamic:
          JsonDynamicContract dynamicContract = (JsonDynamicContract) contract;
          return CreateDynamic(reader, dynamicContract, member, id);
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        case JsonContractType.Serializable:
          JsonISerializableContract serializableContract = (JsonISerializableContract) contract;
          return CreateISerializable(reader, serializableContract, id);
#endif
      }

      throw JsonSerializationException.Create(reader, @"Cannot deserialize the current JSON object (e.g. {{""name"":""value""}}) into type '{0}' because the type requires a {1} to deserialize correctly.
To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object.
".FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract)));
    }

    private bool ReadSpecialProperties(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
    {
      id = null;
      newValue = null;

      if (reader.TokenType == JsonToken.PropertyName)
      {
        string propertyName = reader.Value.ToString();

        if (propertyName.Length > 0 && propertyName[0] == '$')
        {
          // read 'special' properties
          // $type, $id, $ref, etc
          bool specialProperty;

          do
          {
            propertyName = reader.Value.ToString();

            if (string.Equals(propertyName, JsonTypeReflector.RefPropertyName, StringComparison.Ordinal))
            {
              CheckedRead(reader);
              if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
                throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, JsonTypeReflector.RefPropertyName));

              string reference = (reader.Value != null) ? reader.Value.ToString() : null;

              CheckedRead(reader);

              if (reference != null)
              {
                if (reader.TokenType == JsonToken.PropertyName)
                  throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, JsonTypeReflector.RefPropertyName));

                newValue = Serializer.ReferenceResolver.ResolveReference(this, reference);

                if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
                  TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, reference, newValue.GetType())), null);

                return true;
              }
              else
              {
                specialProperty = true;
              }
            }
            else if (string.Equals(propertyName, JsonTypeReflector.TypePropertyName, StringComparison.Ordinal))
            {
              CheckedRead(reader);
              string qualifiedTypeName = reader.Value.ToString();

              TypeNameHandling resolvedTypeNameHandling =
                ((member != null) ? member.TypeNameHandling : null)
                ?? ((containerContract != null) ? containerContract.ItemTypeNameHandling : null)
                ?? ((containerMember != null) ? containerMember.ItemTypeNameHandling : null)
                ?? Serializer.TypeNameHandling;

              if (resolvedTypeNameHandling != TypeNameHandling.None)
              {
                string typeName;
                string assemblyName;
                ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName, out typeName, out assemblyName);

                Type specifiedType;
                try
                {
                  specifiedType = Serializer.Binder.BindToType(assemblyName, typeName);
                }
                catch (Exception ex)
                {
                  throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName), ex);
                }

                if (specifiedType == null)
                  throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName));

                if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
                  TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName, specifiedType)), null);

                if (objectType != null
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
                    && objectType != typeof (IDynamicMetaObjectProvider)
#endif
                    && !objectType.IsAssignableFrom(specifiedType))
                  throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture, specifiedType.AssemblyQualifiedName, objectType.AssemblyQualifiedName));

                objectType = specifiedType;
                contract = GetContractSafe(specifiedType);
              }

              CheckedRead(reader);

              specialProperty = true;
            }
            else if (string.Equals(propertyName, JsonTypeReflector.IdPropertyName, StringComparison.Ordinal))
            {
              CheckedRead(reader);

              id = (reader.Value != null) ? reader.Value.ToString() : null;

              CheckedRead(reader);
              specialProperty = true;
            }
            else if (string.Equals(propertyName, JsonTypeReflector.ArrayValuesPropertyName, StringComparison.Ordinal))
            {
              CheckedRead(reader);
              object list = CreateList(reader, objectType, contract, member, existingValue, id);
              CheckedRead(reader);
              newValue = list;
              return true;
            }
            else
            {
              specialProperty = false;
            }
          } while (specialProperty
                   && reader.TokenType == JsonToken.PropertyName);
        }
      }
      return false;
    }

    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
    {
      if (contract == null)
        throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));

      JsonArrayContract arrayContract = contract as JsonArrayContract;
      if (arrayContract == null)
        throw JsonSerializationException.Create(reader, @"Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly.
To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array.
".FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract)));

      return arrayContract;
    }

    private void CheckedRead(JsonReader reader)
    {
      if (!reader.Read())
        throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
    }

    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
    {
      object value;
      if (HasDefinedType(objectType))
      {
        JsonArrayContract arrayContract = EnsureArrayContract(reader, objectType, contract);

        if (existingValue == null)
        {
          bool isTemporaryListReference;
          IList list = CollectionUtils.CreateList(contract.CreatedType, out isTemporaryListReference);

          if (id != null && isTemporaryListReference)
            throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

#if !PocketPC
          if (contract.OnSerializing != null && isTemporaryListReference)
            throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
#endif
          if (contract.OnError != null && isTemporaryListReference)
            throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

          if (!arrayContract.IsMultidimensionalArray)
            PopulateList(arrayContract.CreateWrapper(list), reader, arrayContract, member, id);
          else
            PopulateMultidimensionalArray(list, reader, arrayContract, member, id);

          // create readonly and fixed sized collections using the temporary list
          if (isTemporaryListReference)
          {
            if (arrayContract.IsMultidimensionalArray)
            {
              list = CollectionUtils.ToMultidimensionalArray(list, ReflectionUtils.GetCollectionItemType(contract.CreatedType), contract.CreatedType.GetArrayRank());
            }
            else if (contract.CreatedType.IsArray)
            {
              list = CollectionUtils.ToArray(((List<object>) list).ToArray(), ReflectionUtils.GetCollectionItemType(contract.CreatedType));
            }
            else if (ReflectionUtils.InheritsGenericDefinition(contract.CreatedType, typeof(ReadOnlyCollection<>)))
            {
              list = (IList) ReflectionUtils.CreateInstance(contract.CreatedType, list);
            }
          }
          else if (list is IWrappedCollection)
          {
            return ((IWrappedCollection)list).UnderlyingCollection;
          }

          value = list;
        }
        else
        {
          value = PopulateList(arrayContract.CreateWrapper(existingValue), reader, arrayContract, member, id);
        }
      }
      else
      {
        value = CreateJToken(reader, contract);
      }
      return value;
    }

    private bool HasDefinedType(Type type)
    {
      return (type != null && type != typeof (object) && !typeof (JToken).IsSubclassOf(type)
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
        && type != typeof (IDynamicMetaObjectProvider)
#endif
        );
    }

    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
    {
      if (targetType == null)
        return value;

      Type valueType = ReflectionUtils.GetObjectType(value);

      // type of value and type of target don't match
      // attempt to convert value's type to target's type
      if (valueType != targetType)
      {
        try
        {
          if (value == null && contract.IsNullable)
            return null;

          if (contract.IsConvertable)
          {
            if (contract.NonNullableUnderlyingType.IsEnum())
              {
                if (value is string)
                  return Enum.Parse(contract.NonNullableUnderlyingType, value.ToString(), true);
                else if (ConvertUtils.IsInteger(value))
                  return Enum.ToObject(contract.NonNullableUnderlyingType, value);
              }

              return Convert.ChangeType(value, contract.NonNullableUnderlyingType, culture);
          }

          return ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
        }
        catch (Exception ex)
        {
          throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, FormatValueForPrint(value), targetType), ex);
        }
      }

      return value;
    }

    private string FormatValueForPrint(object value)
    {
      if (value == null)
        return "{null}";

      if (value is string)
        return @"""" + value + @"""";

      return value.ToString();
    }

    private void SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
    {
      object currentValue;
      bool useExistingValue;
      JsonContract propertyContract;
      bool gottenCurrentValue;

      if (CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out useExistingValue, out currentValue, out propertyContract, out gottenCurrentValue))
        return;

      object value;

      if (propertyConverter != null && propertyConverter.CanRead)
      {
        if (!gottenCurrentValue && target != null && property.Readable)
          currentValue = property.ValueProvider.GetValue(target);

        value = DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
      }
      else
      {
        value = CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, (useExistingValue) ? currentValue : null);
      }

      // always set the value if useExistingValue is false,
      // otherwise also set it if CreateValue returns a new value compared to the currentValue
      // this could happen because of a JsonConverter against the type
      if ((!useExistingValue || value != currentValue)
        && ShouldSetPropertyValue(property, value))
      {
        property.ValueProvider.SetValue(target, value);

        if (property.SetIsSpecified != null)
        {
          if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
            TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);

          property.SetIsSpecified(target, true);
        }
      }
    }

    private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, out bool useExistingValue, out object currentValue, out JsonContract propertyContract, out bool gottenCurrentValue)
    {
      currentValue = null;
      useExistingValue = false;
      propertyContract = null;
      gottenCurrentValue = false;

      if (property.Ignored)
      {
        reader.Skip();
        return true;
      }

      ObjectCreationHandling objectCreationHandling =
        property.ObjectCreationHandling.GetValueOrDefault(Serializer.ObjectCreationHandling);

      if ((objectCreationHandling == ObjectCreationHandling.Auto || objectCreationHandling == ObjectCreationHandling.Reuse)
          && (reader.TokenType == JsonToken.StartArray || reader.TokenType == JsonToken.StartObject)
          && property.Readable)
      {
        currentValue = property.ValueProvider.GetValue(target);
        gottenCurrentValue = true;

        useExistingValue = (currentValue != null
                            && !property.PropertyType.IsArray
                            && !ReflectionUtils.InheritsGenericDefinition(property.PropertyType, typeof (ReadOnlyCollection<>))
                            && !property.PropertyType.IsValueType());
      }

      if (!property.Writable && !useExistingValue)
      {
        reader.Skip();
        return true;
      }

      // test tokentype here because null might not be convertable to some types, e.g. ignoring null when applied to DateTime
      if (property.NullValueHandling.GetValueOrDefault(Serializer.NullValueHandling) == NullValueHandling.Ignore && reader.TokenType == JsonToken.Null)
      {
        reader.Skip();
        return true;
      }

      // test tokentype here because default value might not be convertable to actual type, e.g. default of "" for DateTime
      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling), DefaultValueHandling.Ignore)
          && JsonReader.IsPrimitiveToken(reader.TokenType)
          && MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
      {
        reader.Skip();
        return true;
      }

      if (property.PropertyContract == null)
        property.PropertyContract = GetContractSafe(property.PropertyType);

      if (currentValue == null)
      {
        propertyContract = property.PropertyContract;
      }
      else
      {
        propertyContract = GetContractSafe(currentValue.GetType());

        if (propertyContract != property.PropertyContract)
          propertyConverter = GetConverter(propertyContract, property.MemberConverter, containerContract, containerProperty);
      }

      return false;
    }

    private void AddReference(JsonReader reader, string id, object value)
    {
      try
      {
        if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
          TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, id, value.GetType())), null);

        Serializer.ReferenceResolver.AddReference(this, id, value);
      }
      catch (Exception ex)
      {
        throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
      }
    }

    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
    {
      return ((value & flag) == flag);
    }

    private bool ShouldSetPropertyValue(JsonProperty property, object value)
    {
      if (property.NullValueHandling.GetValueOrDefault(Serializer.NullValueHandling) == NullValueHandling.Ignore && value == null)
        return false;

      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling), DefaultValueHandling.Ignore)
        && MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue()))
        return false;

      if (!property.Writable)
        return false;

      return true;
    }

    public object CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract)
    {
      object dictionary;

      if (contract.DefaultCreator != null &&
        (!contract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
        dictionary = contract.DefaultCreator();
      else
        throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

      return dictionary;
    }

    private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
    {
      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);

      contract.InvokeOnDeserializing(value, Serializer.Context);
    }

    private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
    {
      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);

      contract.InvokeOnDeserialized(value, Serializer.Context);
    }

    private object PopulateDictionary(IWrappedDictionary wrappedDictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
    {
      object dictionary = wrappedDictionary.UnderlyingDictionary;

      if (id != null)
        AddReference(reader, id, dictionary);

      OnDeserializing(reader, contract, dictionary);

      int initialDepth = reader.Depth;

      if (contract.KeyContract == null)
        contract.KeyContract = GetContractSafe(contract.DictionaryKeyType);

      if (contract.ItemContract == null)
        contract.ItemContract = GetContractSafe(contract.DictionaryValueType);

      JsonConverter dictionaryValueConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract, null, contract, containerProperty);

      bool finished = false;
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            object keyValue = reader.Value;
            try
            {
              try
              {
                keyValue = EnsureType(reader, keyValue, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
              }
              catch (Exception ex)
              {
                throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), ex);
              }

              if (!ReadForType(reader, contract.ItemContract, dictionaryValueConverter != null))
                throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");

              object itemValue;
              if (dictionaryValueConverter != null && dictionaryValueConverter.CanRead)
                itemValue = DeserializeConvertable(dictionaryValueConverter, reader, contract.DictionaryValueType, null);
              else
                itemValue = CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, null, contract, containerProperty, null);

              wrappedDictionary[keyValue] = itemValue;
            }
            catch (Exception ex)
            {
              if (IsErrorHandled(dictionary, contract, keyValue, reader as IJsonLineInfo, reader.Path, ex))
                HandleError(reader, true, initialDepth);
              else
                throw;
            }
            break;
          case JsonToken.Comment:
            break;
          case JsonToken.EndObject:
            finished = true;
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
        }
      } while (!finished && reader.Read());

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, dictionary, "Unexpected end when deserializing object.");

      OnDeserialized(reader, contract, dictionary);
      return dictionary;
    }

    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
    {
      int rank = contract.UnderlyingType.GetArrayRank();

      if (id != null)
        AddReference(reader, id, list);

      OnDeserializing(reader, contract, list);

      JsonContract collectionItemContract = GetContractSafe(contract.CollectionItemType);
      JsonConverter collectionItemConverter = GetConverter(collectionItemContract, null, contract, containerProperty);

      int? previousErrorIndex = null;
      Stack<IList> listStack = new Stack<IList>();
      listStack.Push(list);
      IList currentList = list;

      bool finished = false;
      do
      {
        int initialDepth = reader.Depth;

        if (listStack.Count == rank)
        {
          try
          {
            if (ReadForType(reader, collectionItemContract, collectionItemConverter != null))
            {
              switch (reader.TokenType)
              {
                case JsonToken.EndArray:
                  listStack.Pop();
                  currentList = listStack.Peek();
                  previousErrorIndex = null;
                  break;
                case JsonToken.Comment:
                  break;
                default:
                  object value;

                  if (collectionItemConverter != null && collectionItemConverter.CanRead)
                    value = DeserializeConvertable(collectionItemConverter, reader, contract.CollectionItemType, null);
                  else
                    value = CreateValueInternal(reader, contract.CollectionItemType, collectionItemContract, null, contract, containerProperty, null);

                  currentList.Add(value);
                  break;
              }
            }
            else
            {
              break;
            }
          }
          catch (Exception ex)
          {
            JsonPosition errorPosition = reader.GetPosition(initialDepth);

            if (IsErrorHandled(list, contract, errorPosition.Position, reader as IJsonLineInfo, reader.Path, ex))
            {
              HandleError(reader, true, initialDepth);

              if (previousErrorIndex != null && previousErrorIndex == errorPosition.Position)
              {
                // reader index has not moved since previous error handling
                // break out of reading array to prevent infinite loop
                throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
              }
              else
              {
                previousErrorIndex = errorPosition.Position;
              }
            }
            else
            {
              throw;
            }
          }
        }
        else
        {
          if (reader.Read())
          {
            switch (reader.TokenType)
            {
              case JsonToken.StartArray:
                IList newList = new List<object>();
                currentList.Add(newList);
                listStack.Push(newList);
                currentList = newList;
                break;
              case JsonToken.EndArray:
                listStack.Pop();

                if (listStack.Count > 0)
                {
                  currentList = listStack.Peek();
                }
                else
                {
                  finished = true;
                }
                break;
              case JsonToken.Comment:
                break;
              default:
                throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + reader.TokenType);
            }
          }
          else
          {
            break;
          }
        }
      } while (!finished);

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");

      OnDeserialized(reader, contract, list);
      return list;
    }

    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
    {
      try
      {
        throw JsonSerializationException.Create(reader, message);
      }
      catch (Exception ex)
      {
        if (IsErrorHandled(currentObject, contract, null, reader as IJsonLineInfo, reader.Path, ex))
          HandleError(reader, false, 0);
        else
          throw;
      }
    }

    private object PopulateList(IWrappedCollection wrappedList, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
    {
      object list = wrappedList.UnderlyingCollection;

      if (id != null)
        AddReference(reader, id, list);

      // can't populate an existing array
      if (wrappedList.IsFixedSize)
      {
        reader.Skip();
        return list;
      }

      OnDeserializing(reader, contract, list);

      int initialDepth = reader.Depth;

      JsonContract collectionItemContract = GetContractSafe(contract.CollectionItemType);
      JsonConverter collectionItemConverter = GetConverter(collectionItemContract, null, contract, containerProperty);

      int? previousErrorIndex = null;

      bool finished = false;
      do
      {
        try
        {
          if (ReadForType(reader, collectionItemContract, collectionItemConverter != null))
          {
            switch (reader.TokenType)
            {
              case JsonToken.EndArray:
                finished = true;
                break;
              case JsonToken.Comment:
                break;
              default:
                object value;

                if (collectionItemConverter != null && collectionItemConverter.CanRead)
                  value = DeserializeConvertable(collectionItemConverter, reader, contract.CollectionItemType, null);
                else
                  value = CreateValueInternal(reader, contract.CollectionItemType, collectionItemContract, null, contract, containerProperty, null);

                wrappedList.Add(value);
                break;
            }
          }
          else
          {
            break;
          }
        }
        catch (Exception ex)
        {
          JsonPosition errorPosition = reader.GetPosition(initialDepth);

          if (IsErrorHandled(list, contract, errorPosition.Position, reader as IJsonLineInfo, reader.Path, ex))
          {
            HandleError(reader, true, initialDepth);

            if (previousErrorIndex != null && previousErrorIndex == errorPosition.Position)
            {
              // reader index has not moved since previous error handling
              // break out of reading array to prevent infinite loop
              throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
            }
            else
            {
              previousErrorIndex = errorPosition.Position;
            }
          }
          else
          {
            throw;
          }
        }
      } while (!finished);

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");

      OnDeserialized(reader, contract, list);
      return list;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, string id)
    {
      Type objectType = contract.UnderlyingType;

      if (!JsonTypeReflector.FullyTrusted)
      {
        throw JsonSerializationException.Create(reader, @"Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data.
To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true.
".FormatWith(CultureInfo.InvariantCulture, objectType));
      }

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);

      SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, GetFormatterConverter());

      bool finished = false;
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            string memberName = reader.Value.ToString();
            if (!reader.Read())
              throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, memberName));

            serializationInfo.AddValue(memberName, JToken.ReadFrom(reader));
            break;
          case JsonToken.Comment:
            break;
          case JsonToken.EndObject:
            finished = true;
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
        }
      } while (!finished && reader.Read());

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, serializationInfo, "Unexpected end when deserializing object.");

      if (contract.ISerializableCreator == null)
        throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture, objectType));

      object createdObject = contract.ISerializableCreator(serializationInfo, Serializer.Context);

      if (id != null)
        AddReference(reader, id, createdObject);

      // these are together because OnDeserializing takes an object but for an ISerializable the object is fully created in the constructor
      OnDeserializing(reader, contract, createdObject);
      OnDeserialized(reader, contract, createdObject);

      return createdObject;
    }
#endif

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id)
    {
      IDynamicMetaObjectProvider newObject;

      if (contract.UnderlyingType.IsInterface() || contract.UnderlyingType.IsAbstract())
        throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

      if (contract.DefaultCreator != null &&
        (!contract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
        newObject = (IDynamicMetaObjectProvider) contract.DefaultCreator();
      else
        throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));

      if (id != null)
        AddReference(reader, id, newObject);

      OnDeserializing(reader, contract, newObject);

      int initialDepth = reader.Depth;

      bool finished = false;
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            string memberName = reader.Value.ToString();

            try
            {
              if (!reader.Read())
                throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, memberName));

              // first attempt to find a settable property, otherwise fall back to a dynamic set without type
              JsonProperty property = contract.Properties.GetClosestMatchProperty(memberName);

              if (property != null && property.Writable && !property.Ignored)
              {
                if (property.PropertyContract == null)
                  property.PropertyContract = GetContractSafe(property.PropertyType);

                JsonConverter propertyConverter = GetConverter(property.PropertyContract, property.MemberConverter, null, null);

                SetPropertyValue(property, propertyConverter, null, member, reader, newObject);
              }
              else
              {
                Type t = (JsonReader.IsPrimitiveToken(reader.TokenType)) ? reader.ValueType : typeof (IDynamicMetaObjectProvider);

                JsonContract dynamicMemberContract = GetContractSafe(t);
                JsonConverter dynamicMemberConverter = GetConverter(dynamicMemberContract, null, null, member);

                object value;
                if (dynamicMemberConverter != null && dynamicMemberConverter.CanRead)
                  value = DeserializeConvertable(dynamicMemberConverter, reader, t, null);
                else
                  value = CreateValueInternal(reader, t, dynamicMemberContract, null, null, member, null);

                newObject.TrySetMember(memberName, value);
              }
            }
            catch (Exception ex)
            {
              if (IsErrorHandled(newObject, contract, memberName, reader as IJsonLineInfo, reader.Path, ex))
                HandleError(reader, true, initialDepth);
              else
                throw;
            }
            break;
          case JsonToken.EndObject:
            finished = true;
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
        }
      } while (!finished && reader.Read());

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");

      OnDeserialized(reader, contract, newObject);

      return newObject;
    }
#endif

    private object CreateObjectFromNonDefaultConstructor(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ConstructorInfo constructorInfo, string id)
    {
      ValidationUtils.ArgumentNotNull(constructorInfo, "constructorInfo");

      Type objectType = contract.UnderlyingType;

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using a non-default constructor '{1}'.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType, constructorInfo)), null);

      IDictionary<JsonProperty, object> propertyValues = ResolvePropertyAndConstructorValues(contract, containerProperty, reader, objectType);

      IDictionary<ParameterInfo, object> constructorParameters = constructorInfo.GetParameters().ToDictionary(p => p, p => (object) null);
      IDictionary<JsonProperty, object> remainingPropertyValues = new Dictionary<JsonProperty, object>();

      foreach (KeyValuePair<JsonProperty, object> propertyValue in propertyValues)
      {
        ParameterInfo matchingConstructorParameter = constructorParameters.ForgivingCaseSensitiveFind(kv => kv.Key.Name, propertyValue.Key.UnderlyingName).Key;
        if (matchingConstructorParameter != null)
          constructorParameters[matchingConstructorParameter] = propertyValue.Value;
        else
          remainingPropertyValues.Add(propertyValue);
      }

      object createdObject = constructorInfo.Invoke(constructorParameters.Values.ToArray());

      if (id != null)
        AddReference(reader, id, createdObject);

      OnDeserializing(reader, contract, createdObject);

      // go through unused values and set the newly created object's properties
      foreach (KeyValuePair<JsonProperty, object> remainingPropertyValue in remainingPropertyValues)
      {
        JsonProperty property = remainingPropertyValue.Key;
        object value = remainingPropertyValue.Value;

        if (ShouldSetPropertyValue(remainingPropertyValue.Key, remainingPropertyValue.Value))
        {
          property.ValueProvider.SetValue(createdObject, value);
        }
        else if (!property.Writable && value != null)
        {
          // handle readonly collection/dictionary properties
          JsonContract propertyContract = Serializer.ContractResolver.ResolveContract(property.PropertyType);

          if (propertyContract.ContractType == JsonContractType.Array)
          {
            JsonArrayContract propertyArrayContract = (JsonArrayContract)propertyContract;

            object createdObjectCollection = property.ValueProvider.GetValue(createdObject);
            if (createdObjectCollection != null)
            {
              IWrappedCollection createdObjectCollectionWrapper = propertyArrayContract.CreateWrapper(createdObjectCollection);
              IWrappedCollection newValues = propertyArrayContract.CreateWrapper(value);

              foreach (object newValue in newValues)
              {
                createdObjectCollectionWrapper.Add(newValue);
              }
            }
          }
          else if (propertyContract.ContractType == JsonContractType.Dictionary)
          {
            JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)propertyContract;

            object createdObjectDictionary = property.ValueProvider.GetValue(createdObject);
            if (createdObjectDictionary != null)
            {
              IWrappedDictionary createdObjectDictionaryWrapper = jsonDictionaryContract.CreateWrapper(createdObjectDictionary);
              IWrappedDictionary newValues = jsonDictionaryContract.CreateWrapper(value);

              foreach (DictionaryEntry newValue in newValues)
              {
                createdObjectDictionaryWrapper.Add(newValue.Key, newValue.Value);
              }
            }
          }
        }
      }

      OnDeserialized(reader, contract, createdObject);
      return createdObject;
    }

    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
    {
      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);

      object value = converter.ReadJson(reader, objectType, existingValue, GetInternalSerializer());

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);

      return value;
    }

    private IDictionary<JsonProperty, object> ResolvePropertyAndConstructorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
    {
      IDictionary<JsonProperty, object> propertyValues = new Dictionary<JsonProperty, object>();
      bool exit = false;
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            string memberName = reader.Value.ToString();

            // attempt exact case match first
            // then try match ignoring case
            JsonProperty property = contract.ConstructorParameters.GetClosestMatchProperty(memberName) ??
              contract.Properties.GetClosestMatchProperty(memberName);

            if (property != null)
            {
              if (property.PropertyContract == null)
                property.PropertyContract = GetContractSafe(property.PropertyType);

              JsonConverter propertyConverter = GetConverter(property.PropertyContract, property.MemberConverter, contract, containerProperty);

              if (!ReadForType(reader, property.PropertyContract, propertyConverter != null))
                throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, memberName));

              if (!property.Ignored)
              {
                if (property.PropertyContract == null)
                  property.PropertyContract = GetContractSafe(property.PropertyType);

                object propertyValue;
                if (propertyConverter != null && propertyConverter.CanRead)
                  propertyValue = DeserializeConvertable(propertyConverter, reader, property.PropertyType, null);
                else
                  propertyValue = CreateValueInternal(reader, property.PropertyType, property.PropertyContract, property, contract, containerProperty, null);

                propertyValues[property] = propertyValue;
              }
              else
              {
                reader.Skip();
              }
            }
            else
            {
              if (!reader.Read())
                throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, memberName));

              if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
                TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, memberName, contract.UnderlyingType)), null);

              if (Serializer.MissingMemberHandling == MissingMemberHandling.Error)
                throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, memberName, objectType.Name));

              reader.Skip();
            }
            break;
          case JsonToken.Comment:
            break;
          case JsonToken.EndObject:
            exit = true;
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
        }
      } while (!exit && reader.Read());

      return propertyValues;
    }

    private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
    {
      // don't read properties with converters as a specific value
      // the value might be a string which will then get converted which will error if read as date for example
      if (hasConverter)
        return reader.Read();

      ReadType t = (contract != null) ? contract.InternalReadType : ReadType.Read;

      switch (t)
      {
        case ReadType.Read:
          do
          {
            if (!reader.Read())
              return false;
          } while (reader.TokenType == JsonToken.Comment);

          return true;
        case ReadType.ReadAsInt32:
          reader.ReadAsInt32();
          break;
        case ReadType.ReadAsDecimal:
          reader.ReadAsDecimal();
          break;
        case ReadType.ReadAsBytes:
          reader.ReadAsBytes();
          break;
        case ReadType.ReadAsString:
          reader.ReadAsString();
          break;
        case ReadType.ReadAsDateTime:
          reader.ReadAsDateTime();
          break;
#if !NET20
        case ReadType.ReadAsDateTimeOffset:
          reader.ReadAsDateTimeOffset();
          break;
#endif
        default:
          throw new ArgumentOutOfRangeException();
      }

      return (reader.TokenType != JsonToken.None);
    }

    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, out bool createdFromNonDefaultConstructor)
    {
      object newObject = null;

      if (objectContract.UnderlyingType.IsInterface() || objectContract.UnderlyingType.IsAbstract())
        throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));

      if (objectContract.OverrideConstructor != null)
      {
        if (objectContract.OverrideConstructor.GetParameters().Length > 0)
        {
          createdFromNonDefaultConstructor = true;
          return CreateObjectFromNonDefaultConstructor(reader, objectContract, containerMember, objectContract.OverrideConstructor, id);
        }

        newObject = objectContract.OverrideConstructor.Invoke(null);
      }
      else if (objectContract.DefaultCreator != null &&
        (!objectContract.DefaultCreatorNonPublic || Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParametrizedConstructor == null))
      {
        // use the default constructor if it is...
        // public
        // non-public and the user has change constructor handling settings
        // non-public and there is no other constructor
        newObject = objectContract.DefaultCreator();
      }
      else if (objectContract.ParametrizedConstructor != null)
      {
        createdFromNonDefaultConstructor = true;
        return CreateObjectFromNonDefaultConstructor(reader, objectContract, containerMember, objectContract.ParametrizedConstructor, id);
      }

      if (newObject == null)
        throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));

      createdFromNonDefaultConstructor = false;
      return newObject;
    }

    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
    {
      OnDeserializing(reader, contract, newObject);

      // only need to keep a track of properies presence if they are required or a value should be defaulted if missing
      Dictionary<JsonProperty, PropertyPresence> propertiesPresence = (contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer.DefaultValueHandling, DefaultValueHandling.Populate))
        ? contract.Properties.ToDictionary(m => m, m => PropertyPresence.None)
        : null;

      if (id != null)
        AddReference(reader, id, newObject);

      int initialDepth = reader.Depth;

      bool finished = false;
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.PropertyName:
            {
              string memberName = reader.Value.ToString();

              try
              {
                // attempt exact case match first
                // then try match ignoring case
                JsonProperty property = contract.Properties.GetClosestMatchProperty(memberName);

                if (property == null)
                {
                  if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
                    TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith(CultureInfo.InvariantCulture, memberName, contract.UnderlyingType)), null);

                  if (Serializer.MissingMemberHandling == MissingMemberHandling.Error)
                    throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, memberName, contract.UnderlyingType.Name));

                  reader.Skip();
                  continue;
                }

                if (property.PropertyContract == null)
                  property.PropertyContract = GetContractSafe(property.PropertyType);

                JsonConverter propertyConverter = GetConverter(property.PropertyContract, property.MemberConverter, contract, member);

                if (!ReadForType(reader, property.PropertyContract, propertyConverter != null))
                  throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, memberName));

                SetPropertyPresence(reader, property, propertiesPresence);

                SetPropertyValue(property, propertyConverter, contract, member, reader, newObject);
              }
              catch (Exception ex)
              {
                if (IsErrorHandled(newObject, contract, memberName, reader as IJsonLineInfo, reader.Path, ex))
                  HandleError(reader, true, initialDepth);
                else
                  throw;
              }
            }
            break;
          case JsonToken.EndObject:
            finished = true;
            break;
          case JsonToken.Comment:
            // ignore
            break;
          default:
            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
        }
      } while (!finished && reader.Read());

      if (!finished)
        ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");

      EndObject(newObject, reader, contract, initialDepth, propertiesPresence);

      OnDeserialized(reader, contract, newObject);
      return newObject;
    }

    private void EndObject(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, Dictionary<JsonProperty, PropertyPresence> propertiesPresence)
    {
      if (propertiesPresence != null)
      {
        foreach (KeyValuePair<JsonProperty, PropertyPresence> propertyPresence in propertiesPresence)
        {
          JsonProperty property = propertyPresence.Key;
          PropertyPresence presence = propertyPresence.Value;

          if (presence == PropertyPresence.None || presence == PropertyPresence.Null)
          {
            try
            {
              Required resolvedRequired = property._required ?? contract.ItemRequired ?? Required.Default;

              switch (presence)
              {
                case PropertyPresence.None:
                  if (resolvedRequired == Required.AllowNull || resolvedRequired == Required.Always)
                    throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));

                  if (property.PropertyContract == null)
                    property.PropertyContract = GetContractSafe(property.PropertyType);

                  if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling), DefaultValueHandling.Populate) && property.Writable)
                    property.ValueProvider.SetValue(newObject, EnsureType(reader, property.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, property.PropertyContract, property.PropertyType));
                  break;
                case PropertyPresence.Null:
                  if (resolvedRequired == Required.Always)
                    throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
                  break;
              }
            }
            catch (Exception ex)
            {
              if (IsErrorHandled(newObject, contract, property.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
                HandleError(reader, true, initialDepth);
              else
                throw;
            }
          }
        }
      }
    }

    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence> requiredProperties)
    {
      if (property != null && requiredProperties != null)
      {
        requiredProperties[property] = (reader.TokenType == JsonToken.Null || reader.TokenType == JsonToken.Undefined)
          ? PropertyPresence.Null
          : PropertyPresence.Value;
      }
    }

    private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
    {
      ClearErrorContext();

      if (readPastError)
      {
        reader.Skip();

        while (reader.Depth > (initialDepth + 1))
        {
          if (!reader.Read())
            break;
        }
      }
    }
  }
}
#endregion Serialization_JsonSerializerInternalReader.cs

/// ********   File: \Serialization\JsonSerializerInternalWriter.cs
#region Serialization_JsonSerializerInternalWriter.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
  internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
  {
    private readonly List<object> _serializeStack = new List<object>();
    private JsonSerializerProxy _internalSerializer;

    public JsonSerializerInternalWriter(JsonSerializer serializer)
      : base(serializer)
    {
    }

    public void Serialize(JsonWriter jsonWriter, object value)
    {
      if (jsonWriter == null)
        throw new ArgumentNullException("jsonWriter");

      SerializeValue(jsonWriter, value, GetContractSafe(value), null, null, null);
    }

    private JsonSerializerProxy GetInternalSerializer()
    {
      if (_internalSerializer == null)
        _internalSerializer = new JsonSerializerProxy(this);

      return _internalSerializer;
    }

    private JsonContract GetContractSafe(object value)
    {
      if (value == null)
        return null;

      return Serializer.ContractResolver.ResolveContract(value.GetType());
    }

    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      if (contract.UnderlyingType == typeof (byte[]))
      {
        bool includeTypeDetails = ShouldWriteType(TypeNameHandling.Objects, contract, member, containerContract, containerProperty);
        if (includeTypeDetails)
        {
          writer.WriteStartObject();
          WriteTypeProperty(writer, contract.CreatedType);
          writer.WritePropertyName(JsonTypeReflector.ValuePropertyName);
          writer.WriteValue(value);
          writer.WriteEndObject();
          return;
        }
      }

      writer.WriteValue(value);
    }

    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      if (value == null)
      {
        writer.WriteNull();
        return;
      }

      JsonConverter converter;
      if ((((converter = (member != null) ? member.Converter : null) != null)
           || ((converter = (containerProperty != null) ? containerProperty.ItemConverter : null) != null)
           || ((converter = (containerContract != null) ? containerContract.ItemConverter : null) != null)
           || ((converter = valueContract.Converter) != null)
           || ((converter = Serializer.GetMatchingConverter(valueContract.UnderlyingType)) != null)
           || ((converter = valueContract.InternalConverter) != null))
          && converter.CanWrite)
      {
        SerializeConvertable(writer, converter, value, valueContract, containerContract, containerProperty);
        return;
      }

      switch (valueContract.ContractType)
      {
        case JsonContractType.Object:
          SerializeObject(writer, value, (JsonObjectContract)valueContract, member, containerContract, containerProperty);
          break;
        case JsonContractType.Array:
          JsonArrayContract arrayContract = (JsonArrayContract) valueContract;
          if (!arrayContract.IsMultidimensionalArray)
            SerializeList(writer, arrayContract.CreateWrapper(value), arrayContract, member, containerContract, containerProperty);
          else
            SerializeMultidimensionalArray(writer, (Array)value, arrayContract, member, containerContract, containerProperty);
          break;
        case JsonContractType.Primitive:
          SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, containerContract, containerProperty);
          break;
        case JsonContractType.String:
          SerializeString(writer, value, (JsonStringContract)valueContract);
          break;
        case JsonContractType.Dictionary:
          JsonDictionaryContract dictionaryContract = (JsonDictionaryContract) valueContract;
          SerializeDictionary(writer, dictionaryContract.CreateWrapper(value), dictionaryContract, member, containerContract, containerProperty);
          break;
#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
        case JsonContractType.Dynamic:
          SerializeDynamic(writer, (IDynamicMetaObjectProvider)value, (JsonDynamicContract)valueContract, member, containerContract, containerProperty);
          break;
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
        case JsonContractType.Serializable:
          SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract, member, containerContract, containerProperty);
          break;
#endif
        case JsonContractType.Linq:
          ((JToken) value).WriteTo(writer, (Serializer.Converters != null) ? Serializer.Converters.ToArray() : null);
          break;
      }
    }

    private bool? ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      bool? isReference = null;

      // value could be coming from a dictionary or array and not have a property
      if (property != null)
        isReference = property.IsReference;

      if (isReference == null && containerProperty != null)
        isReference = containerProperty.ItemIsReference;

      if (isReference == null && collectionContract != null)
        isReference = collectionContract.ItemIsReference;

      if (isReference == null)
        isReference = contract.IsReference;

      return isReference;
    }

    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      if (value == null)
        return false;
      if (valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
        return false;

      bool? isReference = ResolveIsReference(valueContract, property, collectionContract, containerProperty);

      if (isReference == null)
      {
        if (valueContract.ContractType == JsonContractType.Array)
          isReference = HasFlag(Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Arrays);
        else
          isReference = HasFlag(Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Objects);
      }

      if (!isReference.Value)
        return false;

      return Serializer.ReferenceResolver.IsReferenced(this, value);
    }

    private bool ShouldWriteProperty(object memberValue, JsonProperty property)
    {
      if (property.NullValueHandling.GetValueOrDefault(Serializer.NullValueHandling) == NullValueHandling.Ignore &&
          memberValue == null)
        return false;

      if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer.DefaultValueHandling), DefaultValueHandling.Ignore)
          && MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()))
        return false;

      return true;
    }

    private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
        return true;

      ReferenceLoopHandling? referenceLoopHandling = null;

      if (property != null)
        referenceLoopHandling = property.ReferenceLoopHandling;

      if (referenceLoopHandling == null && containerProperty != null)
        referenceLoopHandling = containerProperty.ItemReferenceLoopHandling;

      if (referenceLoopHandling == null && containerContract != null)
        referenceLoopHandling = containerContract.ItemReferenceLoopHandling;

      if (_serializeStack.IndexOf(value) != -1)
      {
        string message = "Self referencing loop detected";
        if (property != null)
          message += " for property '{0}'".FormatWith(CultureInfo.InvariantCulture, property.PropertyName);
        message += " with type '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType());

        switch (referenceLoopHandling.GetValueOrDefault(Serializer.ReferenceLoopHandling))
        {
          case ReferenceLoopHandling.Error:
            throw JsonSerializationException.Create(null, writer.ContainerPath, message, null);
          case ReferenceLoopHandling.Ignore:
            if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
              TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, message + ". Skipping serializing self referenced value."), null);

            return false;
          case ReferenceLoopHandling.Serialize:
            if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
              TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, message + ". Serializing self referenced value."), null);

            return true;
        }
      }

      return true;
    }

    private void WriteReference(JsonWriter writer, object value)
    {
      string reference = GetReference(writer, value);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, value.GetType())), null);

      writer.WriteStartObject();
      writer.WritePropertyName(JsonTypeReflector.RefPropertyName);
      writer.WriteValue(reference);
      writer.WriteEndObject();
    }

    private string GetReference(JsonWriter writer, object value)
    {
      try
      {
        string reference = Serializer.ReferenceResolver.GetReference(this, value);

        return reference;
      }
      catch (Exception ex)
      {
        throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
      }
    }

    internal static bool TryConvertToString(object value, Type type, out string s)
    {
#if !(PocketPC || NETFX_CORE || PORTABLE)
      TypeConverter converter = ConvertUtils.GetConverter(type);

      // use the objectType's TypeConverter if it has one and can convert to a string
      if (converter != null
#if !SILVERLIGHT
 && !(converter is ComponentConverter)
#endif
 && converter.GetType() != typeof(TypeConverter))
      {
        if (converter.CanConvertTo(typeof(string)))
        {
#if !SILVERLIGHT
          s = converter.ConvertToInvariantString(value);
#else
          s = converter.ConvertToString(value);
#endif
          
          return true;
        }
      }
#endif

#if SILVERLIGHT || PocketPC || NETFX_CORE
      if (value is Guid || value is Uri || value is TimeSpan)
      {
        s = value.ToString();
        return true;
      }
#endif

      if (value is Type)
      {
        s = ((Type)value).AssemblyQualifiedName;
        return true;
      }

      s = null;
      return false;
    }

    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
    {
      OnSerializing(writer, contract, value);

      string s;
      TryConvertToString(value, contract.UnderlyingType, out s);
      writer.WriteValue(s);

      OnSerialized(writer, contract, value);
    }

    private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
    {
      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);

      contract.InvokeOnSerializing(value, Serializer.Context);
    }

    private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
    {
      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
        TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);

      contract.InvokeOnSerialized(value, Serializer.Context);
    }

    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      OnSerializing(writer, contract, value);

      _serializeStack.Add(value);

      WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);

      int initialDepth = writer.Top;

      foreach (JsonProperty property in contract.Properties)
      {
        try
        {
          object memberValue;
          JsonContract memberContract;

          if (!CalculatePropertyValues(writer, value, contract, member, property, out memberContract, out memberValue))
            continue;

          writer.WritePropertyName(property.PropertyName);
          SerializeValue(writer, memberValue, memberContract, property, contract, member);
        }
        catch (Exception ex)
        {
          if (IsErrorHandled(value, contract, property.PropertyName, null, writer.ContainerPath, ex))
            HandleError(writer, initialDepth);
          else
            throw;
        }
      }

      writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);

      OnSerialized(writer, contract, value);
    }

    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, out JsonContract memberContract, out object memberValue)
    {
      if (!property.Ignored && property.Readable && ShouldSerialize(writer, property, value) && IsSpecified(writer, property, value))
      {
        if (property.PropertyContract == null)
          property.PropertyContract = Serializer.ContractResolver.ResolveContract(property.PropertyType);

        memberValue = property.ValueProvider.GetValue(value);
        memberContract = (property.PropertyContract.UnderlyingType.IsSealed()) ? property.PropertyContract : GetContractSafe(memberValue);

        if (ShouldWriteProperty(memberValue, property))
        {
          if (ShouldWriteReference(memberValue, property, memberContract, contract, member))
          {
            writer.WritePropertyName(property.PropertyName);
            WriteReference(writer, memberValue);
            return false;
          }

          if (!CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
            return false;

          if (memberValue == null)
          {
            JsonObjectContract objectContract = contract as JsonObjectContract;
            Required resolvedRequired = property._required ?? ((objectContract != null) ? objectContract.ItemRequired : null) ?? Required.Default;
            if (resolvedRequired == Required.Always)
              throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
          }

          return true;
        }
      }

      memberContract = null;
      memberValue = null;
      return false;
    }

    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      writer.WriteStartObject();

      bool isReference = ResolveIsReference(contract, member, collectionContract, containerProperty) ?? HasFlag(Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Objects);
      if (isReference)
      {
        WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
      }
      if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
      {
        WriteTypeProperty(writer, contract.UnderlyingType);
      }
    }

    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
    {
      string reference = GetReference(writer, value);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
        TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, type)), null);

      writer.WritePropertyName(JsonTypeReflector.IdPropertyName);
      writer.WriteValue(reference);
    }

    private void WriteTypeProperty(JsonWriter writer, Type type)
    {
      string typeName = ReflectionUtils.GetTypeName(type, Serializer.TypeNameAssemblyFormat, Serializer.Binder);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
        TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, typeName, type)), null);

      writer.WritePropertyName(JsonTypeReflector.TypePropertyName);
      writer.WriteValue(typeName);
    }

    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
    {
      return ((value & flag) == flag);
    }

    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
    {
      return ((value & flag) == flag);
    }

    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
    {
      return ((value & flag) == flag);
    }

    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      if (ShouldWriteReference(value, null, contract, collectionContract, containerProperty))
      {
        WriteReference(writer, value);
      }
      else
      {
        if (!CheckForCircularReference(writer, value, null, contract, collectionContract, containerProperty))
          return;

        _serializeStack.Add(value);

        if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
          TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);

        converter.WriteJson(writer, value, GetInternalSerializer());

        if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
          TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);

        _serializeStack.RemoveAt(_serializeStack.Count - 1);
      }
    }

    private void SerializeList(JsonWriter writer, IWrappedCollection values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      OnSerializing(writer, contract, values.UnderlyingCollection);

      _serializeStack.Add(values.UnderlyingCollection);

      bool hasWrittenMetadataObject = WriteStartArray(writer, values.UnderlyingCollection, contract, member, collectionContract, containerProperty);

      writer.WriteStartArray();

      int initialDepth = writer.Top;

      int index = 0;
      // note that an error in the IEnumerable won't be caught
      foreach (object value in values)
      {
        try
        {
          JsonContract valueContract = contract.FinalItemContract ?? GetContractSafe(value);

          if (ShouldWriteReference(value, null, valueContract, contract, member))
          {
            WriteReference(writer, value);
          }
          else
          {
            if (CheckForCircularReference(writer, value, null, valueContract, contract, member))
            {
              SerializeValue(writer, value, valueContract, null, contract, member);
            }
          }
        }
        catch (Exception ex)
        {
          if (IsErrorHandled(values.UnderlyingCollection, contract, index, null, writer.ContainerPath, ex))
            HandleError(writer, initialDepth);
          else
            throw;
        }
        finally
        {
          index++;
        }
      }

      writer.WriteEndArray();

      if (hasWrittenMetadataObject)
        writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);

      OnSerialized(writer, contract, values.UnderlyingCollection);
    }

    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      OnSerializing(writer, contract, values);

      _serializeStack.Add(values);

      bool hasWrittenMetadataObject = WriteStartArray(writer, values, contract, member, collectionContract, containerProperty);

      SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, new int[0]);

      if (hasWrittenMetadataObject)
        writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);

      OnSerialized(writer, contract, values);
    }

    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, int[] indices)
    {
      int dimension = indices.Length;
      int[] newIndices = new int[dimension + 1];
      for (int i = 0; i < dimension; i++)
      {
        newIndices[i] = indices[i];
      }

      writer.WriteStartArray();

      for (int i = 0; i < values.GetLength(dimension); i++)
      {
        newIndices[dimension] = i;
        bool isTopLevel = (newIndices.Length == values.Rank);

        if (isTopLevel)
        {
          object value = values.GetValue(newIndices);

          try
          {
            JsonContract valueContract = contract.FinalItemContract ?? GetContractSafe(value);

            if (ShouldWriteReference(value, null, valueContract, contract, member))
            {
              WriteReference(writer, value);
            }
            else
            {
              if (CheckForCircularReference(writer, value, null, valueContract, contract, member))
              {
                SerializeValue(writer, value, valueContract, null, contract, member);
              }
            }
          }
          catch (Exception ex)
          {
            if (IsErrorHandled(values, contract, i, null, writer.ContainerPath, ex))
              HandleError(writer, initialDepth + 1);
            else
              throw;
          }
        }
        else
        {
          SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, newIndices);
        }
      }

      writer.WriteEndArray();
    }

    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      bool isReference = ResolveIsReference(contract, member, containerContract, containerProperty) ?? HasFlag(Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Arrays);
      bool includeTypeDetails = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract, containerProperty);
      bool writeMetadataObject = isReference || includeTypeDetails;

      if (writeMetadataObject)
      {
        writer.WriteStartObject();

        if (isReference)
        {
          WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
        }
        if (includeTypeDetails)
        {
          WriteTypeProperty(writer, values.GetType());
        }
        writer.WritePropertyName(JsonTypeReflector.ArrayValuesPropertyName);
      }

      if (contract.ItemContract == null)
        contract.ItemContract = Serializer.ContractResolver.ResolveContract(contract.CollectionItemType ?? typeof (object));

      return writeMetadataObject;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
#if !(NET20 || NET35)
    [SecuritySafeCritical]
#endif
    private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      if (!JsonTypeReflector.FullyTrusted)
      {
        throw JsonSerializationException.Create(null, writer.ContainerPath, @"Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data.
To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
      }

      OnSerializing(writer, contract, value);
      _serializeStack.Add(value);

      WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);

      SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
      value.GetObjectData(serializationInfo, Serializer.Context);

      foreach (SerializationEntry serializationEntry in serializationInfo)
      {
        JsonContract valueContract = GetContractSafe(serializationEntry.Value);

        if (CheckForCircularReference(writer, serializationEntry.Value, null, valueContract, contract, member))
        {
          writer.WritePropertyName(serializationEntry.Name);
          SerializeValue(writer, serializationEntry.Value, valueContract, null, contract, member);
        }
      }

      writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);
      OnSerialized(writer, contract, value);
    }
#endif

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      OnSerializing(writer, contract, value);
      _serializeStack.Add(value);

      WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);

      int initialDepth = writer.Top;

      foreach (JsonProperty property in contract.Properties)
      {
        // only write non-dynamic properties that have an explicit attribute
        if (property.HasMemberAttribute)
        {
          try
          {
            object memberValue;
            JsonContract memberContract;

            if (!CalculatePropertyValues(writer, value, contract, member, property, out memberContract, out memberValue))
              continue;

            writer.WritePropertyName(property.PropertyName);
            SerializeValue(writer, memberValue, memberContract, property, contract, member);
          }
          catch (Exception ex)
          {
            if (IsErrorHandled(value, contract, property.PropertyName, null, writer.ContainerPath, ex))
              HandleError(writer, initialDepth);
            else
              throw;
          }
        }
      }

      foreach (string memberName in value.GetDynamicMemberNames())
      {
        object memberValue;
        if (value.TryGetMember(memberName, out memberValue))
        {
          try
          {
            JsonContract valueContract = GetContractSafe(memberValue);

            if (CheckForCircularReference(writer, memberValue, null, valueContract, contract, member))
            {
              string resolvedPropertyName = (contract.PropertyNameResolver != null)
                                              ? contract.PropertyNameResolver(memberName)
                                              : memberName;

              writer.WritePropertyName(resolvedPropertyName);
              SerializeValue(writer, memberValue, valueContract, null, contract, member);
            }
          }
          catch (Exception ex)
          {
            if (IsErrorHandled(value, contract, memberName, null, writer.ContainerPath, ex))
              HandleError(writer, initialDepth);
            else
              throw;
          }
        }
      }

      writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);
      OnSerialized(writer, contract, value);
    }
#endif

    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
    {
      TypeNameHandling resolvedTypeNameHandling =
        ((member != null) ? member.TypeNameHandling : null)
        ?? ((containerProperty != null) ? containerProperty.ItemTypeNameHandling : null)
        ?? ((containerContract != null) ? containerContract.ItemTypeNameHandling : null)
        ?? Serializer.TypeNameHandling;

      if (HasFlag(resolvedTypeNameHandling, typeNameHandlingFlag))
        return true;

      // instance type and the property's type's contract default type are different (no need to put the type in JSON because the type will be created by default)
      if (HasFlag(resolvedTypeNameHandling, TypeNameHandling.Auto))
      {
        if (member != null)
        {
          if (contract.UnderlyingType != member.PropertyContract.CreatedType)
            return true;
        }
        else if (containerContract != null && containerContract.ItemContract != null)
        {
          if (contract.UnderlyingType != containerContract.ItemContract.CreatedType)
            return true;
        }
      }

      return false;
    }

    private void SerializeDictionary(JsonWriter writer, IWrappedDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
    {
      OnSerializing(writer, contract, values.UnderlyingDictionary);
      _serializeStack.Add(values.UnderlyingDictionary);

      WriteObjectStart(writer, values.UnderlyingDictionary, contract, member, collectionContract, containerProperty);

      if (contract.ItemContract == null)
        contract.ItemContract = Serializer.ContractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));

      int initialDepth = writer.Top;

      // Mono Unity 3.0 fix
      IWrappedDictionary d = values;

      foreach (DictionaryEntry entry in d)
      {
        string propertyName = GetPropertyName(entry);

        propertyName = (contract.PropertyNameResolver != null)
                         ? contract.PropertyNameResolver(propertyName)
                         : propertyName;

        try
        {
          object value = entry.Value;
          JsonContract valueContract = contract.FinalItemContract ?? GetContractSafe(value);

          if (ShouldWriteReference(value, null, valueContract, contract, member))
          {
            writer.WritePropertyName(propertyName);
            WriteReference(writer, value);
          }
          else
          {
            if (!CheckForCircularReference(writer, value, null, valueContract, contract, member))
              continue;

            writer.WritePropertyName(propertyName);

            SerializeValue(writer, value, valueContract, null, contract, member);
          }
        }
        catch (Exception ex)
        {
          if (IsErrorHandled(values.UnderlyingDictionary, contract, propertyName, null, writer.ContainerPath, ex))
            HandleError(writer, initialDepth);
          else
            throw;
        }
      }

      writer.WriteEndObject();

      _serializeStack.RemoveAt(_serializeStack.Count - 1);

      OnSerialized(writer, contract, values.UnderlyingDictionary);
    }

    private string GetPropertyName(DictionaryEntry entry)
    {
      string propertyName;

      if (ConvertUtils.IsConvertible(entry.Key))
        return Convert.ToString(entry.Key, CultureInfo.InvariantCulture);
      else if (TryConvertToString(entry.Key, entry.Key.GetType(), out propertyName))
        return propertyName;
      else
        return entry.Key.ToString();
    }

    private void HandleError(JsonWriter writer, int initialDepth)
    {
      ClearErrorContext();

      if (writer.WriteState == WriteState.Property)
        writer.WriteNull();

      while (writer.Top > initialDepth)
      {
        writer.WriteEnd();
      }
    }

    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
    {
      if (property.ShouldSerialize == null)
        return true;

      bool shouldSerialize = property.ShouldSerialize(target);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
        TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, shouldSerialize)), null);

      return shouldSerialize;
    }

    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
    {
      if (property.GetIsSpecified == null)
        return true;

      bool isSpecified = property.GetIsSpecified(target);

      if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
        TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, isSpecified)), null);

      return isSpecified;
    }
  }
}
#endregion Serialization_JsonSerializerInternalWriter.cs

/// ********   File: \Serialization\JsonSerializerProxy.cs
#region Serialization_JsonSerializerProxy.cs

namespace Newtonsoft.Json.Serialization
{
  internal class JsonSerializerProxy : JsonSerializer
  {
    private readonly JsonSerializerInternalReader _serializerReader;
    private readonly JsonSerializerInternalWriter _serializerWriter;
    private readonly JsonSerializer _serializer;

    public override event EventHandler<ErrorEventArgs> Error
    {
      add { _serializer.Error += value; }
      remove { _serializer.Error -= value; }
    }

    public override IReferenceResolver ReferenceResolver
    {
      get { return _serializer.ReferenceResolver; }
      set { _serializer.ReferenceResolver = value; }
    }

    public override ITraceWriter TraceWriter
    {
      get { return _serializer.TraceWriter; }
      set { _serializer.TraceWriter = value; }
    }

    public override JsonConverterCollection Converters
    {
      get { return _serializer.Converters; }
    }

    public override DefaultValueHandling DefaultValueHandling
    {
      get { return _serializer.DefaultValueHandling; }
      set { _serializer.DefaultValueHandling = value; }
    }

    public override IContractResolver ContractResolver
    {
      get { return _serializer.ContractResolver; }
      set { _serializer.ContractResolver = value; }
    }

    public override MissingMemberHandling MissingMemberHandling
    {
      get { return _serializer.MissingMemberHandling; }
      set { _serializer.MissingMemberHandling = value; }
    }

    public override NullValueHandling NullValueHandling
    {
      get { return _serializer.NullValueHandling; }
      set { _serializer.NullValueHandling = value; }
    }

    public override ObjectCreationHandling ObjectCreationHandling
    {
      get { return _serializer.ObjectCreationHandling; }
      set { _serializer.ObjectCreationHandling = value; }
    }

    public override ReferenceLoopHandling ReferenceLoopHandling
    {
      get { return _serializer.ReferenceLoopHandling; }
      set { _serializer.ReferenceLoopHandling = value; }
    }

    public override PreserveReferencesHandling PreserveReferencesHandling
    {
      get { return _serializer.PreserveReferencesHandling; }
      set { _serializer.PreserveReferencesHandling = value; }
    }

    public override TypeNameHandling TypeNameHandling
    {
      get { return _serializer.TypeNameHandling; }
      set { _serializer.TypeNameHandling = value; }
    }

    public override FormatterAssemblyStyle TypeNameAssemblyFormat
    {
      get { return _serializer.TypeNameAssemblyFormat; }
      set { _serializer.TypeNameAssemblyFormat = value; }
    }

    public override ConstructorHandling ConstructorHandling
    {
      get { return _serializer.ConstructorHandling; }
      set { _serializer.ConstructorHandling = value; }
    }

    public override SerializationBinder Binder
    {
      get { return _serializer.Binder; }
      set { _serializer.Binder = value; }
    }

    public override StreamingContext Context
    {
      get { return _serializer.Context; }
      set { _serializer.Context = value; }
    }

    public override Formatting Formatting
    {
      get { return _serializer.Formatting; }
      set { _serializer.Formatting = value; }
    }

    public override DateFormatHandling DateFormatHandling
    {
      get { return _serializer.DateFormatHandling; }
      set { _serializer.DateFormatHandling = value; }
    }

    public override DateTimeZoneHandling DateTimeZoneHandling
    {
      get { return _serializer.DateTimeZoneHandling; }
      set { _serializer.DateTimeZoneHandling = value; }
    }

    public override DateParseHandling DateParseHandling
    {
      get { return _serializer.DateParseHandling; }
      set { _serializer.DateParseHandling = value; }
    }

    public override CultureInfo Culture
    {
      get { return _serializer.Culture; }
      set { _serializer.Culture = value; }
    }

    public override int? MaxDepth
    {
      get { return _serializer.MaxDepth; }
      set { _serializer.MaxDepth = value; }
    }

    public override bool CheckAdditionalContent
    {
      get { return _serializer.CheckAdditionalContent; }
      set { _serializer.CheckAdditionalContent = value; }
    }

    internal JsonSerializerInternalBase GetInternalSerializer()
    {
      if (_serializerReader != null)
        return _serializerReader;
      else
        return _serializerWriter;
    }

    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
    {
      ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");

      _serializerReader = serializerReader;
      _serializer = serializerReader.Serializer;
    }

    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
    {
      ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");

      _serializerWriter = serializerWriter;
      _serializer = serializerWriter.Serializer;
    }

    internal override object DeserializeInternal(JsonReader reader, Type objectType)
    {
      if (_serializerReader != null)
        return _serializerReader.Deserialize(reader, objectType, false);
      else
        return _serializer.Deserialize(reader, objectType);
    }

    internal override void PopulateInternal(JsonReader reader, object target)
    {
      if (_serializerReader != null)
        _serializerReader.Populate(reader, target);
      else
        _serializer.Populate(reader, target);
    }

    internal override void SerializeInternal(JsonWriter jsonWriter, object value)
    {
      if (_serializerWriter != null)
        _serializerWriter.Serialize(jsonWriter, value);
      else
        _serializer.Serialize(jsonWriter, value);
    }
  }
}
#endregion Serialization_JsonSerializerProxy.cs

/// ********   File: \Serialization\JsonStringContract.cs
#region Serialization_JsonStringContract.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Contract details for a <see cref="Type"/> used by the <see cref="JsonSerializer"/>.
  /// </summary>
  public class JsonStringContract : JsonPrimitiveContract
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonStringContract"/> class.
    /// </summary>
    /// <param name="underlyingType">The underlying type for the contract.</param>
    public JsonStringContract(Type underlyingType)
      : base(underlyingType)
    {
      ContractType = JsonContractType.String;
    }
  }
}
#endregion Serialization_JsonStringContract.cs

/// ********   File: \Serialization\JsonTypeReflector.cs
#region Serialization_JsonTypeReflector.cs

#if !(NETFX_CORE || PORTABLE)
#endif
#if NETFX_CORE || PORTABLE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Serialization
{
#if !SILVERLIGHT && !PocketPC && !NET20 && !NETFX_CORE
  internal interface IMetadataTypeAttribute
  {
    Type MetadataClassType { get; }
  }
#endif

  internal static class JsonTypeReflector
  {
    public const string IdPropertyName = "$id";
    public const string RefPropertyName = "$ref";
    public const string TypePropertyName = "$type";
    public const string ValuePropertyName = "$value";
    public const string ArrayValuesPropertyName = "$values";

    public const string ShouldSerializePrefix = "ShouldSerialize";
    public const string SpecifiedPostfix = "Specified";

    private static readonly ThreadSafeStore<ICustomAttributeProvider, Type> JsonConverterTypeCache = new ThreadSafeStore<ICustomAttributeProvider, Type>(GetJsonConverterTypeFromAttribute);
#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
    private static readonly ThreadSafeStore<Type, Type> AssociatedMetadataTypesCache = new ThreadSafeStore<Type, Type>(GetAssociateMetadataTypeFromAttribute);

    private const string MetadataTypeAttributeTypeName =
      "System.ComponentModel.DataAnnotations.MetadataTypeAttribute, System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    private static Type _cachedMetadataTypeAttributeType;
#endif
#if SILVERLIGHT
    private static readonly ThreadSafeStore<ICustomAttributeProvider, Type> TypeConverterTypeCache = new ThreadSafeStore<ICustomAttributeProvider, Type>(GetTypeConverterTypeFromAttribute);

    private static Type GetTypeConverterTypeFromAttribute(ICustomAttributeProvider attributeProvider)
    {
      TypeConverterAttribute converterAttribute = GetAttribute<TypeConverterAttribute>(attributeProvider);
      if (converterAttribute == null)
        return null;

      return Type.GetType(converterAttribute.ConverterTypeName);
    }

    private static Type GetTypeConverterType(ICustomAttributeProvider attributeProvider)
    {
      return TypeConverterTypeCache.Get(attributeProvider);
    }
#endif

    public static JsonContainerAttribute GetJsonContainerAttribute(Type type)
    {
      return CachedAttributeGetter<JsonContainerAttribute>.GetAttribute(type.GetCustomAttributeProvider());
    }

    public static JsonObjectAttribute GetJsonObjectAttribute(Type type)
    {
      return GetJsonContainerAttribute(type) as JsonObjectAttribute;
    }

    public static JsonArrayAttribute GetJsonArrayAttribute(Type type)
    {
      return GetJsonContainerAttribute(type) as JsonArrayAttribute;
    }

    public static JsonDictionaryAttribute GetJsonDictionaryAttribute(Type type)
    {
      return GetJsonContainerAttribute(type) as JsonDictionaryAttribute;
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    public static SerializableAttribute GetSerializableAttribute(Type type)
    {
      return CachedAttributeGetter<SerializableAttribute>.GetAttribute(type.GetCustomAttributeProvider());
    }
#endif

#if !PocketPC && !NET20
    public static DataContractAttribute GetDataContractAttribute(Type type)
    {
      // DataContractAttribute does not have inheritance
      Type currentType = type;

      while (currentType != null)
      {
        DataContractAttribute result = CachedAttributeGetter<DataContractAttribute>.GetAttribute(currentType.GetCustomAttributeProvider());
        if (result != null)
          return result;

        currentType = currentType.BaseType();
      }

      return null;
    }

    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
    {
      // DataMemberAttribute does not have inheritance

      // can't override a field
      if (memberInfo.MemberType() == MemberTypes.Field)
        return CachedAttributeGetter<DataMemberAttribute>.GetAttribute(memberInfo.GetCustomAttributeProvider());

      // search property and then search base properties if nothing is returned and the property is virtual
      PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
      DataMemberAttribute result = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo.GetCustomAttributeProvider());
      if (result == null)
      {
        if (propertyInfo.IsVirtual())
        {
          Type currentType = propertyInfo.DeclaringType;

          while (result == null && currentType != null)
          {
            PropertyInfo baseProperty = (PropertyInfo)ReflectionUtils.GetMemberInfoFromType(currentType, propertyInfo);
            if (baseProperty != null && baseProperty.IsVirtual())
              result = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(baseProperty.GetCustomAttributeProvider());

            currentType = currentType.BaseType();
          }
        }
      }

      return result;
    }
#endif

    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
    {
      JsonObjectAttribute objectAttribute = GetJsonObjectAttribute(objectType);
      if (objectAttribute != null)
        return objectAttribute.MemberSerialization;

#if !PocketPC && !NET20
      DataContractAttribute dataContractAttribute = GetDataContractAttribute(objectType);
      if (dataContractAttribute != null)
        return MemberSerialization.OptIn;
#endif

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (!ignoreSerializableAttribute)
      {
        SerializableAttribute serializableAttribute = GetSerializableAttribute(objectType);
        if (serializableAttribute != null)
          return MemberSerialization.Fields;
      }
#endif

      // the default
      return MemberSerialization.OptOut;
    }

    private static Type GetJsonConverterType(ICustomAttributeProvider attributeProvider)
    {
      return JsonConverterTypeCache.Get(attributeProvider);
    }

    private static Type GetJsonConverterTypeFromAttribute(ICustomAttributeProvider attributeProvider)
    {
      JsonConverterAttribute converterAttribute = GetAttribute<JsonConverterAttribute>(attributeProvider);
      return (converterAttribute != null)
        ? converterAttribute.ConverterType
        : null;
    }

    public static JsonConverter GetJsonConverter(ICustomAttributeProvider attributeProvider, Type targetConvertedType)
    {
      object provider = null;
#if !(NETFX_CORE || PORTABLE)
      provider = attributeProvider as MemberInfo;
#else
      provider = attributeProvider.UnderlyingObject;
#endif

      Type converterType = GetJsonConverterType(attributeProvider);

      if (converterType != null)
      {
        JsonConverter memberConverter = JsonConverterAttribute.CreateJsonConverterInstance(converterType);

        return memberConverter;
      }

      return null;
    }

#if !(NETFX_CORE || PORTABLE)
#if !PocketPC
    public static TypeConverter GetTypeConverter(Type type)
    {
#if !SILVERLIGHT
      return TypeDescriptor.GetConverter(type);
#else
      Type converterType = GetTypeConverterType(type);

      if (converterType != null)
        return (TypeConverter)ReflectionUtils.CreateInstance(converterType);

      return null;
#endif
#endif
    }
#endif

#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
    private static Type GetAssociatedMetadataType(Type type)
    {
      return AssociatedMetadataTypesCache.Get(type);
    }

    private static Type GetAssociateMetadataTypeFromAttribute(Type type)
    {
      Type metadataTypeAttributeType = GetMetadataTypeAttributeType();
      if (metadataTypeAttributeType == null)
        return null;

      object attribute = type.GetCustomAttributes(metadataTypeAttributeType, true).SingleOrDefault();
      if (attribute == null)
        return null;

      IMetadataTypeAttribute metadataTypeAttribute = (DynamicCodeGeneration)
                                                       ? DynamicWrapper.CreateWrapper<IMetadataTypeAttribute>(attribute)
                                                       : new LateBoundMetadataTypeAttribute(attribute);

      return metadataTypeAttribute.MetadataClassType;
    }

    private static Type GetMetadataTypeAttributeType()
    {
      // always attempt to get the metadata type attribute type
      // the assembly may have been loaded since last time
      if (_cachedMetadataTypeAttributeType == null)
      {
        Type metadataTypeAttributeType = Type.GetType(MetadataTypeAttributeTypeName);

        if (metadataTypeAttributeType != null)
          _cachedMetadataTypeAttributeType = metadataTypeAttributeType;
        else
          return null;
      }

      return _cachedMetadataTypeAttributeType;
    }
#endif

    private static T GetAttribute<T>(Type type) where T : Attribute
    {
      T attribute;

#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
      Type metadataType = GetAssociatedMetadataType(type);
      if (metadataType != null)
      {
        attribute = ReflectionUtils.GetAttribute<T>(metadataType, true);
        if (attribute != null)
          return attribute;
      }
#endif

      attribute = ReflectionUtils.GetAttribute<T>(type.GetCustomAttributeProvider(), true);
      if (attribute != null)
        return attribute;

      foreach (Type typeInterface in type.GetInterfaces())
      {
        attribute = ReflectionUtils.GetAttribute<T>(typeInterface.GetCustomAttributeProvider(), true);
        if (attribute != null)
          return attribute;
      }

      return null;
    }

    private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
    {
      T attribute;

#if !(SILVERLIGHT || NET20 || NETFX_CORE || PORTABLE)
      Type metadataType = GetAssociatedMetadataType(memberInfo.DeclaringType);
      if (metadataType != null)
      {
        MemberInfo metadataTypeMemberInfo = ReflectionUtils.GetMemberInfoFromType(metadataType, memberInfo);

        if (metadataTypeMemberInfo != null)
        {
          attribute = ReflectionUtils.GetAttribute<T>(metadataTypeMemberInfo, true);
          if (attribute != null)
            return attribute;
        }
      }
#endif

      attribute = ReflectionUtils.GetAttribute<T>(memberInfo.GetCustomAttributeProvider(), true);
      if (attribute != null)
        return attribute;

      if (memberInfo.DeclaringType != null)
      {
        foreach (Type typeInterface in memberInfo.DeclaringType.GetInterfaces())
        {
          MemberInfo interfaceTypeMemberInfo = ReflectionUtils.GetMemberInfoFromType(typeInterface, memberInfo);

          if (interfaceTypeMemberInfo != null)
          {
            attribute = ReflectionUtils.GetAttribute<T>(interfaceTypeMemberInfo.GetCustomAttributeProvider(), true);
            if (attribute != null)
              return attribute;
          }
        }
      }

      return null;
    }

    public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider) where T : Attribute
    {
      object provider = null;
#if !(NETFX_CORE || PORTABLE)
      provider = attributeProvider;
#else
      provider = attributeProvider.UnderlyingObject;
#endif

      Type type = provider as Type;
      if (type != null)
        return GetAttribute<T>(type);

      MemberInfo memberInfo = provider as MemberInfo;
      if (memberInfo != null)
        return GetAttribute<T>(memberInfo);

      return ReflectionUtils.GetAttribute<T>(attributeProvider, true);
    }

    private static bool? _dynamicCodeGeneration;
    private static bool? _fullyTrusted;

#if DEBUG
    internal static void SetFullyTrusted(bool fullyTrusted)
    {
      _fullyTrusted = fullyTrusted;
    }

    internal static void SetDynamicCodeGeneration(bool dynamicCodeGeneration)
    {
      _dynamicCodeGeneration = dynamicCodeGeneration;
    }
#endif

    public static bool DynamicCodeGeneration
    {
#if !(NET20 || NET35 || SILVERLIGHT || NETFX_CORE || PORTABLE)
      [SecuritySafeCritical]
#endif
      get
      {
        if (_dynamicCodeGeneration == null)
        {
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
          try
          {
            new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Demand();
            new ReflectionPermission(ReflectionPermissionFlag.RestrictedMemberAccess).Demand();
            new SecurityPermission(SecurityPermissionFlag.SkipVerification).Demand();
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            new SecurityPermission(PermissionState.Unrestricted).Demand();
            _dynamicCodeGeneration = true;
          }
          catch (Exception)
          {
            _dynamicCodeGeneration = false;
          }
#else
          _dynamicCodeGeneration = false;
#endif
        }

        return _dynamicCodeGeneration.Value;
      }
    }

    public static bool FullyTrusted
    {
      get
      {
        if (_fullyTrusted == null)
        {
#if (NETFX_CORE || SILVERLIGHT || PORTABLE)
          _fullyTrusted = false;
#elif !(NET20 || NET35)
          AppDomain appDomain = AppDomain.CurrentDomain;

          _fullyTrusted = appDomain.IsHomogenous && appDomain.IsFullyTrusted;
#else
          try
          {
            new SecurityPermission(PermissionState.Unrestricted).Demand();
            _fullyTrusted = true;
          }
          catch (Exception)
          {
            _fullyTrusted = false;
          }
#endif
        }

        return _fullyTrusted.Value;
      }
    }

    public static ReflectionDelegateFactory ReflectionDelegateFactory
    {
      get
      {
#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)
        if (DynamicCodeGeneration)
          return DynamicReflectionDelegateFactory.Instance;
#endif

        return LateBoundReflectionDelegateFactory.Instance;
      }
    }
  }
}
#endregion Serialization_JsonTypeReflector.cs

/// ********   File: \Serialization\LateBoundMetadataTypeAttribute.cs
#region Serialization_LateBoundMetadataTypeAttribute.cs

#if !SILVERLIGHT && !PocketPC && !NET20 && !NETFX_CORE

namespace Newtonsoft.Json.Serialization
{
  internal class LateBoundMetadataTypeAttribute : IMetadataTypeAttribute
  {
    private static PropertyInfo _metadataClassTypeProperty;

    private readonly object _attribute;

    public LateBoundMetadataTypeAttribute(object attribute)
    {
      _attribute = attribute;
    }

    public Type MetadataClassType
    {
      get
      {
        if (_metadataClassTypeProperty == null)
          _metadataClassTypeProperty = _attribute.GetType().GetProperty("MetadataClassType");

        return (Type)ReflectionUtils.GetMemberValue(_metadataClassTypeProperty, _attribute);
      }
    }
  }
}
#endif
#endregion Serialization_LateBoundMetadataTypeAttribute.cs

/// ********   File: \Serialization\MemoryTraceWriter.cs
#region Serialization_MemoryTraceWriter.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Represents a trace writer that writes to memory. When the trace message limit is
  /// reached then old trace messages will be removed as new messages are added.
  /// </summary>
  public class MemoryTraceWriter : ITraceWriter
  {
    private readonly Queue<string> _traceMessages;

    /// <summary>
    /// Gets the <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.
    /// For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
    /// <code>Warning</code> and <code>Error</code> messages.
    /// </summary>
    /// <value>
    /// The <see cref="TraceLevel"/> that will be used to filter the trace messages passed to the writer.
    /// </value>
    public TraceLevel LevelFilter { get; set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="MemoryTraceWriter"/> class.
    /// </summary>
    public MemoryTraceWriter()
    {
      LevelFilter = TraceLevel.Verbose;
      _traceMessages = new Queue<string>();
    }

    /// <summary>
    /// Writes the specified trace level, message and optional exception.
    /// </summary>
    /// <param name="level">The <see cref="TraceLevel"/> at which to write this trace.</param>
    /// <param name="message">The trace message.</param>
    /// <param name="ex">The trace exception. This parameter is optional.</param>
    public void Trace(TraceLevel level, string message, Exception ex)
    {
      string traceMessage = DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", CultureInfo.InvariantCulture) + " " + level.ToString("g") + " " + message;

      if (_traceMessages.Count >= 1000)
        _traceMessages.Dequeue();

      _traceMessages.Enqueue(traceMessage);
    }

    /// <summary>
    /// Returns an enumeration of the most recent trace messages.
    /// </summary>
    /// <returns>An enumeration of the most recent trace messages.</returns>
    public IEnumerable<string> GetTraceMessages()
    {
      return _traceMessages;
    }

    /// <summary>
    /// Returns a <see cref="String"/> of the most recent trace messages.
    /// </summary>
    /// <returns>
    /// A <see cref="String"/> of the most recent trace messages.
    /// </returns>
    public override string ToString()
    {
      StringBuilder sb = new StringBuilder();
      foreach (string traceMessage in _traceMessages)
      {
        if (sb.Length > 0)
          sb.AppendLine();

        sb.Append(traceMessage);
      }

      return sb.ToString();
    }
  }
}
#endregion Serialization_MemoryTraceWriter.cs

/// ********   File: \Serialization\ObjectConstructor.cs
#region Serialization_ObjectConstructor.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Represents a method that constructs an object.
  /// </summary>
  /// <typeparam name="T">The object type to create.</typeparam>
  public delegate object ObjectConstructor<T>(params object[] args);
}
#endregion Serialization_ObjectConstructor.cs

/// ********   File: \Serialization\OnErrorAttribute.cs
#region Serialization_OnErrorAttribute.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// When applied to a method, specifies that the method is called when an error occurs serializing an object.
  /// </summary>
  [AttributeUsage(AttributeTargets.Method, Inherited = false)]
  public sealed class OnErrorAttribute : Attribute
  {
  }
}
#endregion Serialization_OnErrorAttribute.cs

/// ********   File: \Serialization\ReflectionValueProvider.cs
#region Serialization_ReflectionValueProvider.cs

namespace Newtonsoft.Json.Serialization
{
  /// <summary>
  /// Get and set values for a <see cref="MemberInfo"/> using reflection.
  /// </summary>
  public class ReflectionValueProvider : IValueProvider
  {
    private readonly MemberInfo _memberInfo;

    /// <summary>
    /// Initializes a new instance of the <see cref="ReflectionValueProvider"/> class.
    /// </summary>
    /// <param name="memberInfo">The member info.</param>
    public ReflectionValueProvider(MemberInfo memberInfo)
    {
      ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
      _memberInfo = memberInfo;
    }

    /// <summary>
    /// Sets the value.
    /// </summary>
    /// <param name="target">The target to set the value on.</param>
    /// <param name="value">The value to set on the target.</param>
    public void SetValue(object target, object value)
    {
      try
      {
        ReflectionUtils.SetMemberValue(_memberInfo, target, value);
      }
      catch (Exception ex)
      {
        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), ex);
      }
    }

    /// <summary>
    /// Gets the value.
    /// </summary>
    /// <param name="target">The target to get the value from.</param>
    /// <returns>The value.</returns>
    public object GetValue(object target)
    {
      try
      {
        return ReflectionUtils.GetMemberValue(_memberInfo, target);
      }
      catch (Exception ex)
      {
        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), ex);
      }
    }
  }
}
#endregion Serialization_ReflectionValueProvider.cs

/// ********   File: \Utilities\Base64Encoder.cs
#region Utilities_Base64Encoder.cs

namespace Newtonsoft.Json.Utilities
{
  internal class Base64Encoder
  {
    private const int Base64LineSize = 76;
    private const int LineSizeInBytes = 57;

    private readonly char[] _charsLine = new char[Base64LineSize];
    private readonly TextWriter _writer;

    private byte[] _leftOverBytes;
    private int _leftOverBytesCount;

    public Base64Encoder(TextWriter writer)
    {
      ValidationUtils.ArgumentNotNull(writer, "writer");
      _writer = writer;
    }

    public void Encode(byte[] buffer, int index, int count)
    {
      if (buffer == null)
        throw new ArgumentNullException("buffer");

      if (index < 0)
        throw new ArgumentOutOfRangeException("index");

      if (count < 0)
        throw new ArgumentOutOfRangeException("count");

      if (count > (buffer.Length - index))
        throw new ArgumentOutOfRangeException("count");

      if (_leftOverBytesCount > 0)
      {
        int leftOverBytesCount = _leftOverBytesCount;
        while (leftOverBytesCount < 3 && count > 0)
        {
          _leftOverBytes[leftOverBytesCount++] = buffer[index++];
          count--;
        }
        if (count == 0 && leftOverBytesCount < 3)
        {
          _leftOverBytesCount = leftOverBytesCount;
          return;
        }
        int num2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
        WriteChars(_charsLine, 0, num2);
      }
      _leftOverBytesCount = count % 3;
      if (_leftOverBytesCount > 0)
      {
        count -= _leftOverBytesCount;
        if (_leftOverBytes == null)
        {
          _leftOverBytes = new byte[3];
        }
        for (int i = 0; i < _leftOverBytesCount; i++)
        {
          _leftOverBytes[i] = buffer[(index + count) + i];
        }
      }
      int num4 = index + count;
      int length = LineSizeInBytes;
      while (index < num4)
      {
        if ((index + length) > num4)
        {
          length = num4 - index;
        }
        int num6 = Convert.ToBase64CharArray(buffer, index, length, _charsLine, 0);
        WriteChars(_charsLine, 0, num6);
        index += length;
      }
    }

    public void Flush()
    {
      if (_leftOverBytesCount > 0)
      {
        int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
        WriteChars(_charsLine, 0, count);
        _leftOverBytesCount = 0;
      }
    }

    private void WriteChars(char[] chars, int index, int count)
    {
      _writer.Write(chars, index, count);
    }
  }
}
#endregion Utilities_Base64Encoder.cs

/// ********   File: \Utilities\BidirectionalDictionary.cs
#region Utilities_BidirectionalDictionary.cs

namespace Newtonsoft.Json.Utilities
{
  internal class BidirectionalDictionary<TFirst, TSecond>
  {
    private readonly IDictionary<TFirst, TSecond> _firstToSecond;
    private readonly IDictionary<TSecond, TFirst> _secondToFirst;
    private readonly string _duplicateFirstErrorMessage;
    private readonly string _duplicateSecondErrorMessage;

    public BidirectionalDictionary()
      : this(EqualityComparer<TFirst>.Default, EqualityComparer<TSecond>.Default)
    {
    }

    public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
      : this(
          firstEqualityComparer,
          secondEqualityComparer,
          "Duplicate item already exists for '{0}'.",
          "Duplicate item already exists for '{0}'.")
    {
    }

    public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer,
      string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
    {
      _firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
      _secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
      _duplicateFirstErrorMessage = duplicateFirstErrorMessage;
      _duplicateSecondErrorMessage = duplicateSecondErrorMessage;
    }

    public void Set(TFirst first, TSecond second)
    {
      TFirst existingFirst;
      TSecond existingSecond;

      if (_firstToSecond.TryGetValue(first, out existingSecond))
      {
        if (!existingSecond.Equals(second))
          throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
      }

      if (_secondToFirst.TryGetValue(second, out existingFirst))
      {
        if (!existingFirst.Equals(first))
          throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
      }

      _firstToSecond.Add(first, second);
      _secondToFirst.Add(second, first);
    }

    public bool TryGetByFirst(TFirst first, out TSecond second)
    {
      return _firstToSecond.TryGetValue(first, out second);
    }

    public bool TryGetBySecond(TSecond second, out TFirst first)
    {
      return _secondToFirst.TryGetValue(second, out first);
    }
  }
}
#endregion Utilities_BidirectionalDictionary.cs

/// ********   File: \Utilities\CollectionUtils.cs
#region Utilities_CollectionUtils.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal static class CollectionUtils
  {
    public static IEnumerable<T> CastValid<T>(this IEnumerable enumerable)
    {
      ValidationUtils.ArgumentNotNull(enumerable, "enumerable");

      return enumerable.Cast<object>().Where(o => o is T).Cast<T>();
    }

    /// <summary>
    /// Determines whether the collection is null or empty.
    /// </summary>
    /// <param name="collection">The collection.</param>
    /// <returns>
    /// 	<c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsNullOrEmpty<T>(ICollection<T> collection)
    {
      if (collection != null)
      {
        return (collection.Count == 0);
      }
      return true;
    }

    /// <summary>
    /// Adds the elements of the specified collection to the specified generic IList.
    /// </summary>
    /// <param name="initial">The list to add to.</param>
    /// <param name="collection">The collection of elements to add.</param>
    public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
    {
      if (initial == null)
        throw new ArgumentNullException("initial");

      if (collection == null)
        return;

      foreach (T value in collection)
      {
        initial.Add(value);
      }
    }

    public static void AddRange(this IList initial, IEnumerable collection)
    {
      ValidationUtils.ArgumentNotNull(initial, "initial");

      ListWrapper<object> wrapper = new ListWrapper<object>(initial);
      wrapper.AddRange(collection.Cast<object>());
    }

    public static IList CreateGenericList(Type listType)
    {
      ValidationUtils.ArgumentNotNull(listType, "listType");

      return (IList)ReflectionUtils.CreateGeneric(typeof(List<>), listType);
    }

    public static bool IsDictionaryType(Type type)
    {
      ValidationUtils.ArgumentNotNull(type, "type");

      if (typeof(IDictionary).IsAssignableFrom(type))
        return true;
      if (ReflectionUtils.ImplementsGenericDefinition(type, typeof (IDictionary<,>)))
        return true;

      return false;
    }

    public static IWrappedCollection CreateCollectionWrapper(object list)
    {
      ValidationUtils.ArgumentNotNull(list, "list");

      Type collectionDefinition;
      if (ReflectionUtils.ImplementsGenericDefinition(list.GetType(), typeof(ICollection<>), out collectionDefinition))
      {
        Type collectionItemType = ReflectionUtils.GetCollectionItemType(collectionDefinition);

        // Activator.CreateInstance throws AmbiguousMatchException. Manually invoke constructor
        Func<Type, IList<object>, object> instanceCreator = (t, a) =>
        {
          ConstructorInfo c = t.GetConstructor(new[] { collectionDefinition });
          return c.Invoke(new[] { list });
        };

        return (IWrappedCollection)ReflectionUtils.CreateGeneric(typeof(CollectionWrapper<>), new[] { collectionItemType }, instanceCreator, list);
      }
      else if (list is IList)
      {
        return new CollectionWrapper<object>((IList)list);
      }
      else
      {
        throw new ArgumentException("Can not create ListWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture, list.GetType()), "list");
      }
    }

    public static IWrappedDictionary CreateDictionaryWrapper(object dictionary)
    {
      ValidationUtils.ArgumentNotNull(dictionary, "dictionary");

      Type dictionaryDefinition;
      if (ReflectionUtils.ImplementsGenericDefinition(dictionary.GetType(), typeof(IDictionary<,>), out dictionaryDefinition))
      {
        Type dictionaryKeyType = ReflectionUtils.GetDictionaryKeyType(dictionaryDefinition);
        Type dictionaryValueType = ReflectionUtils.GetDictionaryValueType(dictionaryDefinition);

        // Activator.CreateInstance throws AmbiguousMatchException. Manually invoke constructor
        Func<Type, IList<object>, object> instanceCreator = (t, a) =>
        {
          ConstructorInfo c = t.GetConstructor(new[] { dictionaryDefinition });
          return c.Invoke(new[] { dictionary });
        };

        return (IWrappedDictionary)ReflectionUtils.CreateGeneric(typeof(DictionaryWrapper<,>), new[] { dictionaryKeyType, dictionaryValueType }, instanceCreator, dictionary);
      }
      else if (dictionary is IDictionary)
      {
        return new DictionaryWrapper<object, object>((IDictionary)dictionary);
      }
      else
      {
        throw new ArgumentException("Can not create DictionaryWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture, dictionary.GetType()), "dictionary");
      }
    }

    public static IList CreateList(Type listType, out bool isReadOnlyOrFixedSize)
    {
      ValidationUtils.ArgumentNotNull(listType, "listType");

      IList list;
      Type collectionType;
      isReadOnlyOrFixedSize = false;

      if (listType.IsArray)
      {
        // have to use an arraylist when creating array
        // there is no way to know the size until it is finised
        list = new List<object>();
        isReadOnlyOrFixedSize = true;
      }
      else if (ReflectionUtils.InheritsGenericDefinition(listType, typeof(ReadOnlyCollection<>), out collectionType))
      {
        Type readOnlyCollectionContentsType = collectionType.GetGenericArguments()[0];
        Type genericEnumerable = ReflectionUtils.MakeGenericType(typeof(IEnumerable<>), readOnlyCollectionContentsType);
        bool suitableConstructor = false;

        foreach (ConstructorInfo constructor in listType.GetConstructors())
        {
          IList<ParameterInfo> parameters = constructor.GetParameters();

          if (parameters.Count == 1)
          {
            if (genericEnumerable.IsAssignableFrom(parameters[0].ParameterType))
            {
              suitableConstructor = true;
              break;
            }
          }
        }

        if (!suitableConstructor)
          throw new Exception("Read-only type {0} does not have a public constructor that takes a type that implements {1}.".FormatWith(CultureInfo.InvariantCulture, listType, genericEnumerable));

        // can't add or modify a readonly list
        // use List<T> and convert once populated
        list = CreateGenericList(readOnlyCollectionContentsType);
        isReadOnlyOrFixedSize = true;
      }
      else if (typeof(IList).IsAssignableFrom(listType))
      {
        if (ReflectionUtils.IsInstantiatableType(listType))
          list = (IList)Activator.CreateInstance(listType);
        else if (listType == typeof(IList))
          list = new List<object>();
        else
          list = null;
      }
      else if (ReflectionUtils.ImplementsGenericDefinition(listType, typeof(ICollection<>)))
      {
        if (ReflectionUtils.IsInstantiatableType(listType))
          list = CreateCollectionWrapper(Activator.CreateInstance(listType));
        else
          list = null;
      }
      else
      {
        list = null;
      }

      if (list == null)
        throw new InvalidOperationException("Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, listType));

      return list;
    }

    public static Array ToArray(Array initial, Type type)
    {
      if (type == null)
        throw new ArgumentNullException("type");

      Array destinationArray = Array.CreateInstance(type, initial.Length);
      Array.Copy(initial, 0, destinationArray, 0, initial.Length);
      return destinationArray;
    }

    public static bool AddDistinct<T>(this IList<T> list, T value)
    {
      return list.AddDistinct(value, EqualityComparer<T>.Default);
    }

    public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
    {
      if (list.ContainsValue(value, comparer))
        return false;

      list.Add(value);
      return true;
    }

    // this is here because LINQ Bridge doesn't support Contains with IEqualityComparer<T>
    public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
    {
      if (comparer == null)
        comparer = EqualityComparer<TSource>.Default;

      if (source == null)
        throw new ArgumentNullException("source");

      foreach (TSource local in source)
      {
        if (comparer.Equals(local, value))
          return true;
      }

      return false;
    }

    public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
    {
      bool allAdded = true;
      foreach (T value in values)
      {
        if (!list.AddDistinct(value, comparer))
          allAdded = false;
      }

      return allAdded;
    }

    public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
    {
      int index = 0;
      foreach (T value in collection)
      {
        if (predicate(value))
          return index;

        index++;
      }

      return -1;
    }

    /// <summary>
    /// Returns the index of the first occurrence in a sequence by using a specified IEqualityComparer.
    /// </summary>
    /// <typeparam name="TSource">The type of the elements of source.</typeparam>
    /// <param name="list">A sequence in which to locate a value.</param>
    /// <param name="value">The object to locate in the sequence</param>
    /// <param name="comparer">An equality comparer to compare values.</param>
    /// <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, 1.</returns>
    public static int IndexOf<TSource>(this IEnumerable<TSource> list, TSource value, IEqualityComparer<TSource> comparer)
    {
      int index = 0;
      foreach (TSource item in list)
      {
        if (comparer.Equals(item, value))
        {
          return index;
        }
        index++;
      }
      return -1;
    }

    private static IList<int> GetDimensions(IList values)
    {
      IList<int> dimensions = new List<int>();

      IList currentArray = values;
      while (true)
      {
        dimensions.Add(currentArray.Count);
        if (currentArray.Count == 0)
          break;

        object v = currentArray[0];
        if (v is IList)
          currentArray = (IList)v;
        else
          break;
      }

      return dimensions;
    }

    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
    {
      int dimension = indices.Length;
      if (dimension == multidimensionalArray.Rank)
      {
        multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
        return;
      }

      int dimensionLength = multidimensionalArray.GetLength(dimension);
      IList list = (IList)JaggedArrayGetValue(values, indices);
      int currentValuesLength = list.Count;
      if (currentValuesLength != dimensionLength)
        throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");

      int[] newIndices = new int[dimension + 1];
      for (int i = 0; i < dimension; i++)
      {
        newIndices[i] = indices[i];
      }

      for (int i = 0; i < multidimensionalArray.GetLength(dimension); i++)
      {
        newIndices[dimension] = i;
        CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, newIndices);
      }
    }

    private static object JaggedArrayGetValue(IList values, int[] indices)
    {
      IList currentList = values;
      for (int i = 0; i < indices.Length; i++)
      {
        int index = indices[i];
        if (i == indices.Length - 1)
          return currentList[index];
        else
          currentList = (IList)currentList[index];
      }
      return currentList;
    }

    public static Array ToMultidimensionalArray(IList values, Type type, int rank)
    {
      IList<int> dimensions = GetDimensions(values);

      while (dimensions.Count < rank)
      {
        dimensions.Add(0);
      }

      Array multidimensionalArray = Array.CreateInstance(type, dimensions.ToArray());
      CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, new int[0]);

      return multidimensionalArray;
    }
  }
}
#endregion Utilities_CollectionUtils.cs

/// ********   File: \Utilities\CollectionWrapper.cs
#region Utilities_CollectionWrapper.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal interface IWrappedCollection : IList
  {
    object UnderlyingCollection { get; }
  }

  internal class CollectionWrapper<T> : ICollection<T>, IWrappedCollection
  {
    private readonly IList _list;
    private readonly ICollection<T> _genericCollection;
    private object _syncRoot;

    public CollectionWrapper(IList list)
    {
      ValidationUtils.ArgumentNotNull(list, "list");

      if (list is ICollection<T>)
        _genericCollection = (ICollection<T>)list;
      else
        _list = list;
    }

    public CollectionWrapper(ICollection<T> list)
    {
      ValidationUtils.ArgumentNotNull(list, "list");

      _genericCollection = list;
    }

    public virtual void Add(T item)
    {
      if (_genericCollection != null)
        _genericCollection.Add(item);
      else
        _list.Add(item);
    }

    public virtual void Clear()
    {
      if (_genericCollection != null)
        _genericCollection.Clear();
      else
        _list.Clear();
    }

    public virtual bool Contains(T item)
    {
      if (_genericCollection != null)
        return _genericCollection.Contains(item);
      else
        return _list.Contains(item);
    }

    public virtual void CopyTo(T[] array, int arrayIndex)
    {
      if (_genericCollection != null)
        _genericCollection.CopyTo(array, arrayIndex);
      else
        _list.CopyTo(array, arrayIndex);
    }

    public virtual int Count
    {
      get
      {
        if (_genericCollection != null)
          return _genericCollection.Count;
        else
          return _list.Count;
      }
    }

    public virtual bool IsReadOnly
    {
      get
      {
        if (_genericCollection != null)
          return _genericCollection.IsReadOnly;
        else
          return _list.IsReadOnly;
      }
    }

    public virtual bool Remove(T item)
    {
      if (_genericCollection != null)
      {
        return _genericCollection.Remove(item);
      }
      else
      {
        bool contains = _list.Contains(item);

        if (contains)
          _list.Remove(item);

        return contains;
      }
    }

    public virtual IEnumerator<T> GetEnumerator()
    {
      if (_genericCollection != null)
        return _genericCollection.GetEnumerator();

      return _list.Cast<T>().GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      if (_genericCollection != null)
        return _genericCollection.GetEnumerator();
      else
        return _list.GetEnumerator();
    }

    int IList.Add(object value)
    {
      VerifyValueType(value);
      Add((T)value);

      return (Count - 1);
    }

    bool IList.Contains(object value)
    {
      if (IsCompatibleObject(value))
        return Contains((T)value);

      return false;
    }

    int IList.IndexOf(object value)
    {
      if (_genericCollection != null)
        throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");

      if (IsCompatibleObject(value))
        return _list.IndexOf((T)value);

      return -1;
    }

    void IList.RemoveAt(int index)
    {
      if (_genericCollection != null)
        throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");

      _list.RemoveAt(index);
    }

    void IList.Insert(int index, object value)
    {
      if (_genericCollection != null)
        throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");

      VerifyValueType(value);
      _list.Insert(index, (T)value);
    }

    bool IList.IsFixedSize
    {
      get
      {
        if (_genericCollection != null)
          // ICollection<T> only has IsReadOnly
          return _genericCollection.IsReadOnly;
        else
          return _list.IsFixedSize;
      }
    }

    void IList.Remove(object value)
    {
      if (IsCompatibleObject(value))
        Remove((T)value);
    }

    object IList.this[int index]
    {
      get
      {
        if (_genericCollection != null)
          throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");

        return _list[index];
      }
      set
      {
        if (_genericCollection != null)
          throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");

        VerifyValueType(value);
        _list[index] = (T)value;
      }
    }

    void ICollection.CopyTo(Array array, int arrayIndex)
    {
      CopyTo((T[])array, arrayIndex);
    }

    bool ICollection.IsSynchronized
    {
      get { return false; }
    }

    object ICollection.SyncRoot
    {
      get
      {
        if (_syncRoot == null)
          Interlocked.CompareExchange(ref _syncRoot, new object(), null);

        return _syncRoot;
      }
    }

    private static void VerifyValueType(object value)
    {
      if (!IsCompatibleObject(value))
        throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
    }

    private static bool IsCompatibleObject(object value)
    {
      if (!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T)))))
        return false;

      return true;
    }

    public object UnderlyingCollection
    {
      get
      {
        if (_genericCollection != null)
          return _genericCollection;
        else
          return _list;
      }
    }
  }
}
#endregion Utilities_CollectionWrapper.cs

/// ********   File: \Utilities\ConvertUtils.cs
#region Utilities_ConvertUtils.cs

#if NET20
#endif

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
#endif
#if NETFX_CORE
#endif

namespace Newtonsoft.Json.Utilities
{
#if NETFX_CORE
  internal class Convertible
  {
    private object _underlyingValue;

    public Convertible(object o)
    {
      _underlyingValue = o;
    }

    public TypeCode GetTypeCode()
    {
      return ConvertUtils.GetTypeCode(_underlyingValue);
    }

    public bool ToBoolean(IFormatProvider provider)
    {
      return Convert.ToBoolean(_underlyingValue, provider);
    }
    public byte ToByte(IFormatProvider provider)
    {
      return Convert.ToByte(_underlyingValue, provider);
    }
    public char ToChar(IFormatProvider provider)
    {
      return Convert.ToChar(_underlyingValue, provider);
    }
    public DateTime ToDateTime(IFormatProvider provider)
    {
      return Convert.ToDateTime(_underlyingValue, provider);
    }
    public decimal ToDecimal(IFormatProvider provider)
    {
      return Convert.ToDecimal(_underlyingValue, provider);
    }
    public double ToDouble(IFormatProvider provider)
    {
      return Convert.ToDouble(_underlyingValue, provider);
    }
    public short ToInt16(IFormatProvider provider)
    {
      return Convert.ToInt16(_underlyingValue, provider);
    }
    public int ToInt32(IFormatProvider provider)
    {
      return Convert.ToInt32(_underlyingValue, provider);
    }
    public long ToInt64(IFormatProvider provider)
    {
      return Convert.ToInt64(_underlyingValue, provider);
    }
    public sbyte ToSByte(IFormatProvider provider)
    {
      return Convert.ToSByte(_underlyingValue, provider);
    }
    public float ToSingle(IFormatProvider provider)
    {
      return Convert.ToSingle(_underlyingValue, provider);
    }
    public string ToString(IFormatProvider provider)
    {
      return Convert.ToString(_underlyingValue, provider);
    }
    public object ToType(Type conversionType, IFormatProvider provider)
    {
      return Convert.ChangeType(_underlyingValue, conversionType, provider);
    }
    public ushort ToUInt16(IFormatProvider provider)
    {
      return Convert.ToUInt16(_underlyingValue, provider);
    }
    public uint ToUInt32(IFormatProvider provider)
    {
      return Convert.ToUInt32(_underlyingValue, provider);
    }
    public ulong ToUInt64(IFormatProvider provider)
    {
      return Convert.ToUInt64(_underlyingValue, provider);
    }
  }
#endif

  internal static class ConvertUtils
  {
    public static TypeCode GetTypeCode(this IConvertible convertible)
    {
#if !NETFX_CORE
      return convertible.GetTypeCode();
#else
      return GetTypeCode((object)convertible);
#endif
    }

    public static TypeCode GetTypeCode(object o)
    {
#if !(NETFX_CORE || PORTABLE)
      return System.Convert.GetTypeCode(o);
#else
      return GetTypeCode(o.GetType());
#endif
    }

    public static TypeCode GetTypeCode(Type t)
    {
#if !NETFX_CORE
      return Type.GetTypeCode(t);
#else
      if (t == typeof(bool))
        return TypeCode.Boolean;
      if (t == typeof(byte))
        return TypeCode.Byte;
      if (t == typeof(char))
        return TypeCode.Char;
      if (t == typeof(DateTime))
        return TypeCode.DateTime;
      if (t == typeof(decimal))
        return TypeCode.Decimal;
      if (t == typeof(double))
        return TypeCode.Double;
      if (t == typeof(short))
        return TypeCode.Int16;
      if (t == typeof(int))
        return TypeCode.Int32;
      if (t == typeof(long))
        return TypeCode.Int64;
      if (t == typeof(sbyte))
        return TypeCode.SByte;
      if (t == typeof(float))
        return TypeCode.Single;
      if (t == typeof(string))
        return TypeCode.String;
      if (t == typeof(ushort))
        return TypeCode.UInt16;
      if (t == typeof(uint))
        return TypeCode.UInt32;
      if (t == typeof(ulong))
        return TypeCode.UInt64;
      if (t.IsEnum())
        return GetTypeCode(Enum.GetUnderlyingType(t));

      return TypeCode.Object;
#endif
    }

    public static IConvertible ToConvertible(object o)
    {
#if !NETFX_CORE
      return o as IConvertible;
#else
      if (!IsConvertible(o))
        return null;

      return new IConvertible(o);
#endif
    }

    public static bool IsConvertible(object o)
    {
#if !NETFX_CORE
      return o is IConvertible;
#else
      if (o == null)
        return false;

      return (
        o is bool || o is byte || o is char || o is DateTime || o is decimal || o is double || o is short || o is int ||
        o is long || o is sbyte || o is float || o is string || o is ushort || o is uint || o is ulong || o is Enum);
#endif
    }

    public static bool IsConvertible(Type t)
    {
#if !NETFX_CORE
      return typeof(IConvertible).IsAssignableFrom(t);
#else
      return (
        t == typeof(bool) || t == typeof(byte) || t == typeof(char) || t == typeof(DateTime) || t == typeof(decimal) || t == typeof(double) || t == typeof(short) || t == typeof(int) ||
        t == typeof(long) || t == typeof(sbyte) || t == typeof(float) || t == typeof(string) || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong) || t.IsEnum());
#endif
    }

    public static TimeSpan ParseTimeSpan(string input)
    {
#if !(NET35 || NET20 || PORTABLE || WINDOWS_PHONE)
      return TimeSpan.Parse((string) input, CultureInfo.InvariantCulture);
#else
      return TimeSpan.Parse((string)input);
#endif
    }

    internal struct TypeConvertKey : IEquatable<TypeConvertKey>
    {
      private readonly Type _initialType;
      private readonly Type _targetType;

      public Type InitialType
      {
        get { return _initialType; }
      }

      public Type TargetType
      {
        get { return _targetType; }
      }

      public TypeConvertKey(Type initialType, Type targetType)
      {
        _initialType = initialType;
        _targetType = targetType;
      }

      public override int GetHashCode()
      {
        return _initialType.GetHashCode() ^ _targetType.GetHashCode();
      }

      public override bool Equals(object obj)
      {
        if (!(obj is TypeConvertKey))
          return false;

        return Equals((TypeConvertKey)obj);
      }

      public bool Equals(TypeConvertKey other)
      {
        return (_initialType == other._initialType && _targetType == other._targetType);
      }
    }

    private static readonly ThreadSafeStore<TypeConvertKey, Func<object, object>> CastConverters =
      new ThreadSafeStore<TypeConvertKey, Func<object, object>>(CreateCastConverter);

    private static Func<object, object> CreateCastConverter(TypeConvertKey t)
    {
      MethodInfo castMethodInfo = t.TargetType.GetMethod("op_Implicit", new[] { t.InitialType });
      if (castMethodInfo == null)
        castMethodInfo = t.TargetType.GetMethod("op_Explicit", new[] { t.InitialType });

      if (castMethodInfo == null)
        return null;

      MethodCall<object, object> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(castMethodInfo);

      return o => call(null, o);
    }

    #region Convert
    /// <summary>
    /// Converts the value to the specified type.
    /// </summary>
    /// <param name="initialValue">The value to convert.</param>
    /// <param name="culture">The culture to use when converting.</param>
    /// <param name="targetType">The type to convert the value to.</param>
    /// <returns>The converted type.</returns>
    public static object Convert(object initialValue, CultureInfo culture, Type targetType)
    {
      if (initialValue == null)
        throw new ArgumentNullException("initialValue");

      if (ReflectionUtils.IsNullableType(targetType))
        targetType = Nullable.GetUnderlyingType(targetType);

      Type initialType = initialValue.GetType();

      if (targetType == initialType)
        return initialValue;

      // use Convert.ChangeType if both types are IConvertible
      if (ConvertUtils.IsConvertible(initialValue) && ConvertUtils.IsConvertible(targetType))
      {
        if (targetType.IsEnum())
        {
          if (initialValue is string)
            return Enum.Parse(targetType, initialValue.ToString(), true);
          else if (IsInteger(initialValue))
            return Enum.ToObject(targetType, initialValue);
        }

        return System.Convert.ChangeType(initialValue, targetType, culture);
      }

      if (initialValue is string && typeof(Type).IsAssignableFrom(targetType))
        return Type.GetType((string) initialValue, true);

      if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
        throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType");

#if !PocketPC && !NET20
      if (initialValue is DateTime && targetType == typeof(DateTimeOffset))
        return new DateTimeOffset((DateTime)initialValue);
#endif

      if (initialValue is string)
      {
        if (targetType == typeof (Guid))
          return new Guid((string) initialValue);
        if (targetType == typeof (Uri))
          return new Uri((string) initialValue, UriKind.RelativeOrAbsolute);
        if (targetType == typeof(TimeSpan))
          return ParseTimeSpan((string) initialValue);
      }

#if !(NETFX_CORE || PORTABLE)
      // see if source or target types have a TypeConverter that converts between the two
      TypeConverter toConverter = GetConverter(initialType);

      if (toConverter != null && toConverter.CanConvertTo(targetType))
      {
#if !SILVERLIGHT
        return toConverter.ConvertTo(null, culture, initialValue, targetType);
#else
        return toConverter.ConvertTo(initialValue, targetType);
#endif
      }

      TypeConverter fromConverter = GetConverter(targetType);

      if (fromConverter != null && fromConverter.CanConvertFrom(initialType))
      {
#if !SILVERLIGHT
        return fromConverter.ConvertFrom(null, culture, initialValue);
#else
        return fromConverter.ConvertFrom(initialValue);
#endif
      }
#endif
#if !(NETFX_CORE || PORTABLE)
      // handle DBNull and INullable
      if (initialValue == DBNull.Value)
      {
        if (ReflectionUtils.IsNullable(targetType))
          return EnsureTypeAssignable(null, initialType, targetType);
        
        throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, initialType, targetType));
      }
#endif
#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
      if (initialValue is INullable)
        return EnsureTypeAssignable(ToValue((INullable)initialValue), initialType, targetType);
#endif

      throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialType, targetType));
    }
    #endregion

    #region TryConvert
    /// <summary>
    /// Converts the value to the specified type.
    /// </summary>
    /// <param name="initialValue">The value to convert.</param>
    /// <param name="culture">The culture to use when converting.</param>
    /// <param name="targetType">The type to convert the value to.</param>
    /// <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
    /// <returns>
    /// 	<c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
    /// </returns>
    public static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, out object convertedValue)
    {
      try
      {
        convertedValue = Convert(initialValue, culture, targetType);
        return true;
      }
      catch
      {
        convertedValue = null;
        return false;
      }
    }
    #endregion

    #region ConvertOrCast
    /// <summary>
    /// Converts the value to the specified type. If the value is unable to be converted, the
    /// value is checked whether it assignable to the specified type.
    /// </summary>
    /// <param name="initialValue">The value to convert.</param>
    /// <param name="culture">The culture to use when converting.</param>
    /// <param name="targetType">The type to convert or cast the value to.</param>
    /// <returns>
    /// The converted type. If conversion was unsuccessful, the initial value
    /// is returned if assignable to the target type.
    /// </returns>
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
    {
      object convertedValue;

      if (targetType == typeof(object))
        return initialValue;

      if (initialValue == null && ReflectionUtils.IsNullable(targetType))
        return null;

      if (TryConvert(initialValue, culture, targetType, out convertedValue))
        return convertedValue;

      return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
    }
    #endregion

    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
    {
      Type valueType = (value != null) ? value.GetType() : null;

      if (value != null)
      {
        if (targetType.IsAssignableFrom(valueType))
          return value;

        Func<object, object> castConverter = CastConverters.Get(new TypeConvertKey(valueType, targetType));
        if (castConverter != null)
          return castConverter(value);
      }
      else
      {
        if (ReflectionUtils.IsNullable(targetType))
          return null;
      }

      throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, (initialType != null) ? initialType.ToString() : "{null}", targetType));
    }

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
    public static object ToValue(INullable nullableValue)
    {
      if (nullableValue == null)
        return null;
      else if (nullableValue is SqlInt32)
        return ToValue((SqlInt32)nullableValue);
      else if (nullableValue is SqlInt64)
        return ToValue((SqlInt64)nullableValue);
      else if (nullableValue is SqlBoolean)
        return ToValue((SqlBoolean)nullableValue);
      else if (nullableValue is SqlString)
        return ToValue((SqlString)nullableValue);
      else if (nullableValue is SqlDateTime)
        return ToValue((SqlDateTime)nullableValue);

      throw new ArgumentException("Unsupported INullable type: {0}".FormatWith(CultureInfo.InvariantCulture, nullableValue.GetType()));
    }
#endif

#if !(NETFX_CORE || PORTABLE)
    internal static TypeConverter GetConverter(Type t)
    {
      return JsonTypeReflector.GetTypeConverter(t);
    }
#endif

    public static bool IsInteger(object value)
    {
      switch (GetTypeCode(value))
      {
        case TypeCode.SByte:
        case TypeCode.Byte:
        case TypeCode.Int16:
        case TypeCode.UInt16:
        case TypeCode.Int32:
        case TypeCode.UInt32:
        case TypeCode.Int64:
        case TypeCode.UInt64:
          return true;
        default:
          return false;
      }
    }
  }
}

#endregion Utilities_ConvertUtils.cs

/// ********   File: \Utilities\DateTimeUtils.cs
#region Utilities_DateTimeUtils.cs

namespace Newtonsoft.Json.Utilities
{
  internal static class DateTimeUtils
  {
    public static string GetUtcOffsetText(this DateTime d)
    {
      TimeSpan utcOffset = d.GetUtcOffset();

      return utcOffset.Hours.ToString("+00;-00", CultureInfo.InvariantCulture) + ":" + utcOffset.Minutes.ToString("00;00", CultureInfo.InvariantCulture);
    }

    public static TimeSpan GetUtcOffset(this DateTime d)
    {
#if NET20
      return TimeZone.CurrentTimeZone.GetUtcOffset(d);
#else
      return TimeZoneInfo.Local.GetUtcOffset(d);
#endif
    }

#if !(NETFX_CORE || PORTABLE)
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
    {
      switch (kind)
      {
        case DateTimeKind.Local:
          return XmlDateTimeSerializationMode.Local;
        case DateTimeKind.Unspecified:
          return XmlDateTimeSerializationMode.Unspecified;
        case DateTimeKind.Utc:
          return XmlDateTimeSerializationMode.Utc;
        default:
          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("kind", kind, "Unexpected DateTimeKind value.");
      }
    }
#endif
  }
}

#endregion Utilities_DateTimeUtils.cs

/// ********   File: \Utilities\DictionaryWrapper.cs
#region Utilities_DictionaryWrapper.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal interface IWrappedDictionary
    : IDictionary
  {
    object UnderlyingDictionary { get; }
  }

  internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, IWrappedDictionary
  {
    private readonly IDictionary _dictionary;
    private readonly IDictionary<TKey, TValue> _genericDictionary;
    private object _syncRoot;

    public DictionaryWrapper(IDictionary dictionary)
    {
      ValidationUtils.ArgumentNotNull(dictionary, "dictionary");

      _dictionary = dictionary;
    }

    public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
    {
      ValidationUtils.ArgumentNotNull(dictionary, "dictionary");

      _genericDictionary = dictionary;
    }

    public void Add(TKey key, TValue value)
    {
      if (_dictionary != null)
        _dictionary.Add(key, value);
      else
        _genericDictionary.Add(key, value);
    }

    public bool ContainsKey(TKey key)
    {
      if (_dictionary != null)
        return _dictionary.Contains(key);
      else
        return _genericDictionary.ContainsKey(key);
    }

    public ICollection<TKey> Keys
    {
      get
      {
        if (_dictionary != null)
          return _dictionary.Keys.Cast<TKey>().ToList();
        else
          return _genericDictionary.Keys;
      }
    }

    public bool Remove(TKey key)
    {
      if (_dictionary != null)
      {
        if (_dictionary.Contains(key))
        {
          _dictionary.Remove(key);
          return true;
        }
        else
        {
          return false;
        }
      }

      return _genericDictionary.Remove(key);
    }

    public bool TryGetValue(TKey key, out TValue value)
    {
      if (_dictionary != null)
      {
        if (!_dictionary.Contains(key))
        {
          value = default(TValue);
          return false;
        }
        else
        {
          value = (TValue)_dictionary[key];
          return true;
        }
      }

      return _genericDictionary.TryGetValue(key, out value);
    }

    public ICollection<TValue> Values
    {
      get
      {
        if (_dictionary != null)
          return _dictionary.Values.Cast<TValue>().ToList();
        else
          return _genericDictionary.Values;
      }
    }

    public TValue this[TKey key]
    {
      get
      {
        if (_dictionary != null)
          return (TValue)_dictionary[key];
        return _genericDictionary[key];
      }
      set
      {
        if (_dictionary != null)
          _dictionary[key] = value;
        else
          _genericDictionary[key] = value;
      }
    }

    public void Add(KeyValuePair<TKey, TValue> item)
    {
      if (_dictionary != null)
        ((IList)_dictionary).Add(item);
      else
        _genericDictionary.Add(item);
    }

    public void Clear()
    {
      if (_dictionary != null)
        _dictionary.Clear();
      else
        _genericDictionary.Clear();
    }

    public bool Contains(KeyValuePair<TKey, TValue> item)
    {
      if (_dictionary != null)
        return ((IList)_dictionary).Contains(item);
      else
        return _genericDictionary.Contains(item);
    }

    public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
    {
      if (_dictionary != null)
      {
        foreach (DictionaryEntry item in _dictionary)
        {
          array[arrayIndex++] = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
        }
      }
      else
      {
        _genericDictionary.CopyTo(array, arrayIndex);
      }
    }

    public int Count
    {
      get
      {
        if (_dictionary != null)
          return _dictionary.Count;
        else
          return _genericDictionary.Count;
      }
    }

    public bool IsReadOnly
    {
      get
      {
        if (_dictionary != null)
          return _dictionary.IsReadOnly;
        else
          return _genericDictionary.IsReadOnly;
      }
    }

    public bool Remove(KeyValuePair<TKey, TValue> item)
    {
      if (_dictionary != null)
      {
        if (_dictionary.Contains(item.Key))
        {
          object value = _dictionary[item.Key];

          if (object.Equals(value, item.Value))
          {
            _dictionary.Remove(item.Key);
            return true;
          }
          else
          {
            return false;
          }
        }
        else
        {
          return true;
        }
      }
      else
      {
        return _genericDictionary.Remove(item);
      }
    }

    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
    {
      if (_dictionary != null)
        return _dictionary.Cast<DictionaryEntry>().Select(de => new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
      else
        return _genericDictionary.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      return GetEnumerator();
    }

    void IDictionary.Add(object key, object value)
    {
      if (_dictionary != null)
        _dictionary.Add(key, value);
      else
        _genericDictionary.Add((TKey)key, (TValue)value);
    }

    object IDictionary.this[object key]
    {
      get
      {
        if (_dictionary != null)
          return _dictionary[key];
        else
          return _genericDictionary[(TKey)key];
      }
      set
      {
        if (_dictionary != null)
          _dictionary[key] = value;
        else
          _genericDictionary[(TKey)key] = (TValue)value;
      }
    }

    private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator
    {
      private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

      public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
      {
        ValidationUtils.ArgumentNotNull(e, "e");
        _e = e;
      }

      public DictionaryEntry Entry
      {
        get { return (DictionaryEntry)Current; }
      }

      public object Key
      {
        get { return Entry.Key; }
      }

      public object Value
      {
        get { return Entry.Value; }
      }

      public object Current
      {
        get { return new DictionaryEntry(_e.Current.Key, _e.Current.Value); }
      }

      public bool MoveNext()
      {
        return _e.MoveNext();
      }

      public void Reset()
      {
        _e.Reset();
      }
    }

    IDictionaryEnumerator IDictionary.GetEnumerator()
    {
      if (_dictionary != null)
        return _dictionary.GetEnumerator();
      else
        return new DictionaryEnumerator<TKey, TValue>(_genericDictionary.GetEnumerator());
    }

    bool IDictionary.Contains(object key)
    {
      if (_genericDictionary != null)
        return _genericDictionary.ContainsKey((TKey)key);
      else
        return _dictionary.Contains(key);
    }

    bool IDictionary.IsFixedSize
    {
      get
      {
        if (_genericDictionary != null)
          return false;
        else
          return _dictionary.IsFixedSize;
      }
    }

    ICollection IDictionary.Keys
    {
      get
      {
        if (_genericDictionary != null)
          return _genericDictionary.Keys.ToList();
        else
          return _dictionary.Keys;
      }
    }

    public void Remove(object key)
    {
      if (_dictionary != null)
        _dictionary.Remove(key);
      else
        _genericDictionary.Remove((TKey)key);
    }

    ICollection IDictionary.Values
    {
      get
      {
        if (_genericDictionary != null)
          return _genericDictionary.Values.ToList();
        else
          return _dictionary.Values;
      }
    }

    void ICollection.CopyTo(Array array, int index)
    {
      if (_dictionary != null)
        _dictionary.CopyTo(array, index);
      else
        _genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
    }

    bool ICollection.IsSynchronized
    {
      get
      {
        if (_dictionary != null)
          return _dictionary.IsSynchronized;
        else
          return false;
      }
    }

    object ICollection.SyncRoot
    {
      get
      {
        if (_syncRoot == null)
          Interlocked.CompareExchange(ref _syncRoot, new object(), null);

        return _syncRoot;
      }
    }

    public object UnderlyingDictionary
    {
      get
      {
        if (_dictionary != null)
          return _dictionary;
        else
          return _genericDictionary;
      }
    }
  }
}
#endregion Utilities_DictionaryWrapper.cs

/// ********   File: \Utilities\DynamicProxy.cs
#region Utilities_DynamicProxy.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)

namespace Newtonsoft.Json.Utilities
{
  internal class DynamicProxy<T>
  {
    public virtual IEnumerable<string> GetDynamicMemberNames(T instance)
    {
      return new string[0];
    }

    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryConvert(T instance, ConvertBinder binder, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, object[] args, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, object[] indexes)
    {
      return false;
    }

    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder)
    {
      return false;
    }

    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, object[] indexes, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryGetMember(T instance, GetMemberBinder binder, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryInvoke(T instance, InvokeBinder binder, object[] args, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, object[] args, out object result)
    {
      result = null;
      return false;
    }

    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, object[] indexes, object value)
    {
      return false;
    }

    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value)
    {
      return false;
    }

    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, out object result)
    {
      result = null;
      return false;
    }
  }
}
#endif
#endregion Utilities_DynamicProxy.cs

/// ********   File: \Utilities\DynamicProxyMetaObject.cs
#region Utilities_DynamicProxyMetaObject.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)

namespace Newtonsoft.Json.Utilities
{
  internal sealed class DynamicProxyMetaObject<T> : DynamicMetaObject
  {
    private readonly DynamicProxy<T> _proxy;
    private readonly bool _dontFallbackFirst;

    internal DynamicProxyMetaObject(Expression expression, T value, DynamicProxy<T> proxy, bool dontFallbackFirst)
      : base(expression, BindingRestrictions.Empty, value)
    {
      _proxy = proxy;
      _dontFallbackFirst = dontFallbackFirst;
    }

    private new T Value { get { return (T)base.Value; } }

    private bool IsOverridden(string method)
    {
      return ReflectionUtils.IsMethodOverridden(_proxy.GetType(), typeof (DynamicProxy<T>), method);
    }

    public override DynamicMetaObject BindGetMember(GetMemberBinder binder)
    {
      return IsOverridden("TryGetMember")
           ? CallMethodWithResult("TryGetMember", binder, NoArgs, e => binder.FallbackGetMember(this, e))
           : base.BindGetMember(binder);
    }

    public override DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
    {
      return IsOverridden("TrySetMember")
           ? CallMethodReturnLast("TrySetMember", binder, GetArgs(value), e => binder.FallbackSetMember(this, value, e))
           : base.BindSetMember(binder, value);
    }

    public override DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
    {
      return IsOverridden("TryDeleteMember")
           ? CallMethodNoResult("TryDeleteMember", binder, NoArgs, e => binder.FallbackDeleteMember(this, e))
           : base.BindDeleteMember(binder);
    }

    public override DynamicMetaObject BindConvert(ConvertBinder binder)
    {
      return IsOverridden("TryConvert")
           ? CallMethodWithResult("TryConvert", binder, NoArgs, e => binder.FallbackConvert(this, e))
           : base.BindConvert(binder);
    }

    public override DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
    {
      if (!IsOverridden("TryInvokeMember"))
        return base.BindInvokeMember(binder, args);

      //
      // Generate a tree like:
      //
      // {
      //   object result;
      //   TryInvokeMember(payload, out result)
      //      ? result
      //      : TryGetMember(payload, out result)
      //          ? FallbackInvoke(result)
      //          : fallbackResult
      // }
      //
      // Then it calls FallbackInvokeMember with this tree as the
      // "error", giving the language the option of using this
      // tree or doing .NET binding.
      //
      Fallback fallback = e => binder.FallbackInvokeMember(this, args, e);

      DynamicMetaObject call = BuildCallMethodWithResult(
          "TryInvokeMember",
          binder,
          GetArgArray(args),
          BuildCallMethodWithResult(
              "TryGetMember",
              new GetBinderAdapter(binder),
              NoArgs,
              fallback(null),
              e => binder.FallbackInvoke(e, args, null)
          ),
          null
      );

      return _dontFallbackFirst ? call : fallback(call);
    }

    public override DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args)
    {
      return IsOverridden("TryCreateInstance")
           ? CallMethodWithResult("TryCreateInstance", binder, GetArgArray(args), e => binder.FallbackCreateInstance(this, args, e))
           : base.BindCreateInstance(binder, args);
    }

    public override DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args)
    {
      return IsOverridden("TryInvoke")
        ? CallMethodWithResult("TryInvoke", binder, GetArgArray(args), e => binder.FallbackInvoke(this, args, e))
        : base.BindInvoke(binder, args);
    }

    public override DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg)
    {
      return IsOverridden("TryBinaryOperation")
        ? CallMethodWithResult("TryBinaryOperation", binder, GetArgs(arg), e => binder.FallbackBinaryOperation(this, arg, e))
        : base.BindBinaryOperation(binder, arg);
    }

    public override DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder)
    {
      return IsOverridden("TryUnaryOperation")
           ? CallMethodWithResult("TryUnaryOperation", binder, NoArgs, e => binder.FallbackUnaryOperation(this, e))
           : base.BindUnaryOperation(binder);
    }

    public override DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes)
    {
      return IsOverridden("TryGetIndex")
           ? CallMethodWithResult("TryGetIndex", binder, GetArgArray(indexes), e => binder.FallbackGetIndex(this, indexes, e))
           : base.BindGetIndex(binder, indexes);
    }

    public override DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value)
    {
      return IsOverridden("TrySetIndex")
           ? CallMethodReturnLast("TrySetIndex", binder, GetArgArray(indexes, value), e => binder.FallbackSetIndex(this, indexes, value, e))
           : base.BindSetIndex(binder, indexes, value);
    }

    public override DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes)
    {
      return IsOverridden("TryDeleteIndex")
           ? CallMethodNoResult("TryDeleteIndex", binder, GetArgArray(indexes), e => binder.FallbackDeleteIndex(this, indexes, e))
           : base.BindDeleteIndex(binder, indexes);
    }

    private delegate DynamicMetaObject Fallback(DynamicMetaObject errorSuggestion);

    private readonly static Expression[] NoArgs = new Expression[0];

    private static Expression[] GetArgs(params DynamicMetaObject[] args)
    {
      return args.Select(arg => Expression.Convert(arg.Expression, typeof(object))).ToArray();
    }

    private static Expression[] GetArgArray(DynamicMetaObject[] args)
    {
      return new[] { Expression.NewArrayInit(typeof(object), GetArgs(args)) };
    }

    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value)
    {
      return new Expression[]
            {
                Expression.NewArrayInit(typeof(object), GetArgs(args)),
                Expression.Convert(value.Expression, typeof(object))
            };
    }

    private static ConstantExpression Constant(DynamicMetaObjectBinder binder)
    {
      Type t = binder.GetType();
      while (!t.IsVisible())
        t = t.BaseType();
      return Expression.Constant(binder, t);
    }

    /// <summary>
    /// Helper method for generating a MetaObject which calls a
    /// specific method on Dynamic that returns a result
    /// </summary>
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback fallback, Fallback fallbackInvoke = null)
    {
      //
      // First, call fallback to do default binding
      // This produces either an error or a call to a .NET member
      //
      DynamicMetaObject fallbackResult = fallback(null);

      DynamicMetaObject callDynamic = BuildCallMethodWithResult(methodName, binder, args, fallbackResult, fallbackInvoke);

      //
      // Now, call fallback again using our new MO as the error
      // When we do this, one of two things can happen:
      //   1. Binding will succeed, and it will ignore our call to
      //      the dynamic method, OR
      //   2. Binding will fail, and it will use the MO we created
      //      above.
      //

      return _dontFallbackFirst ? callDynamic : fallback(callDynamic);
    }

    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, DynamicMetaObject fallbackResult, Fallback fallbackInvoke)
    {
      //
      // Build a new expression like:
      // {
      //   object result;
      //   TryGetMember(payload, out result) ? fallbackInvoke(result) : fallbackResult
      // }
      //
      ParameterExpression result = Expression.Parameter(typeof(object), null);

      IList<Expression> callArgs = new List<Expression>();
      callArgs.Add(Expression.Convert(Expression, typeof(T)));
      callArgs.Add(Constant(binder));
      callArgs.AddRange(args);
      callArgs.Add(result);

      DynamicMetaObject resultMetaObject = new DynamicMetaObject(result, BindingRestrictions.Empty);

      // Need to add a conversion if calling TryConvert
      if (binder.ReturnType != typeof (object))
      {
        UnaryExpression convert = Expression.Convert(resultMetaObject.Expression, binder.ReturnType);
        // will always be a cast or unbox

        resultMetaObject = new DynamicMetaObject(convert, resultMetaObject.Restrictions);
      }

      if (fallbackInvoke != null)
        resultMetaObject = fallbackInvoke(resultMetaObject);

      DynamicMetaObject callDynamic = new DynamicMetaObject(
        Expression.Block(
          new[] {result},
          Expression.Condition(
            Expression.Call(
              Expression.Constant(_proxy),
              typeof(DynamicProxy<T>).GetMethod(methodName),
              callArgs
              ),
            resultMetaObject.Expression,
            fallbackResult.Expression,
            binder.ReturnType
            )
          ),
        GetRestrictions().Merge(resultMetaObject.Restrictions).Merge(fallbackResult.Restrictions)
        );

      return callDynamic;
    }

    /// <summary>
    /// Helper method for generating a MetaObject which calls a
    /// specific method on Dynamic, but uses one of the arguments for
    /// the result.
    /// </summary>
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback fallback)
    {
      //
      // First, call fallback to do default binding
      // This produces either an error or a call to a .NET member
      //
      DynamicMetaObject fallbackResult = fallback(null);

      //
      // Build a new expression like:
      // {
      //   object result;
      //   TrySetMember(payload, result = value) ? result : fallbackResult
      // }
      //
      ParameterExpression result = Expression.Parameter(typeof(object), null);

      IList<Expression> callArgs = new List<Expression>();
      callArgs.Add(Expression.Convert(Expression, typeof (T)));
      callArgs.Add(Constant(binder));
      callArgs.AddRange(args);
      callArgs[args.Length + 1] = Expression.Assign(result, callArgs[args.Length + 1]);

      DynamicMetaObject callDynamic = new DynamicMetaObject(
          Expression.Block(
              new[] { result },
              Expression.Condition(
                  Expression.Call(
                      Expression.Constant(_proxy),
                      typeof(DynamicProxy<T>).GetMethod(methodName),
                      callArgs
                  ),
                  result,
                  fallbackResult.Expression,
                  typeof(object)
              )
          ),
          GetRestrictions().Merge(fallbackResult.Restrictions)
      );

      //
      // Now, call fallback again using our new MO as the error
      // When we do this, one of two things can happen:
      //   1. Binding will succeed, and it will ignore our call to
      //      the dynamic method, OR
      //   2. Binding will fail, and it will use the MO we created
      //      above.
      //
      return _dontFallbackFirst ? callDynamic : fallback(callDynamic);
    }

    /// <summary>
    /// Helper method for generating a MetaObject which calls a
    /// specific method on Dynamic, but uses one of the arguments for
    /// the result.
    /// </summary>
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback fallback)
    {
      //
      // First, call fallback to do default binding
      // This produces either an error or a call to a .NET member
      //
      DynamicMetaObject fallbackResult = fallback(null);

      IList<Expression> callArgs = new List<Expression>();
      callArgs.Add(Expression.Convert(Expression, typeof(T)));
      callArgs.Add(Constant(binder));
      callArgs.AddRange(args);

      //
      // Build a new expression like:
      //   if (TryDeleteMember(payload)) { } else { fallbackResult }
      //
      DynamicMetaObject callDynamic = new DynamicMetaObject(
        Expression.Condition(
          Expression.Call(
            Expression.Constant(_proxy),
            typeof(DynamicProxy<T>).GetMethod(methodName),
            callArgs
            ),
          Expression.Empty(),
          fallbackResult.Expression,
          typeof (void)
          ),
        GetRestrictions().Merge(fallbackResult.Restrictions)
        );

      //
      // Now, call fallback again using our new MO as the error
      // When we do this, one of two things can happen:
      //   1. Binding will succeed, and it will ignore our call to
      //      the dynamic method, OR
      //   2. Binding will fail, and it will use the MO we created
      //      above.
      //
      return _dontFallbackFirst ? callDynamic : fallback(callDynamic);
    }

    /// <summary>
    /// Returns a Restrictions object which includes our current restrictions merged
    /// with a restriction limiting our type
    /// </summary>
    private BindingRestrictions GetRestrictions()
    {
      return (Value == null && HasValue)
           ? BindingRestrictions.GetInstanceRestriction(Expression, null)
           : BindingRestrictions.GetTypeRestriction(Expression, LimitType);
    }

    public override IEnumerable<string> GetDynamicMemberNames()
    {
      return _proxy.GetDynamicMemberNames(Value);
    }

    // It is okay to throw NotSupported from this binder. This object
    // is only used by DynamicObject.GetMember--it is not expected to
    // (and cannot) implement binding semantics. It is just so the DO
    // can use the Name and IgnoreCase properties.
    private sealed class GetBinderAdapter : GetMemberBinder
    {
      internal GetBinderAdapter(InvokeMemberBinder binder) :
        base(binder.Name, binder.IgnoreCase)
      {
      }

      public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
      {
        throw new NotSupportedException();
      }
    }
  }
}
#endif
#endregion Utilities_DynamicProxyMetaObject.cs

/// ********   File: \Utilities\DynamicReflectionDelegateFactory.cs
#region Utilities_DynamicReflectionDelegateFactory.cs

#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)
#if NET20
#endif

namespace Newtonsoft.Json.Utilities
{
  internal class DynamicReflectionDelegateFactory : ReflectionDelegateFactory
  {
    public static DynamicReflectionDelegateFactory Instance = new DynamicReflectionDelegateFactory();

    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner)
    {
      DynamicMethod dynamicMethod = !owner.IsInterface()
        ? new DynamicMethod(name, returnType, parameterTypes, owner, true)
        : new DynamicMethod(name, returnType, parameterTypes, owner.Module, true);

      return dynamicMethod;
    }

    public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod(method.ToString(), typeof(object), new[] { typeof(object), typeof(object[]) }, method.DeclaringType);
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateMethodCallIL(method, generator);

      return (MethodCall<T, object>)dynamicMethod.CreateDelegate(typeof(MethodCall<T, object>));
    }

    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator)
    {
      ParameterInfo[] args = method.GetParameters();

      Label argsOk = generator.DefineLabel();

      generator.Emit(OpCodes.Ldarg_1);
      generator.Emit(OpCodes.Ldlen);
      generator.Emit(OpCodes.Ldc_I4, args.Length);
      generator.Emit(OpCodes.Beq, argsOk);

      generator.Emit(OpCodes.Newobj, typeof(TargetParameterCountException).GetConstructor(ReflectionUtils.EmptyTypes));
      generator.Emit(OpCodes.Throw);

      generator.MarkLabel(argsOk);

      if (!method.IsConstructor && !method.IsStatic)
        generator.PushInstance(method.DeclaringType);

      for (int i = 0; i < args.Length; i++)
      {
        generator.Emit(OpCodes.Ldarg_1);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Ldelem_Ref);

        generator.UnboxIfNeeded(args[i].ParameterType);
      }

      if (method.IsConstructor)
        generator.Emit(OpCodes.Newobj, (ConstructorInfo)method);
      else if (method.IsFinal || !method.IsVirtual)
        generator.CallMethod((MethodInfo)method);

      Type returnType = method.IsConstructor
                          ? method.DeclaringType
                          : ((MethodInfo)method).ReturnType;

      if (returnType != typeof(void))
        generator.BoxIfNeeded(returnType);
      else
        generator.Emit(OpCodes.Ldnull);

      generator.Return();
    }

    public override Func<T> CreateDefaultConstructor<T>(Type type)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod("Create" + type.FullName, typeof(T), ReflectionUtils.EmptyTypes, type);
      dynamicMethod.InitLocals = true;
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateDefaultConstructorIL(type, generator);

      return (Func<T>)dynamicMethod.CreateDelegate(typeof(Func<T>));
    }

    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator)
    {
      if (type.IsValueType())
      {
        generator.DeclareLocal(type);
        generator.Emit(OpCodes.Ldloc_0);
        generator.Emit(OpCodes.Box, type);
      }
      else
      {
        ConstructorInfo constructorInfo =
          type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null,
                              ReflectionUtils.EmptyTypes, null);

        if (constructorInfo == null)
          throw new ArgumentException("Could not get constructor for {0}.".FormatWith(CultureInfo.InvariantCulture, type));

        generator.Emit(OpCodes.Newobj, constructorInfo);
      }

      generator.Return();
    }

    public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod("Get" + propertyInfo.Name, typeof(T), new[] { typeof(object) }, propertyInfo.DeclaringType);
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateGetPropertyIL(propertyInfo, generator);

      return (Func<T, object>)dynamicMethod.CreateDelegate(typeof(Func<T, object>));
    }

    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
    {
      MethodInfo getMethod = propertyInfo.GetGetMethod(true);
      if (getMethod == null)
        throw new ArgumentException("Property '{0}' does not have a getter.".FormatWith(CultureInfo.InvariantCulture, propertyInfo.Name));

      if (!getMethod.IsStatic)
        generator.PushInstance(propertyInfo.DeclaringType);

      generator.CallMethod(getMethod);
      generator.BoxIfNeeded(propertyInfo.PropertyType);
      generator.Return();
    }

    public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod("Get" + fieldInfo.Name, typeof(T), new[] { typeof(object) }, fieldInfo.DeclaringType);
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateGetFieldIL(fieldInfo, generator);

      return (Func<T, object>)dynamicMethod.CreateDelegate(typeof(Func<T, object>));
    }

    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
    {
      if (!fieldInfo.IsStatic)
        generator.PushInstance(fieldInfo.DeclaringType);

      generator.Emit(OpCodes.Ldfld, fieldInfo);
      generator.BoxIfNeeded(fieldInfo.FieldType);
      generator.Return();
    }

    public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod("Set" + fieldInfo.Name, null, new[] { typeof(T), typeof(object) }, fieldInfo.DeclaringType);
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateSetFieldIL(fieldInfo, generator);

      return (Action<T, object>)dynamicMethod.CreateDelegate(typeof(Action<T, object>));
    }

    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
    {
      if (!fieldInfo.IsStatic)
        generator.PushInstance(fieldInfo.DeclaringType);

      generator.Emit(OpCodes.Ldarg_1);
      generator.UnboxIfNeeded(fieldInfo.FieldType);
      generator.Emit(OpCodes.Stfld, fieldInfo);
      generator.Return();
    }

    public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
    {
      DynamicMethod dynamicMethod = CreateDynamicMethod("Set" + propertyInfo.Name, null, new[] { typeof(T), typeof(object) }, propertyInfo.DeclaringType);
      ILGenerator generator = dynamicMethod.GetILGenerator();

      GenerateCreateSetPropertyIL(propertyInfo, generator);

      return (Action<T, object>)dynamicMethod.CreateDelegate(typeof(Action<T, object>));
    }

    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
    {
      MethodInfo setMethod = propertyInfo.GetSetMethod(true);
      if (!setMethod.IsStatic)
        generator.PushInstance(propertyInfo.DeclaringType);

      generator.Emit(OpCodes.Ldarg_1);
      generator.UnboxIfNeeded(propertyInfo.PropertyType);
      generator.CallMethod(setMethod);
      generator.Return();
    }
  }
}
#endif
#endregion Utilities_DynamicReflectionDelegateFactory.cs

/// ********   File: \Utilities\DynamicUtils.cs
#region Utilities_DynamicUtils.cs

#if !(NET35 || NET20 || WINDOWS_PHONE || PORTABLE)

namespace Newtonsoft.Json.Utilities
{
  internal static class DynamicUtils
  {
    internal static class BinderWrapper
    {
#if !SILVERLIGHT
      public const string CSharpAssemblyName = "Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
#else
      public const string CSharpAssemblyName = "Microsoft.CSharp, Version=2.0.5.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
#endif

      private const string BinderTypeName = "Microsoft.CSharp.RuntimeBinder.Binder, " + CSharpAssemblyName;
      private const string CSharpArgumentInfoTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo, " + CSharpAssemblyName;
      private const string CSharpArgumentInfoFlagsTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, " + CSharpAssemblyName;
      private const string CSharpBinderFlagsTypeName = "Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, " + CSharpAssemblyName;

      private static object _getCSharpArgumentInfoArray;
      private static object _setCSharpArgumentInfoArray;
      private static MethodCall<object, object> _getMemberCall;
      private static MethodCall<object, object> _setMemberCall;
      private static bool _init;

      private static void Init()
      {
        if (!_init)
        {
          Type binderType = Type.GetType(BinderTypeName, false);
          if (binderType == null)
            throw new InvalidOperationException("Could not resolve type '{0}'. You may need to add a reference to Microsoft.CSharp.dll to work with dynamic types.".FormatWith(CultureInfo.InvariantCulture, BinderTypeName));

          // None
          _getCSharpArgumentInfoArray = CreateSharpArgumentInfoArray(0);
          // None, Constant | UseCompileTimeType
          _setCSharpArgumentInfoArray = CreateSharpArgumentInfoArray(0, 3);
          CreateMemberCalls();

          _init = true;
        }
      }

      private static object CreateSharpArgumentInfoArray(params int[] values)
      {
        Type csharpArgumentInfoType = Type.GetType(CSharpArgumentInfoTypeName);
        Type csharpArgumentInfoFlags = Type.GetType(CSharpArgumentInfoFlagsTypeName);

        Array a = Array.CreateInstance(csharpArgumentInfoType, values.Length);

        for (int i = 0; i < values.Length; i++)
        {
          MethodInfo createArgumentInfoMethod = csharpArgumentInfoType.GetMethod("Create", BindingFlags.Public | BindingFlags.Static, null, new[] { csharpArgumentInfoFlags, typeof(string) }, null);
          object arg = createArgumentInfoMethod.Invoke(null, new object[] { 0, null });
          a.SetValue(arg, i);
        }

        return a;
      }

      private static void CreateMemberCalls()
      {
        Type csharpArgumentInfoType = Type.GetType(CSharpArgumentInfoTypeName);
        Type csharpBinderFlagsType = Type.GetType(CSharpBinderFlagsTypeName);
        Type binderType = Type.GetType(BinderTypeName);

        Type csharpArgumentInfoTypeEnumerableType = typeof(IEnumerable<>).MakeGenericType(csharpArgumentInfoType);

        MethodInfo getMemberMethod = binderType.GetMethod("GetMember", BindingFlags.Public | BindingFlags.Static, null, new[] { csharpBinderFlagsType, typeof(string), typeof(Type), csharpArgumentInfoTypeEnumerableType }, null);
        _getMemberCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(getMemberMethod);

        MethodInfo setMemberMethod = binderType.GetMethod("SetMember", BindingFlags.Public | BindingFlags.Static, null, new[] { csharpBinderFlagsType, typeof(string), typeof(Type), csharpArgumentInfoTypeEnumerableType }, null);
        _setMemberCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(setMemberMethod);
      }

      public static CallSiteBinder GetMember(string name, Type context)
      {
        Init();
        return (CallSiteBinder)_getMemberCall(null, 0, name, context, _getCSharpArgumentInfoArray);
      }

      public static CallSiteBinder SetMember(string name, Type context)
      {
        Init();
        return (CallSiteBinder)_setMemberCall(null, 0, name, context, _setCSharpArgumentInfoArray);
      }
    }

    public static bool TryGetMember(this IDynamicMetaObjectProvider dynamicProvider, string name, out object value)
    {
      ValidationUtils.ArgumentNotNull(dynamicProvider, "dynamicProvider");

      GetMemberBinder getMemberBinder = (GetMemberBinder) BinderWrapper.GetMember(name, typeof (DynamicUtils));

      CallSite<Func<CallSite, object, object>> callSite = CallSite<Func<CallSite, object, object>>.Create(new NoThrowGetBinderMember(getMemberBinder));

      object result = callSite.Target(callSite, dynamicProvider);

      if (!ReferenceEquals(result, NoThrowExpressionVisitor.ErrorResult))
      {
        value = result;
        return true;
      }
      else
      {
        value = null;
        return false;
      }
    }

    public static bool TrySetMember(this IDynamicMetaObjectProvider dynamicProvider, string name, object value)
    {
      ValidationUtils.ArgumentNotNull(dynamicProvider, "dynamicProvider");

      SetMemberBinder binder = (SetMemberBinder)BinderWrapper.SetMember(name, typeof(DynamicUtils));

      var setterSite = CallSite<Func<CallSite, object, object, object>>.Create(new NoThrowSetBinderMember(binder));

      object result = setterSite.Target(setterSite, dynamicProvider, value);

      return !ReferenceEquals(result, NoThrowExpressionVisitor.ErrorResult);
    }

    public static IEnumerable<string> GetDynamicMemberNames(this IDynamicMetaObjectProvider dynamicProvider)
    {
      DynamicMetaObject metaObject = dynamicProvider.GetMetaObject(Expression.Constant(dynamicProvider));
      return metaObject.GetDynamicMemberNames();
    }

    internal class NoThrowGetBinderMember : GetMemberBinder
    {
      private readonly GetMemberBinder _innerBinder;

      public NoThrowGetBinderMember(GetMemberBinder innerBinder)
        : base(innerBinder.Name, innerBinder.IgnoreCase)
      {
        _innerBinder = innerBinder;
      }

      public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
      {
        DynamicMetaObject retMetaObject = _innerBinder.Bind(target, new DynamicMetaObject[] { });

        NoThrowExpressionVisitor noThrowVisitor = new NoThrowExpressionVisitor();
        Expression resultExpression = noThrowVisitor.Visit(retMetaObject.Expression);

        DynamicMetaObject finalMetaObject = new DynamicMetaObject(resultExpression, retMetaObject.Restrictions);
        return finalMetaObject;
      }
    }

    internal class NoThrowSetBinderMember : SetMemberBinder
    {
      private readonly SetMemberBinder _innerBinder;

      public NoThrowSetBinderMember(SetMemberBinder innerBinder)
        : base(innerBinder.Name, innerBinder.IgnoreCase)
      {
        _innerBinder = innerBinder;
      }

      public override DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion)
      {
        DynamicMetaObject retMetaObject = _innerBinder.Bind(target, new DynamicMetaObject[] { value });

        NoThrowExpressionVisitor noThrowVisitor = new NoThrowExpressionVisitor();
        Expression resultExpression = noThrowVisitor.Visit(retMetaObject.Expression);

        DynamicMetaObject finalMetaObject = new DynamicMetaObject(resultExpression, retMetaObject.Restrictions);
        return finalMetaObject;
      }
    }

    internal class NoThrowExpressionVisitor : ExpressionVisitor
    {
      internal static readonly object ErrorResult = new object();

      protected override Expression VisitConditional(ConditionalExpression node)
      {
        // if the result of a test is to throw an error, rewrite to result an error result value
        if (node.IfFalse.NodeType == ExpressionType.Throw)
          return Expression.Condition(node.Test, node.IfTrue, Expression.Constant(ErrorResult));

        return base.VisitConditional(node);
      }
    }
  }
}
#endif
#endregion Utilities_DynamicUtils.cs

/// ********   File: \Utilities\DynamicWrapper.cs
#region Utilities_DynamicWrapper.cs

#if !(SILVERLIGHT || NETFX_CORE || PORTABLE)
#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal class DynamicWrapperBase
  {
    internal protected object UnderlyingObject;
  }

  internal static class DynamicWrapper
  {
    private static readonly object _lock = new object();
    private static readonly WrapperDictionary _wrapperDictionary = new WrapperDictionary();

    private static ModuleBuilder _moduleBuilder;

    private static ModuleBuilder ModuleBuilder
    {
      get
      {
        Init();
        return _moduleBuilder;
      }
    }

    private static void Init()
    {
      if (_moduleBuilder == null)
      {
        lock (_lock)
        {
          if (_moduleBuilder == null)
          {
            AssemblyName assemblyName = new AssemblyName("Newtonsoft.Json.Dynamic");
            assemblyName.KeyPair = new StrongNameKeyPair(GetStrongKey());

            AssemblyBuilder assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
            _moduleBuilder = assembly.DefineDynamicModule("Newtonsoft.Json.DynamicModule", false);
          }
        }
      }
    }

    private static byte[] GetStrongKey()
    {
      //const string name = "Newtonsoft.Json.Dynamic.snk";

      //using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(name))
      //{
      //  if (stream == null)
      //    throw new MissingManifestResourceException("Should have " + name + " as an embedded resource.");

      //  int length = (int)stream.Length;
      //  byte[] buffer = new byte[length];
      //  stream.Read(buffer, 0, length);

      //  return buffer;
      //}

        byte[] buffer = new byte[] {
            0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00,
            0x01, 0x00, 0x01, 0x00, 0xCB, 0xD8, 0xD5, 0x3B, 0x9D, 0x7D, 0x3E, 0x0F, 0x1F, 0x12, 0x78, 0xF6,
            0x36, 0xEC, 0x46, 0x2C, 0xF9, 0xC2, 0x54, 0x99, 0x12, 0x91, 0xE6, 0x6E, 0xBB, 0x15, 0x7A, 0x88,
            0x56, 0x38, 0xA5, 0x17, 0x88, 0x76, 0x33, 0xB8, 0x98, 0xCC, 0xBB, 0xF0, 0xD5, 0xC5, 0xFF, 0x7B,
            0xE8, 0x5A, 0x6A, 0xBE, 0x9E, 0x76, 0x5D, 0x0A, 0xC7, 0xCD, 0x33, 0xC6, 0x8D, 0xAC, 0x67, 0xE7,
            
            0xE6, 0x45, 0x30, 0xE8, 0x22, 0x21, 0x01, 0x10, 0x9F, 0x15, 0x4A, 0xB1, 0x4A, 0x94, 0x1C, 0x49,
            0x0A, 0xC1, 0x55, 0xCD, 0x1D, 0x4F, 0xCB, 0xA0, 0xFA, 0xBB, 0x49, 0x01, 0x6B, 0x4E, 0xF2, 0x85,
            0x93, 0xB0, 0x15, 0xCA, 0xB5, 0x93, 0x7D, 0xA3, 0x11, 0x72, 0xF0, 0x3F, 0x67, 0xD0, 0x9E, 0xDD,
            0xA4, 0x04, 0xB8, 0x8A, 0x60, 0x02, 0x3F, 0x06, 0x2A, 0xE7, 0x1D, 0x0B, 0x2E, 0x44, 0xE8, 0xB7,
            0x4C, 0xC1, 0x1D, 0xC9, 0x19, 0x24, 0x64, 0x93, 0xC2, 0x65, 0xD7, 0x34, 0x6B, 0x42, 0x7A, 0x8D,

            0xC1, 0xA1, 0xF5, 0x07, 0x0C, 0xA5, 0xA9, 0x54, 0x26, 0x4D, 0x3A, 0x3D, 0xAE, 0xBC, 0x77, 0xD8,
            0x9E, 0xF6, 0x7C, 0xDB, 0xE3, 0xB9, 0x8E, 0x3A, 0xB7, 0x04, 0x99, 0x27, 0xDA, 0x3C, 0xA9, 0x63,
            0xFB, 0xE2, 0x95, 0xCD, 0xC9, 0xD9, 0x0F, 0xF8, 0x51, 0x4D, 0x4F, 0x65, 0xAA, 0xE0, 0x32, 0xE3,
            0x23, 0x16, 0x5A, 0xE9, 0x83, 0x60, 0x3E, 0x24, 0x42, 0x0E, 0x65, 0x76, 0x81, 0x23, 0xA8, 0x63,
            0xE0, 0x0B, 0x48, 0xDA, 0x3A, 0x94, 0xF3, 0xB9, 0x8E, 0x46, 0x51, 0x4D, 0x73, 0xC6, 0x5F, 0x07,

            0xC1, 0xE8, 0xFE, 0x47, 0xD2, 0x78, 0x0F, 0x70, 0x6A, 0x4D, 0x4C, 0x4A, 0x45, 0x54, 0xD9, 0x41,
            0x4D, 0xE7, 0x05, 0x56, 0x80, 0x04, 0x64, 0x14, 0x6E, 0x84, 0x6E, 0xCF, 0xD8, 0x85, 0xB8, 0x27,
            0xE3, 0xBB, 0xA2, 0xDC, 0x61, 0xBE, 0x88, 0x82, 0xEF, 0xEE, 0xBD, 0x00, 0x1D, 0xAD, 0x24, 0x92,
            0x16, 0xF0, 0x01, 0x78, 0xDF, 0x79, 0xCD, 0x7C, 0x7B, 0x32, 0xCC, 0x07, 0xE8, 0x6B, 0x5C, 0xA3,
            0xA1, 0x46, 0xAF, 0xF9, 0x2C, 0xC4, 0xDA, 0xA7, 0xFE, 0x7A, 0x9C, 0x8C, 0x97, 0xD4, 0x77, 0xC6,

            0x01, 0xA5, 0x6F, 0xD8, 0xD3, 0x7C, 0x4A, 0xB7, 0xD0, 0xA9, 0x2F, 0xD9, 0x28, 0xEF, 0x09, 0x25,
            0x4E, 0xE0, 0x37, 0xC4, 0x73, 0x6A, 0xDD, 0x14, 0x80, 0xF1, 0xD1, 0x5F, 0xAC, 0x4A, 0x54, 0xAF,
            0x00, 0x6B, 0x42, 0x9E, 0xCF, 0x13, 0xC1, 0x2E, 0xE4, 0xD5, 0xBB, 0x3A, 0x37, 0xF9, 0x6D, 0x46,
            0x06, 0x69, 0xEF, 0xC5, 0x47, 0x62, 0x37, 0x94, 0xFB, 0x0A, 0x1C, 0x3D, 0xC0, 0x51, 0xD0, 0xD1,
            0x42, 0xE9, 0x60, 0x53, 0xFB, 0x4F, 0xC8, 0xE0, 0x0E, 0x12, 0xDD, 0x2A, 0x74, 0xB5, 0x8B, 0xA4,

            0x1E, 0xCC, 0x7B, 0xAB, 0x2F, 0x3D, 0x6A, 0x8E, 0x33, 0x03, 0x46, 0x15, 0xE4, 0xF6, 0xD6, 0x5B,
            0x99, 0xF9, 0xDF, 0x08, 0xC2, 0x54, 0x56, 0x7A, 0x10, 0x0E, 0xAD, 0xD3, 0x4A, 0x7C, 0xE9, 0x48,
            0x81, 0x5A, 0xE1, 0xCC, 0x49, 0x8F, 0x66, 0x33, 0x9F, 0xA7, 0x52, 0x58, 0xA9, 0x6E, 0xD4, 0xD8,
            0xC3, 0x15, 0xBB, 0xDA, 0xA3, 0xEA, 0xAA, 0x79, 0x24, 0x60, 0x90, 0x02, 0xBC, 0xCB, 0x07, 0x26,
            0x2B, 0x7D, 0x8E, 0xAB, 0x41, 0x18, 0xCA, 0x83, 0x47, 0xCC, 0xF3, 0x08, 0x1F, 0xD0, 0xA4, 0x55,

            0x98, 0xB5, 0x87, 0x4C, 0x6F, 0x8C, 0xB3, 0x0A, 0xA9, 0x15, 0x30, 0x02, 0x79, 0xC9, 0x1C, 0xB2,
            0xE6, 0x3E, 0xAC, 0xD2, 0x5D, 0x89, 0x62, 0x40, 0x4F, 0xB7, 0xF6, 0x8A, 0x9D, 0x8E, 0xBB, 0x68,
            0x86, 0x16, 0x47, 0xEB, 0x7B, 0xC4, 0x33, 0xA5, 0x94, 0x6C, 0xFF, 0xC4, 0xAF, 0x73, 0x47, 0xE9,
            0x0E, 0x29, 0x8B, 0xB0, 0x65, 0x86, 0x50, 0xFE, 0xE6, 0xD5, 0x86, 0xFD, 0xCF, 0x43, 0xE4, 0xB9,
            0x91, 0x71, 0x60, 0x22, 0x4F, 0xB8, 0x68, 0x1A, 0xF5, 0x8D, 0x7B, 0xC8, 0xC8, 0x6C, 0x29, 0x4A,

            0x3C, 0x54, 0x82, 0x25, 0x17, 0xCD, 0xE3, 0xA6, 0x43, 0xF1, 0x97, 0x79, 0x9C, 0x85, 0x55, 0x83,
            0xA2, 0x57, 0x26, 0x93, 0xBA, 0x73, 0xB7, 0x72, 0xC0, 0xD8, 0x81, 0x63, 0xF6, 0x9F, 0x0C, 0x1C,
            0xAB, 0x41, 0xD4, 0x88,
      };

        return buffer;
    }

    public static Type GetWrapper(Type interfaceType, Type realObjectType)
    {
      Type wrapperType = _wrapperDictionary.GetType(interfaceType, realObjectType);

      if (wrapperType == null)
      {
        lock (_lock)
        {
          wrapperType = _wrapperDictionary.GetType(interfaceType, realObjectType);

          if (wrapperType == null)
          {
            wrapperType = GenerateWrapperType(interfaceType, realObjectType);
            _wrapperDictionary.SetType(interfaceType, realObjectType, wrapperType);
          }
        }
      }

      return wrapperType;
    }

    public static object GetUnderlyingObject(object wrapper)
    {
      DynamicWrapperBase wrapperBase = wrapper as DynamicWrapperBase;
      if (wrapperBase == null)
        throw new ArgumentException("Object is not a wrapper.", "wrapper");

      return wrapperBase.UnderlyingObject;
    }

    private static Type GenerateWrapperType(Type interfaceType, Type underlyingType)
    {
      TypeBuilder wrapperBuilder = ModuleBuilder.DefineType(
          "{0}_{1}_Wrapper".FormatWith(CultureInfo.InvariantCulture, interfaceType.Name, underlyingType.Name),
          TypeAttributes.NotPublic | TypeAttributes.Sealed,
          typeof(DynamicWrapperBase),
          new[] { interfaceType });

      WrapperMethodBuilder wrapperMethod = new WrapperMethodBuilder(underlyingType, wrapperBuilder);

      foreach (MethodInfo method in interfaceType.GetAllMethods())
      {
        wrapperMethod.Generate(method);
      }

      return wrapperBuilder.CreateType();
    }

    public static T CreateWrapper<T>(object realObject) where T : class
    {
      var dynamicType = GetWrapper(typeof(T), realObject.GetType());
      var dynamicWrapper = (DynamicWrapperBase)Activator.CreateInstance(dynamicType);

      dynamicWrapper.UnderlyingObject = realObject;

      return dynamicWrapper as T;
    }
  }

  internal class WrapperMethodBuilder
  {
    private readonly Type _realObjectType;
    private readonly TypeBuilder _wrapperBuilder;

    public WrapperMethodBuilder(Type realObjectType, TypeBuilder proxyBuilder)
    {
      _realObjectType = realObjectType;
      _wrapperBuilder = proxyBuilder;
    }

    public void Generate(MethodInfo newMethod)
    {
      if (newMethod.IsGenericMethod)
        newMethod = newMethod.GetGenericMethodDefinition();

      FieldInfo srcField = typeof(DynamicWrapperBase).GetField("UnderlyingObject", BindingFlags.Instance | BindingFlags.NonPublic);

      var parameters = newMethod.GetParameters();
      var parameterTypes = parameters.Select(parameter => parameter.ParameterType).ToArray();

      MethodBuilder methodBuilder = _wrapperBuilder.DefineMethod(
          newMethod.Name,
          MethodAttributes.Public | MethodAttributes.Virtual,
          newMethod.ReturnType,
          parameterTypes);

      if (newMethod.IsGenericMethod)
      {
        methodBuilder.DefineGenericParameters(
            newMethod.GetGenericArguments().Select(arg => arg.Name).ToArray());
      }

      ILGenerator ilGenerator = methodBuilder.GetILGenerator();

      LoadUnderlyingObject(ilGenerator, srcField);
      PushParameters(parameters, ilGenerator);
      ExecuteMethod(newMethod, parameterTypes, ilGenerator);
      Return(ilGenerator);
    }

    private static void Return(ILGenerator ilGenerator)
    {
      ilGenerator.Emit(OpCodes.Ret);
    }

    private void ExecuteMethod(MethodBase newMethod, Type[] parameterTypes, ILGenerator ilGenerator)
    {
      MethodInfo srcMethod = GetMethod(newMethod, parameterTypes);

      if (srcMethod == null)
        throw new MissingMethodException("Unable to find method " + newMethod.Name + " on " + _realObjectType.FullName);

      ilGenerator.Emit(OpCodes.Call, srcMethod);
    }

    private MethodInfo GetMethod(MethodBase realMethod, Type[] parameterTypes)
    {
      if (realMethod.IsGenericMethod)
        return _realObjectType.GetGenericMethod(realMethod.Name, parameterTypes);

      return _realObjectType.GetMethod(realMethod.Name, parameterTypes);
    }

    private static void PushParameters(ICollection<ParameterInfo> parameters, ILGenerator ilGenerator)
    {
      for (int i = 1; i < parameters.Count + 1; i++)
        ilGenerator.Emit(OpCodes.Ldarg, i);
    }

    private static void LoadUnderlyingObject(ILGenerator ilGenerator, FieldInfo srcField)
    {
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldfld, srcField);
    }
  }

  internal class WrapperDictionary
  {
    private readonly Dictionary<string, Type> _wrapperTypes = new Dictionary<string, Type>();

    private static string GenerateKey(Type interfaceType, Type realObjectType)
    {
      return interfaceType.Name + "_" + realObjectType.Name;
    }

    public Type GetType(Type interfaceType, Type realObjectType)
    {
      string key = GenerateKey(interfaceType, realObjectType);

      if (_wrapperTypes.ContainsKey(key))
        return _wrapperTypes[key];

      return null;
    }

    public void SetType(Type interfaceType, Type realObjectType, Type wrapperType)
    {
      string key = GenerateKey(interfaceType, realObjectType);

      if (_wrapperTypes.ContainsKey(key))
        _wrapperTypes[key] = wrapperType;
      else
        _wrapperTypes.Add(key, wrapperType);
    }
  }
}
#endif
#endregion Utilities_DynamicWrapper.cs

/// ********   File: \Utilities\EnumUtils.cs
#region Utilities_EnumUtils.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal static class EnumUtils
  {
    public static IList<T> GetFlagsValues<T>(T value) where T : struct
    {
      Type enumType = typeof(T);

      if (!enumType.IsDefined(typeof(FlagsAttribute), false))
        throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, enumType));

      Type underlyingType = Enum.GetUnderlyingType(value.GetType());

      ulong num = Convert.ToUInt64(value, CultureInfo.InvariantCulture);
      EnumValues<ulong> enumNameValues = GetNamesAndValues<T>();
      IList<T> selectedFlagsValues = new List<T>();

      foreach (EnumValue<ulong> enumNameValue in enumNameValues)
      {
        if ((num & enumNameValue.Value) == enumNameValue.Value && enumNameValue.Value != 0)
          selectedFlagsValues.Add((T)Convert.ChangeType(enumNameValue.Value, underlyingType, CultureInfo.CurrentCulture));
      }

      if (selectedFlagsValues.Count == 0 && enumNameValues.SingleOrDefault(v => v.Value == 0) != null)
        selectedFlagsValues.Add(default(T));

      return selectedFlagsValues;
    }

    /// <summary>
    /// Gets a dictionary of the names and values of an Enum type.
    /// </summary>
    /// <returns></returns>
    public static EnumValues<ulong> GetNamesAndValues<T>() where T : struct
    {
      return GetNamesAndValues<ulong>(typeof(T));
    }

    /// <summary>
    /// Gets a dictionary of the names and values of an Enum type.
    /// </summary>
    /// <param name="enumType">The enum type to get names and values for.</param>
    /// <returns></returns>
    public static EnumValues<TUnderlyingType> GetNamesAndValues<TUnderlyingType>(Type enumType) where TUnderlyingType : struct
    {
      if (enumType == null)
        throw new ArgumentNullException("enumType");

      ValidationUtils.ArgumentTypeIsEnum(enumType, "enumType");

      IList<object> enumValues = GetValues(enumType);
      IList<string> enumNames = GetNames(enumType);

      EnumValues<TUnderlyingType> nameValues = new EnumValues<TUnderlyingType>();

      for (int i = 0; i < enumValues.Count; i++)
      {
        try
        {
          nameValues.Add(new EnumValue<TUnderlyingType>(enumNames[i], (TUnderlyingType)Convert.ChangeType(enumValues[i], typeof(TUnderlyingType), CultureInfo.CurrentCulture)));
        }
        catch (OverflowException e)
        {
          throw new InvalidOperationException(
            string.Format(CultureInfo.InvariantCulture, "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}",
              Enum.GetUnderlyingType(enumType), typeof(TUnderlyingType), Convert.ToUInt64(enumValues[i], CultureInfo.InvariantCulture)), e);
        }
      }

      return nameValues;
    }

    public static IList<object> GetValues(Type enumType)
    {
      if (!enumType.IsEnum())
        throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");

      List<object> values = new List<object>();

      var fields = from field in enumType.GetFields()
                   where field.IsLiteral
                   select field;

      foreach (FieldInfo field in fields)
      {
        object value = field.GetValue(enumType);
        values.Add(value);
      }

      return values;
    }

    public static IList<string> GetNames(Type enumType)
    {
      if (!enumType.IsEnum())
        throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");

      List<string> values = new List<string>();

      var fields = from field in enumType.GetFields()
                   where field.IsLiteral
                   select field;

      foreach (FieldInfo field in fields)
      {
        values.Add(field.Name);
      }

      return values;
    }
  }
}
#endregion Utilities_EnumUtils.cs

/// ********   File: \Utilities\EnumValue.cs
#region Utilities_EnumValue.cs

namespace Newtonsoft.Json.Utilities
{
  internal class EnumValue<T> where T : struct
  {
    private readonly string _name;
    private readonly T _value;

    public string Name
    {
      get { return _name; }
    }
    public T Value
    {
      get { return _value; }
    }

    public EnumValue(string name, T value)
    {
      _name = name;
      _value = value;
    }
  }
}
#endregion Utilities_EnumValue.cs

/// ********   File: \Utilities\EnumValues.cs
#region Utilities_EnumValues.cs

namespace Newtonsoft.Json.Utilities
{
  internal class EnumValues<T> : KeyedCollection<string, EnumValue<T>> where T : struct
  {
    protected override string GetKeyForItem(EnumValue<T> item)
    {
      return item.Name;
    }
  }
}
#endregion Utilities_EnumValues.cs

/// ********   File: \Utilities\ILGeneratorExtensions.cs
#region Utilities_ILGeneratorExtensions.cs

#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)

namespace Newtonsoft.Json.Utilities
{
  internal static class ILGeneratorExtensions
  {
    public static void PushInstance(this ILGenerator generator, Type type)
    {
      generator.Emit(OpCodes.Ldarg_0);
      if (type.IsValueType())
        generator.Emit(OpCodes.Unbox, type);
      else
        generator.Emit(OpCodes.Castclass, type);
    }

    public static void BoxIfNeeded(this ILGenerator generator, Type type)
    {
      if (type.IsValueType())
        generator.Emit(OpCodes.Box, type);
      else
        generator.Emit(OpCodes.Castclass, type);
    }

    public static void UnboxIfNeeded(this ILGenerator generator, Type type)
    {
      if (type.IsValueType())
        generator.Emit(OpCodes.Unbox_Any, type);
      else
        generator.Emit(OpCodes.Castclass, type);
    }

    public static void CallMethod(this ILGenerator generator, MethodInfo methodInfo)
    {
      if (methodInfo.IsFinal || !methodInfo.IsVirtual)
        generator.Emit(OpCodes.Call, methodInfo);
      else
        generator.Emit(OpCodes.Callvirt, methodInfo);
    }

    public static void Return(this ILGenerator generator)
    {
      generator.Emit(OpCodes.Ret);
    }
  }
}
#endif
#endregion Utilities_ILGeneratorExtensions.cs

/// ********   File: \Utilities\JavaScriptUtils.cs
#region Utilities_JavaScriptUtils.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal static class JavaScriptUtils
  {
    internal static readonly bool[] SingleQuoteCharEscapeFlags = new bool[128];
    internal static readonly bool[] DoubleQuoteCharEscapeFlags = new bool[128];
    internal static readonly bool[] HtmlCharEscapeFlags = new bool[128];

    static JavaScriptUtils()
    {
      IList<char> escapeChars = new List<char>
      {
        '\n', '\r', '\t', '\\', '\f', '\b',
      };
      for (int i = 0; i < ' '; i++)
      {
        escapeChars.Add((char)i);
      }

      foreach (var escapeChar in escapeChars.Union(new[] { '\'' }))
      {
        SingleQuoteCharEscapeFlags[escapeChar] = true;
      }
      foreach (var escapeChar in escapeChars.Union(new[] { '"' }))
      {
        DoubleQuoteCharEscapeFlags[escapeChar] = true;
      }
      foreach (var escapeChar in escapeChars.Union(new[] { '"', '\'', '<', '>', '&' }))
      {
        HtmlCharEscapeFlags[escapeChar] = true;
      }
    }

    private const string EscapedUnicodeText = "!";

    public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling)
    {
      // leading delimiter
      if (appendDelimiters)
        writer.Write(delimiter);

      if (s != null)
      {
        char[] chars = null;
        char[] unicodeBuffer = null;
        int lastWritePosition = 0;

        for (int i = 0; i < s.Length; i++)
        {
          var c = s[i];

          if (c < charEscapeFlags.Length && !charEscapeFlags[c])
            continue;

          string escapedValue;

          switch (c)
          {
            case '\t':
              escapedValue = @"\t";
              break;
            case '\n':
              escapedValue = @"\n";
              break;
            case '\r':
              escapedValue = @"\r";
              break;
            case '\f':
              escapedValue = @"\f";
              break;
            case '\b':
              escapedValue = @"\b";
              break;
            case '\\':
              escapedValue = @"\\";
              break;
            case '\u0085': // Next Line
              escapedValue = @"\u0085";
              break;
            case '\u2028': // Line Separator
              escapedValue = @"\u2028";
              break;
            case '\u2029': // Paragraph Separator
              escapedValue = @"\u2029";
              break;
            default:
              if (c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
              {
                if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
                {
                  escapedValue = @"\'";
                }
                else if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
                {
                  escapedValue = @"\""";
                }
                else
                {
                  if (unicodeBuffer == null)
                    unicodeBuffer = new char[6];

                  StringUtils.ToCharAsUnicode(c, unicodeBuffer);

                  // slightly hacky but it saves multiple conditions in if test
                  escapedValue = EscapedUnicodeText;
                }
              }
              else
              {
                escapedValue = null;
              }
              break;
          }

          if (escapedValue == null)
            continue;

          if (i > lastWritePosition)
          {
            if (chars == null)
              chars = s.ToCharArray();

            // write unchanged chars before writing escaped text
            writer.Write(chars, lastWritePosition, i - lastWritePosition);
          }

          lastWritePosition = i + 1;
          if (!string.Equals(escapedValue, EscapedUnicodeText))
            writer.Write(escapedValue);
          else
            writer.Write(unicodeBuffer);
        }

        if (lastWritePosition == 0)
        {
          // no escaped text, write entire string
          writer.Write(s);
        }
        else
        {
          if (chars == null)
            chars = s.ToCharArray();

          // write remaining text
          writer.Write(chars, lastWritePosition, s.Length - lastWritePosition);
        }
      }

      // trailing delimiter
      if (appendDelimiters)
        writer.Write(delimiter);
    }

    public static string ToEscapedJavaScriptString(string value)
    {
      return ToEscapedJavaScriptString(value, '"', true);
    }

    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters)
    {
      using (StringWriter w = StringUtils.CreateStringWriter(StringUtils.GetLength(value) ?? 16))
      {
        WriteEscapedJavaScriptString(w, value, delimiter, appendDelimiters, (delimiter == '"') ? DoubleQuoteCharEscapeFlags : SingleQuoteCharEscapeFlags, StringEscapeHandling.Default);
        return w.ToString();
      }
    }
  }
}
#endregion Utilities_JavaScriptUtils.cs

/// ********   File: \Utilities\LateBoundReflectionDelegateFactory.cs
#region Utilities_LateBoundReflectionDelegateFactory.cs

#if NET20
#endif

namespace Newtonsoft.Json.Utilities
{
  internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
  {
    private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

    internal static ReflectionDelegateFactory Instance
    {
      get { return _instance; }
    }

    public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
    {
      ValidationUtils.ArgumentNotNull(method, "method");

      ConstructorInfo c = method as ConstructorInfo;
      if (c != null)
        return (o, a) => c.Invoke(a);

      return (o, a) => method.Invoke(o, a);
    }

    public override Func<T> CreateDefaultConstructor<T>(Type type)
    {
      ValidationUtils.ArgumentNotNull(type, "type");

      if (type.IsValueType())
        return () => (T)ReflectionUtils.CreateInstance(type);

      ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, true);

      return () => (T)constructorInfo.Invoke(null);
    }

    public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
    {
      ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");

      return o => propertyInfo.GetValue(o, null);
    }

    public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
    {
      ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");

      return o => fieldInfo.GetValue(o);
    }

    public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
    {
      ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");

      return (o, v) => fieldInfo.SetValue(o, v);
    }

    public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
    {
      ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");

      return (o, v) => propertyInfo.SetValue(o, v, null);
    }
  }
}
#endregion Utilities_LateBoundReflectionDelegateFactory.cs

/// ********   File: \Utilities\ListWrapper.cs
#region Utilities_ListWrapper.cs

namespace Newtonsoft.Json.Utilities
{
  internal interface IWrappedList : IList
  {
    object UnderlyingList { get; }
  }

  internal class ListWrapper<T> : CollectionWrapper<T>, IList<T>, IWrappedList
  {
    private readonly IList<T> _genericList;

    public ListWrapper(IList list)
      : base(list)
    {
      ValidationUtils.ArgumentNotNull(list, "list");

      if (list is IList<T>)
        _genericList = (IList<T>) list;
    }

    public ListWrapper(IList<T> list)
      : base(list)
    {
      ValidationUtils.ArgumentNotNull(list, "list");

      _genericList = list;
    }

    public int IndexOf(T item)
    {
      if (_genericList != null)
        return _genericList.IndexOf(item);
      else
        return ((IList)this).IndexOf(item);
    }

    public void Insert(int index, T item)
    {
      if (_genericList != null)
        _genericList.Insert(index, item);
      else
        ((IList)this).Insert(index, item);
    }

    public void RemoveAt(int index)
    {
      if (_genericList != null)
        _genericList.RemoveAt(index);
      else
        ((IList)this).RemoveAt(index);
    }

    public T this[int index]
    {
      get
      {
        if (_genericList != null)
          return _genericList[index];
        else
          return (T)((IList)this)[index];
      }
      set
      {
        if (_genericList != null)
          _genericList[index] = value;
        else
          ((IList)this)[index] = value;
      }
    }

    public override void Add(T item)
    {
      if (_genericList != null)
        _genericList.Add(item);
      else
        base.Add(item);
    }

    public override void Clear()
    {
      if (_genericList != null)
        _genericList.Clear();
      else
        base.Clear();
    }

    public override bool Contains(T item)
    {
      if (_genericList != null)
        return _genericList.Contains(item);
      else
        return base.Contains(item);
    }

    public override void CopyTo(T[] array, int arrayIndex)
    {
      if (_genericList != null)
        _genericList.CopyTo(array, arrayIndex);
      else
        base.CopyTo(array, arrayIndex);
    }

    public override int Count
    {
      get
      {
        if (_genericList != null)
          return _genericList.Count;
        else
          return base.Count;
      }
    }

    public override bool IsReadOnly
    {
      get
      {
        if (_genericList != null)
          return _genericList.IsReadOnly;
        else
          return base.IsReadOnly;
      }
    }

    public override bool Remove(T item)
    {
      if (_genericList != null)
      {
        return _genericList.Remove(item);
      }
      else
      {
        bool contains = base.Contains(item);

        if (contains)
          base.Remove(item);

        return contains;
      }
    }

    public override IEnumerator<T> GetEnumerator()
    {
      if (_genericList != null)
        return _genericList.GetEnumerator();

      return base.GetEnumerator();
    }

    public object UnderlyingList
    {
      get
      {
        if (_genericList != null)
          return _genericList;
        else
          return UnderlyingCollection;
      }
    }
  }
}
#endregion Utilities_ListWrapper.cs

/// ********   File: \Utilities\MathUtils.cs
#region Utilities_MathUtils.cs

namespace Newtonsoft.Json.Utilities
{
  internal class MathUtils
  {
    public static int IntLength(int i)
    {
      if (i < 0)
        throw new ArgumentOutOfRangeException();

      if (i == 0)
        return 1;

      return (int)Math.Floor(Math.Log10(i)) + 1;
    }

    public static char IntToHex(int n)
    {
      if (n <= 9)
        return (char)(n + 48);

      return (char)((n - 10) + 97);
    }

    public static int? Min(int? val1, int? val2)
    {
      if (val1 == null)
        return val2;
      if (val2 == null)
        return val1;

      return Math.Min(val1.Value, val2.Value);
    }

    public static int? Max(int? val1, int? val2)
    {
      if (val1 == null)
        return val2;
      if (val2 == null)
        return val1;

      return Math.Max(val1.Value, val2.Value);
    }

    public static double? Max(double? val1, double? val2)
    {
      if (val1 == null)
        return val2;
      if (val2 == null)
        return val1;

      return Math.Max(val1.Value, val2.Value);
    }

    public static bool ApproxEquals(double d1, double d2)
    {
      const double epsilon = 2.2204460492503131E-16;

      if (d1 == d2)
        return true;

      double tolerance = ((Math.Abs(d1) + Math.Abs(d2)) + 10.0) * epsilon;
      double difference = d1 - d2;

      return (-tolerance < difference && tolerance > difference);
    }
  }
}
#endregion Utilities_MathUtils.cs

/// ********   File: \Utilities\MethodCall.cs
#region Utilities_MethodCall.cs

namespace Newtonsoft.Json.Utilities
{
  internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);
}
#endregion Utilities_MethodCall.cs

/// ********   File: \Utilities\MiscellaneousUtils.cs
#region Utilities_MiscellaneousUtils.cs

namespace Newtonsoft.Json.Utilities
{
  internal delegate T Creator<T>();

  internal static class MiscellaneousUtils
  {
    public static bool ValueEquals(object objA, object objB)
    {
      if (objA == null && objB == null)
        return true;
      if (objA != null && objB == null)
        return false;
      if (objA == null && objB != null)
        return false;

      // comparing an Int32 and Int64 both of the same value returns false
      // make types the same then compare
      if (objA.GetType() != objB.GetType())
      {
        if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
          return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
        else if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
          return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
        else
          return false;
      }

      return objA.Equals(objB);
    }

    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
    {
      string newMessage = message + Environment.NewLine + @"Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);

      return new ArgumentOutOfRangeException(paramName, newMessage);
    }

    public static bool TryAction<T>(Creator<T> creator, out T output)
    {
      ValidationUtils.ArgumentNotNull(creator, "creator");

      try
      {
        output = creator();
        return true;
      }
      catch
      {
        output = default(T);
        return false;
      }
    }

    public static string ToString(object value)
    {
      if (value == null)
        return "{null}";

      return (value is string) ? @"""" + value.ToString() + @"""" : value.ToString();
    }

    public static byte[] HexToBytes(string hex)
    {
      string fixedHex = hex.Replace("-", string.Empty);

      // array to put the result in
      byte[] bytes = new byte[fixedHex.Length / 2];
      // variable to determine shift of high/low nibble
      int shift = 4;
      // offset of the current byte in the array
      int offset = 0;
      // loop the characters in the string
      foreach (char c in fixedHex)
      {
        // get character code in range 0-9, 17-22
        // the % 32 handles lower case characters
        int b = (c - '0') % 32;
        // correction for a-f
        if (b > 9) b -= 7;
        // store nibble (4 bits) in byte array
        bytes[offset] |= (byte)(b << shift);
        // toggle the shift variable between 0 and 4
        shift ^= 4;
        // move to next byte
        if (shift != 0) offset++;
      }
      return bytes;
    }

    public static string BytesToHex(byte[] bytes)
    {
      return BytesToHex(bytes, false);
    }

    public static string BytesToHex(byte[] bytes, bool removeDashes)
    {
      string hex = BitConverter.ToString(bytes);
      if (removeDashes)
        hex = hex.Replace("-", "");

      return hex;
    }

    public static int ByteArrayCompare(byte[] a1, byte[] a2)
    {
      int lengthCompare = a1.Length.CompareTo(a2.Length);
      if (lengthCompare != 0)
        return lengthCompare;

      for (int i = 0; i < a1.Length; i++)
      {
        int valueCompare = a1[i].CompareTo(a2[i]);
        if (valueCompare != 0)
          return valueCompare;
      }

      return 0;
    }

    public static string GetPrefix(string qualifiedName)
    {
      string prefix;
      string localName;
      GetQualifiedNameParts(qualifiedName, out prefix, out localName);

      return prefix;
    }

    public static string GetLocalName(string qualifiedName)
    {
      string prefix;
      string localName;
      GetQualifiedNameParts(qualifiedName, out prefix, out localName);

      return localName;
    }

    public static void GetQualifiedNameParts(string qualifiedName, out string prefix, out string localName)
    {
      int colonPosition = qualifiedName.IndexOf(':');

      if ((colonPosition == -1 || colonPosition == 0) || (qualifiedName.Length - 1) == colonPosition)
      {
        prefix = null;
        localName = qualifiedName;
      }
      else
      {
        prefix = qualifiedName.Substring(0, colonPosition);
        localName = qualifiedName.Substring(colonPosition + 1);
      }
    }
  }
}
#endregion Utilities_MiscellaneousUtils.cs

/// ********   File: \Utilities\ReflectionDelegateFactory.cs
#region Utilities_ReflectionDelegateFactory.cs

#if NET20
#endif

namespace Newtonsoft.Json.Utilities
{
  internal abstract class ReflectionDelegateFactory
  {
    public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
    {
      PropertyInfo propertyInfo = memberInfo as PropertyInfo;
      if (propertyInfo != null)
        return CreateGet<T>(propertyInfo);

      FieldInfo fieldInfo = memberInfo as FieldInfo;
      if (fieldInfo != null)
        return CreateGet<T>(fieldInfo);

      throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
    }

    public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
    {
      PropertyInfo propertyInfo = memberInfo as PropertyInfo;
      if (propertyInfo != null)
        return CreateSet<T>(propertyInfo);

      FieldInfo fieldInfo = memberInfo as FieldInfo;
      if (fieldInfo != null)
        return CreateSet<T>(fieldInfo);

      throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
    }

    public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);
    public abstract Func<T> CreateDefaultConstructor<T>(Type type);
    public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);
    public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);
    public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);
    public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
  }
}
#endregion Utilities_ReflectionDelegateFactory.cs

/// ********   File: \Utilities\ReflectionUtils.cs
#region Utilities_ReflectionUtils.cs

#if NETFX_CORE
#endif
#if NETFX_CORE || PORTABLE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
#if NETFX_CORE || PORTABLE
  internal enum MemberTypes
  {
    Property,
    Field,
    Event,
    Method,
    Other
  }

  internal class CustomAttributeProvider
  {
    private readonly object _underlyingObject;

    public CustomAttributeProvider(object o)
    {
      _underlyingObject = o;
    }

    public object UnderlyingObject
    {
      get { return _underlyingObject; }
    }
  }
#endif

#if NETFX_CORE
  internal enum TypeCode
  {
    Empty,
    Object,
    String,
    Char,
    Boolean,
    SByte,
    Int16,
    UInt16,
    Int32,
    Byte,
    UInt32,
    Int64,
    UInt64,
    Single,
    Double,
    DateTime,
    Decimal
  }

  [Flags]
  internal enum BindingFlags
  {
    Default = 0,
    IgnoreCase = 1,
    DeclaredOnly = 2,
    Instance = 4,
    Static = 8,
    Public = 16,
    NonPublic = 32,
    FlattenHierarchy = 64,
    InvokeMethod = 256,
    CreateInstance = 512,
    GetField = 1024,
    SetField = 2048,
    GetProperty = 4096,
    SetProperty = 8192,
    PutDispProperty = 16384,
    ExactBinding = 65536,
    PutRefDispProperty = 32768,
    SuppressChangeType = 131072,
    OptionalParamBinding = 262144,
    IgnoreReturn = 16777216
  }
#endif

  internal static class ReflectionUtils
  {
    public static readonly Type[] EmptyTypes;

    static ReflectionUtils()
    {
#if !(NETFX_CORE || PORTABLE)
      EmptyTypes = Type.EmptyTypes;
#else
      EmptyTypes = new Type[0];
#endif
    }

    public static ICustomAttributeProvider GetCustomAttributeProvider(this object o)
    {
#if !(NETFX_CORE || PORTABLE)
      return (ICustomAttributeProvider)o;
#else
      return new ICustomAttributeProvider(o);
#endif
    }

    public static bool IsVirtual(this PropertyInfo propertyInfo)
    {
      ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");

      MethodInfo m = propertyInfo.GetGetMethod();
      if (m != null && m.IsVirtual)
        return true;

      m = propertyInfo.GetSetMethod();
      if (m != null && m.IsVirtual)
        return true;

      return false;
    }

    public static Type GetObjectType(object v)
    {
      return (v != null) ? v.GetType() : null;
    }

    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat)
    {
      return GetTypeName(t, assemblyFormat, null);
    }

    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
    {
      string fullyQualifiedTypeName;
#if !(NET20 || NET35)
      if (binder != null)
      {
        string assemblyName, typeName;
        binder.BindToName(t, out assemblyName, out typeName);
        fullyQualifiedTypeName = typeName + (assemblyName == null ? "" : ", " + assemblyName);
      }
      else
      {
        fullyQualifiedTypeName = t.AssemblyQualifiedName;
      }
#else
      fullyQualifiedTypeName = t.AssemblyQualifiedName;
#endif

      switch (assemblyFormat)
      {
        case FormatterAssemblyStyle.Simple:
          return RemoveAssemblyDetails(fullyQualifiedTypeName);
        case FormatterAssemblyStyle.Full:
          return fullyQualifiedTypeName;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
    {
      StringBuilder builder = new StringBuilder();

      // loop through the type name and filter out qualified assembly details from nested type names
      bool writingAssemblyName = false;
      bool skippingAssemblyDetails = false;
      for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
      {
        char current = fullyQualifiedTypeName[i];
        switch (current)
        {
          case '[':
            writingAssemblyName = false;
            skippingAssemblyDetails = false;
            builder.Append(current);
            break;
          case ']':
            writingAssemblyName = false;
            skippingAssemblyDetails = false;
            builder.Append(current);
            break;
          case ',':
            if (!writingAssemblyName)
            {
              writingAssemblyName = true;
              builder.Append(current);
            }
            else
            {
              skippingAssemblyDetails = true;
            }
            break;
          default:
            if (!skippingAssemblyDetails)
              builder.Append(current);
            break;
        }
      }

      return builder.ToString();
    }

    public static bool IsInstantiatableType(Type t)
    {
      ValidationUtils.ArgumentNotNull(t, "t");

      if (t.IsAbstract() || t.IsInterface() || t.IsArray || t.IsGenericTypeDefinition() || t == typeof(void))
        return false;

      if (!HasDefaultConstructor(t))
        return false;

      return true;
    }

    public static bool HasDefaultConstructor(Type t)
    {
      return HasDefaultConstructor(t, false);
    }

    public static bool HasDefaultConstructor(Type t, bool nonPublic)
    {
      ValidationUtils.ArgumentNotNull(t, "t");

      if (t.IsValueType())
        return true;

      return (GetDefaultConstructor(t, nonPublic) != null);
    }

    public static ConstructorInfo GetDefaultConstructor(Type t)
    {
      return GetDefaultConstructor(t, false);
    }

    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
    {
      BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
      if (nonPublic)
        bindingFlags = bindingFlags | BindingFlags.NonPublic;

      return t.GetConstructors(bindingFlags).SingleOrDefault(c => !c.GetParameters().Any());
    }

    public static bool IsNullable(Type t)
    {
      ValidationUtils.ArgumentNotNull(t, "t");

      if (t.IsValueType())
        return IsNullableType(t);

      return true;
    }

    public static bool IsNullableType(Type t)
    {
      ValidationUtils.ArgumentNotNull(t, "t");

      return (t.IsGenericType() && t.GetGenericTypeDefinition() == typeof(Nullable<>));
    }

    public static Type EnsureNotNullableType(Type t)
    {
      return (IsNullableType(t))
        ? Nullable.GetUnderlyingType(t)
        : t;
    }

    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
    {
      Type implementingType;
      return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
    }

    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, out Type implementingType)
    {
      ValidationUtils.ArgumentNotNull(type, "type");
      ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");

      if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
        throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));

      if (type.IsInterface())
      {
        if (type.IsGenericType())
        {
          Type interfaceDefinition = type.GetGenericTypeDefinition();

          if (genericInterfaceDefinition == interfaceDefinition)
          {
            implementingType = type;
            return true;
          }
        }
      }

      foreach (Type i in type.GetInterfaces())
      {
        if (i.IsGenericType())
        {
          Type interfaceDefinition = i.GetGenericTypeDefinition();

          if (genericInterfaceDefinition == interfaceDefinition)
          {
            implementingType = i;
            return true;
          }
        }
      }

      implementingType = null;
      return false;
    }

    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
    {
      Type implementingType;
      return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
    }

    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type implementingType)
    {
      ValidationUtils.ArgumentNotNull(type, "type");
      ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");

      if (!genericClassDefinition.IsClass() || !genericClassDefinition.IsGenericTypeDefinition())
        throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));

      return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
    }

    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type implementingType)
    {
      if (currentType.IsGenericType())
      {
        Type currentGenericClassDefinition = currentType.GetGenericTypeDefinition();

        if (genericClassDefinition == currentGenericClassDefinition)
        {
          implementingType = currentType;
          return true;
        }
      }

      if (currentType.BaseType() == null)
      {
        implementingType = null;
        return false;
      }

      return InheritsGenericDefinitionInternal(currentType.BaseType(), genericClassDefinition, out implementingType);
    }

    /// <summary>
    /// Gets the type of the typed collection's items.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <returns>The type of the typed collection's items.</returns>
    public static Type GetCollectionItemType(Type type)
    {
      ValidationUtils.ArgumentNotNull(type, "type");
      Type genericListType;

      if (type.IsArray)
      {
        return type.GetElementType();
      }
      else if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out genericListType))
      {
        if (genericListType.IsGenericTypeDefinition())
          throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));

        return genericListType.GetGenericArguments()[0];
      }
      else if (typeof(IEnumerable).IsAssignableFrom(type))
      {
        return null;
      }
      else
      {
        throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
      }
    }

    public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type keyType, out Type valueType)
    {
      ValidationUtils.ArgumentNotNull(dictionaryType, "type");

      Type genericDictionaryType;
      if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<,>), out genericDictionaryType))
      {
        if (genericDictionaryType.IsGenericTypeDefinition())
          throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));

        Type[] dictionaryGenericArguments = genericDictionaryType.GetGenericArguments();

        keyType = dictionaryGenericArguments[0];
        valueType = dictionaryGenericArguments[1];
        return;
      }
      else if (typeof(IDictionary).IsAssignableFrom(dictionaryType))
      {
        keyType = null;
        valueType = null;
        return;
      }
      else
      {
        throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
      }
    }

    public static Type GetDictionaryValueType(Type dictionaryType)
    {
      Type keyType;
      Type valueType;
      GetDictionaryKeyValueTypes(dictionaryType, out keyType, out valueType);

      return valueType;
    }

    public static Type GetDictionaryKeyType(Type dictionaryType)
    {
      Type keyType;
      Type valueType;
      GetDictionaryKeyValueTypes(dictionaryType, out keyType, out valueType);

      return keyType;
    }

    /// <summary>
    /// Gets the member's underlying type.
    /// </summary>
    /// <param name="member">The member.</param>
    /// <returns>The underlying type of the member.</returns>
    public static Type GetMemberUnderlyingType(MemberInfo member)
    {
      ValidationUtils.ArgumentNotNull(member, "member");

      switch (member.MemberType())
      {
        case MemberTypes.Field:
          return ((FieldInfo)member).FieldType;
        case MemberTypes.Property:
          return ((PropertyInfo)member).PropertyType;
        case MemberTypes.Event:
          return ((EventInfo)member).EventHandlerType;
        default:
          throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo or EventInfo", "member");
      }
    }

    /// <summary>
    /// Determines whether the member is an indexed property.
    /// </summary>
    /// <param name="member">The member.</param>
    /// <returns>
    /// 	<c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsIndexedProperty(MemberInfo member)
    {
      ValidationUtils.ArgumentNotNull(member, "member");

      PropertyInfo propertyInfo = member as PropertyInfo;

      if (propertyInfo != null)
        return IsIndexedProperty(propertyInfo);
      else
        return false;
    }

    /// <summary>
    /// Determines whether the property is an indexed property.
    /// </summary>
    /// <param name="property">The property.</param>
    /// <returns>
    /// 	<c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsIndexedProperty(PropertyInfo property)
    {
      ValidationUtils.ArgumentNotNull(property, "property");

      return (property.GetIndexParameters().Length > 0);
    }

    /// <summary>
    /// Gets the member's value on the object.
    /// </summary>
    /// <param name="member">The member.</param>
    /// <param name="target">The target object.</param>
    /// <returns>The member's value on the object.</returns>
    public static object GetMemberValue(MemberInfo member, object target)
    {
      ValidationUtils.ArgumentNotNull(member, "member");
      ValidationUtils.ArgumentNotNull(target, "target");

      switch (member.MemberType())
      {
        case MemberTypes.Field:
          return ((FieldInfo)member).GetValue(target);
        case MemberTypes.Property:
          try
          {
            return ((PropertyInfo)member).GetValue(target, null);
          }
          catch (TargetParameterCountException e)
          {
            throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), e);
          }
        default:
          throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, CultureInfo.InvariantCulture, member.Name), "member");
      }
    }

    /// <summary>
    /// Sets the member's value on the target object.
    /// </summary>
    /// <param name="member">The member.</param>
    /// <param name="target">The target.</param>
    /// <param name="value">The value.</param>
    public static void SetMemberValue(MemberInfo member, object target, object value)
    {
      ValidationUtils.ArgumentNotNull(member, "member");
      ValidationUtils.ArgumentNotNull(target, "target");

      switch (member.MemberType())
      {
        case MemberTypes.Field:
          ((FieldInfo)member).SetValue(target, value);
          break;
        case MemberTypes.Property:
          ((PropertyInfo)member).SetValue(target, value, null);
          break;
        default:
          throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
      }
    }

    /// <summary>
    /// Determines whether the specified MemberInfo can be read.
    /// </summary>
    /// <param name="member">The MemberInfo to determine whether can be read.</param>
    /// /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param>
    /// <returns>
    /// 	<c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
    /// </returns>
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
    {
      switch (member.MemberType())
      {
        case MemberTypes.Field:
          FieldInfo fieldInfo = (FieldInfo)member;

          if (nonPublic)
            return true;
          else if (fieldInfo.IsPublic)
            return true;
          return false;
        case MemberTypes.Property:
          PropertyInfo propertyInfo = (PropertyInfo) member;

          if (!propertyInfo.CanRead)
            return false;
          if (nonPublic)
            return true;
          return (propertyInfo.GetGetMethod(nonPublic) != null);
        default:
          return false;
      }
    }

    /// <summary>
    /// Determines whether the specified MemberInfo can be set.
    /// </summary>
    /// <param name="member">The MemberInfo to determine whether can be set.</param>
    /// <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
    /// <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
    /// <returns>
    /// 	<c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
    /// </returns>
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
    {
      switch (member.MemberType())
      {
        case MemberTypes.Field:
          FieldInfo fieldInfo = (FieldInfo)member;

          if (fieldInfo.IsInitOnly && !canSetReadOnly)
            return false;
          if (nonPublic)
            return true;
          else if (fieldInfo.IsPublic)
            return true;
          return false;
        case MemberTypes.Property:
          PropertyInfo propertyInfo = (PropertyInfo)member;

          if (!propertyInfo.CanWrite)
            return false;
          if (nonPublic)
            return true;
          return (propertyInfo.GetSetMethod(nonPublic) != null);
        default:
          return false;
      }
    }

    public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
    {
      List<MemberInfo> targetMembers = new List<MemberInfo>();

      targetMembers.AddRange(GetFields(type, bindingAttr));
      targetMembers.AddRange(GetProperties(type, bindingAttr));

      // for some reason .NET returns multiple members when overriding a generic member on a base class
      // http://forums.msdn.microsoft.com/en-US/netfxbcl/thread/b5abbfee-e292-4a64-8907-4e3f0fb90cd9/
      // filter members to only return the override on the topmost class
      // update: I think this is fixed in .NET 3.5 SP1 - leave this in for now...
      List<MemberInfo> distinctMembers = new List<MemberInfo>(targetMembers.Count);

      foreach (var groupedMember in targetMembers.GroupBy(m => m.Name))
      {
        int count = groupedMember.Count();
        IList<MemberInfo> members = groupedMember.ToList();

        if (count == 1)
        {
          distinctMembers.Add(members.First());
        }
        else
        {
          var resolvedMembers = members.Where(m => !IsOverridenGenericMember(m, bindingAttr) || m.Name == "Item");

          distinctMembers.AddRange(resolvedMembers);
        }
      }

      return distinctMembers;
    }

    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
    {
      MemberTypes memberType = memberInfo.MemberType();
      if (memberType != MemberTypes.Field && memberType != MemberTypes.Property)
        throw new ArgumentException("Member must be a field or property.");

      Type declaringType = memberInfo.DeclaringType;
      if (!declaringType.IsGenericType())
        return false;
      Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
      if (genericTypeDefinition == null)
        return false;
      MemberInfo[] members = genericTypeDefinition.GetMember(memberInfo.Name, bindingAttr);
      if (members.Length == 0)
        return false;
      Type memberUnderlyingType = GetMemberUnderlyingType(members[0]);
      if (!memberUnderlyingType.IsGenericParameter)
        return false;

      return true;
    }

    public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider) where T : Attribute
    {
      return GetAttribute<T>(attributeProvider, true);
    }

    public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
    {
      T[] attributes = GetAttributes<T>(attributeProvider, inherit);

      return (attributes != null) ? attributes.SingleOrDefault() : null;
    }

#if !(NETFX_CORE)
    public static T[] GetAttributes<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
    {
      ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");

      object provider;

#if !PORTABLE
      provider = attributeProvider;
#else
      provider = attributeProvider.UnderlyingObject;
#endif

      // http://hyperthink.net/blog/getcustomattributes-gotcha/
      // ICustomAttributeProvider doesn't do inheritance

      if (provider is Type)
        return (T[])((Type)provider).GetCustomAttributes(typeof(T), inherit);

      if (provider is Assembly)
        return (T[])Attribute.GetCustomAttributes((Assembly)provider, typeof(T));

      if (provider is MemberInfo)
        return (T[])Attribute.GetCustomAttributes((MemberInfo)provider, typeof(T), inherit);

#if !PORTABLE
      if (provider is Module)
        return (T[])Attribute.GetCustomAttributes((Module)provider, typeof(T), inherit);
#endif

      if (provider is ParameterInfo)
        return (T[])Attribute.GetCustomAttributes((ParameterInfo)provider, typeof(T), inherit);

#if !PORTABLE
      return (T[])attributeProvider.GetCustomAttributes(typeof(T), inherit);
#else
      throw new Exception("Cannot get attributes from '{0}'.".FormatWith(CultureInfo.InvariantCulture, provider));
#endif
    }
#else
    public static T[] GetAttributes<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
    {
      object provider = attributeProvider.UnderlyingObject;

      if (provider is Type)
        return ((Type)provider).GetTypeInfo().GetCustomAttributes<T>(inherit).ToArray();

      if (provider is Assembly)
        return ((Assembly)provider).GetCustomAttributes<T>().ToArray();

      if (provider is MemberInfo)
        return ((MemberInfo)provider).GetCustomAttributes<T>(inherit).ToArray();

      if (provider is Module)
        return ((Module)provider).GetCustomAttributes<T>().ToArray();

      if (provider is ParameterInfo)
        return ((ParameterInfo)provider).GetCustomAttributes<T>(inherit).ToArray();

      throw new Exception("Cannot get attributes from '{0}'.".FormatWith(CultureInfo.InvariantCulture, provider));
    }
#endif

    public static Type MakeGenericType(Type genericTypeDefinition, params Type[] innerTypes)
    {
      ValidationUtils.ArgumentNotNull(genericTypeDefinition, "genericTypeDefinition");
      ValidationUtils.ArgumentNotNullOrEmpty<Type>(innerTypes, "innerTypes");
      ValidationUtils.ArgumentConditionTrue(genericTypeDefinition.IsGenericTypeDefinition(), "genericTypeDefinition", "Type {0} is not a generic type definition.".FormatWith(CultureInfo.InvariantCulture, genericTypeDefinition));

      return genericTypeDefinition.MakeGenericType(innerTypes);
    }

    public static object CreateGeneric(Type genericTypeDefinition, Type innerType, params object[] args)
    {
      return CreateGeneric(genericTypeDefinition, new [] { innerType }, args);
    }

    public static object CreateGeneric(Type genericTypeDefinition, IList<Type> innerTypes, params object[] args)
    {
      return CreateGeneric(genericTypeDefinition, innerTypes, (t, a) => CreateInstance(t, a.ToArray()), args);
    }

    public static object CreateGeneric(Type genericTypeDefinition, IList<Type> innerTypes, Func<Type, IList<object>, object> instanceCreator, params object[] args)
    {
      ValidationUtils.ArgumentNotNull(genericTypeDefinition, "genericTypeDefinition");
      ValidationUtils.ArgumentNotNullOrEmpty(innerTypes, "innerTypes");
      ValidationUtils.ArgumentNotNull(instanceCreator, "createInstance");

      Type specificType = MakeGenericType(genericTypeDefinition, innerTypes.ToArray());

      return instanceCreator(specificType, args);
    }

     public static object CreateInstance(Type type, params object[] args)
     {
       ValidationUtils.ArgumentNotNull(type, "type");

#if !PocketPC
       return Activator.CreateInstance(type, args);
#else
       // CF doesn't have a Activator.CreateInstance overload that takes args
       // lame

       if (type.IsValueType && CollectionUtils.IsNullOrEmpty<object>(args))
         return Activator.CreateInstance(type);

       ConstructorInfo[] constructors = type.GetConstructors();
       ConstructorInfo match = constructors.Where(c =>
         {
           ParameterInfo[] parameters = c.GetParameters();
           if (parameters.Length != args.Length)
             return false;

           for (int i = 0; i < parameters.Length; i++)
           {
             ParameterInfo parameter = parameters[i];
             object value = args[i];

             if (!IsCompatibleValue(value, parameter.ParameterType))
               return false;
           }

           return true;
         }).FirstOrDefault();

       if (match == null)
         throw new Exception("Could not create '{0}' with given parameters.".FormatWith(CultureInfo.InvariantCulture, type));

       return match.Invoke(args);
#endif
     }

    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, out string typeName, out string assemblyName)
    {
      int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);

      if (assemblyDelimiterIndex != null)
      {
        typeName = fullyQualifiedTypeName.Substring(0, assemblyDelimiterIndex.Value).Trim();
        assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.Value + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.Value - 1).Trim();
      }
      else
      {
        typeName = fullyQualifiedTypeName;
        assemblyName = null;
      }

    }

    private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
    {
      // we need to get the first comma following all surrounded in brackets because of generic types
      // e.g. System.Collections.Generic.Dictionary`2[[System.String, mscorlib,Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
      int scope = 0;
      for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
      {
        char current = fullyQualifiedTypeName[i];
        switch (current)
        {
          case '[':
            scope++;
            break;
          case ']':
            scope--;
            break;
          case ',':
            if (scope == 0)
              return i;
            break;
        }
      }

      return null;
    }

    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
    {
      const BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

      switch (memberInfo.MemberType())
      {
        case MemberTypes.Property:
          PropertyInfo propertyInfo = (PropertyInfo) memberInfo;

          Type[] types = propertyInfo.GetIndexParameters().Select(p => p.ParameterType).ToArray();

          return targetType.GetProperty(propertyInfo.Name, bindingAttr, null, propertyInfo.PropertyType, types, null);
        default:
          return targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), bindingAttr).SingleOrDefault();
      }
    }

    public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
    {
      ValidationUtils.ArgumentNotNull(targetType, "targetType");

      List<MemberInfo> fieldInfos = new List<MemberInfo>(targetType.GetFields(bindingAttr));
#if !NETFX_CORE
      // Type.GetFields doesn't return inherited private fields
      // manually find private fields from base class
      GetChildPrivateFields(fieldInfos, targetType, bindingAttr);
#endif

      return fieldInfos.Cast<FieldInfo>();
    }

    private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
    {
      // fix weirdness with private FieldInfos only being returned for the current Type
      // find base type fields and add them to result
      if ((bindingAttr & BindingFlags.NonPublic) != 0)
      {
        // modify flags to not search for public fields
        BindingFlags nonPublicBindingAttr = bindingAttr.RemoveFlag(BindingFlags.Public);

        while ((targetType = targetType.BaseType()) != null)
        {
          // filter out protected fields
          IEnumerable<MemberInfo> childPrivateFields =
            targetType.GetFields(nonPublicBindingAttr).Where(f => f.IsPrivate).Cast<MemberInfo>();

          initialFields.AddRange(childPrivateFields);
        }
      }
    }

    public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
    {
      ValidationUtils.ArgumentNotNull(targetType, "targetType");

      List<PropertyInfo> propertyInfos = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
      GetChildPrivateProperties(propertyInfos, targetType, bindingAttr);

      // a base class private getter/setter will be inaccessable unless the property was gotten from the base class
      for (int i = 0; i < propertyInfos.Count; i++)
      {
        PropertyInfo member = propertyInfos[i];
        if (member.DeclaringType != targetType)
        {
          PropertyInfo declaredMember = (PropertyInfo)GetMemberInfoFromType(member.DeclaringType, member);
          propertyInfos[i] = declaredMember;
        }
      }

      return propertyInfos;
    }

    public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
    {
      return ((bindingAttr & flag) == flag)
        ? bindingAttr ^ flag
        : bindingAttr;
    }

    private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
    {
      // fix weirdness with private PropertyInfos only being returned for the current Type
      // find base type properties and add them to result
      if ((bindingAttr & BindingFlags.NonPublic) != 0)
      {
        // modify flags to not search for public fields
        BindingFlags nonPublicBindingAttr = bindingAttr.RemoveFlag(BindingFlags.Public);

        while ((targetType = targetType.BaseType()) != null)
        {
          foreach (PropertyInfo propertyInfo in targetType.GetProperties(nonPublicBindingAttr))
          {
            PropertyInfo nonPublicProperty = propertyInfo;

            // have to test on name rather than reference because instances are different
            // depending on the type that GetProperties was called on
            int index = initialProperties.IndexOf(p => p.Name == nonPublicProperty.Name);
            if (index == -1)
            {
              initialProperties.Add(nonPublicProperty);
            }
            else
            {
              // replace nonpublic properties for a child, but gotten from
              // the parent with the one from the child
              // the property gotten from the child will have access to private getter/setter
              initialProperties[index] = nonPublicProperty;
            }
          }
        }
      }
    }

    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
    {
      bool isMethodOverriden = currentType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
        .Any(info =>
             info.Name == method &&
             // check that the method overrides the original on DynamicObjectProxy
             info.DeclaringType != methodDeclaringType
             // todo - find out whether there is a way to do this in winrt
#if !NETFX_CORE
             && info.GetBaseDefinition().DeclaringType == methodDeclaringType
#endif
        );

      return isMethodOverriden;
    }

    public static object GetDefaultValue(Type type)
    {
      if (!type.IsValueType())
        return null;

      switch (ConvertUtils.GetTypeCode(type))
      {
        case TypeCode.Boolean:
          return false;
        case TypeCode.Char:
        case TypeCode.SByte:
        case TypeCode.Byte:
        case TypeCode.Int16:
        case TypeCode.UInt16:
        case TypeCode.Int32:
        case TypeCode.UInt32:
          return 0;
        case TypeCode.Int64:
        case TypeCode.UInt64:
          return 0L;
        case TypeCode.Single:
          return 0f;
        case TypeCode.Double:
          return 0.0;
        case TypeCode.Decimal:
          return 0m;
        case TypeCode.DateTime:
          return new DateTime();
      }

      if (type == typeof(Guid))
        return new Guid();

#if !NET20
      if (type == typeof(DateTimeOffset))
        return new DateTimeOffset();
#endif

      if (IsNullable(type))
        return null;

      // possibly use IL initobj for perf here?
      return Activator.CreateInstance(type);
    }
  }
}
#endregion Utilities_ReflectionUtils.cs

/// ********   File: \Utilities\StringBuffer.cs
#region Utilities_StringBuffer.cs

namespace Newtonsoft.Json.Utilities
{
  /// <summary>
  /// Builds a string. Unlike StringBuilder this class lets you reuse it's internal buffer.
  /// </summary>
  internal class StringBuffer
  {
    private char[] _buffer;
    private int _position;

    private static readonly char[] EmptyBuffer = new char[0];

    public int Position
    {
      get { return _position; }
      set { _position = value; }
    }

    public StringBuffer()
    {
      _buffer = EmptyBuffer;
    }

    public StringBuffer(int initalSize)
    {
      _buffer = new char[initalSize];
    }

    public void Append(char value)
    {
      // test if the buffer array is large enough to take the value
      if (_position == _buffer.Length)
        EnsureSize(1);

      // set value and increment poisition
      _buffer[_position++] = value;
    }

    public void Append(char[] buffer, int startIndex, int count)
    {
      if (_position + count >= _buffer.Length)
        EnsureSize(count);

      Array.Copy(buffer, startIndex, _buffer, _position, count);

      _position += count;
    }

    public void Clear()
    {
      _buffer = EmptyBuffer;
      _position = 0;
    }

    private void EnsureSize(int appendLength)
    {
      char[] newBuffer = new char[(_position + appendLength) * 2];

      Array.Copy(_buffer, newBuffer, _position);

      _buffer = newBuffer;
    }

    public override string ToString()
    {
      return ToString(0, _position);
    }

    public string ToString(int start, int length)
    {
      // TODO: validation
      return new string(_buffer, start, length);
    }

    public char[] GetInternalBuffer()
    {
      return _buffer;
    }
  }
}
#endregion Utilities_StringBuffer.cs

/// ********   File: \Utilities\StringReference.cs
#region Utilities_StringReference.cs

namespace Newtonsoft.Json.Utilities
{
  internal struct StringReference
  {
    private readonly char[] _chars;
    private readonly int _startIndex;
    private readonly int _length;

    public char[] Chars
    {
      get { return _chars; }
    }

    public int StartIndex
    {
      get { return _startIndex; }
    }

    public int Length
    {
      get { return _length; }
    }

    public StringReference(char[] chars, int startIndex, int length)
    {
      _chars = chars;
      _startIndex = startIndex;
      _length = length;
    }

    public override string ToString()
    {
      return new string(_chars, _startIndex, _length);
    }
  }
}
#endregion Utilities_StringReference.cs

/// ********   File: \Utilities\StringUtils.cs
#region Utilities_StringUtils.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal static class StringUtils
  {
    public const string CarriageReturnLineFeed = "\r\n";
    public const string Empty = "";
    public const char CarriageReturn = '\r';
    public const char LineFeed = '\n';
    public const char Tab = '\t';

    public static string FormatWith(this string format, IFormatProvider provider, object arg0)
    {
      return format.FormatWith(provider, new[] { arg0 });
    }

    public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1)
    {
      return format.FormatWith(provider, new[] { arg0, arg1 });
    }

    public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2)
    {
      return format.FormatWith(provider, new[] { arg0, arg1, arg2 });
    }

    public static string FormatWith(this string format, IFormatProvider provider, params object[] args)
    {
      ValidationUtils.ArgumentNotNull(format, "format");

      return string.Format(provider, format, args);
    }

    /// <summary>
    /// Determines whether the string is all white space. Empty string will return false.
    /// </summary>
    /// <param name="s">The string to test whether it is all white space.</param>
    /// <returns>
    /// 	<c>true</c> if the string is all white space; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsWhiteSpace(string s)
    {
      if (s == null)
        throw new ArgumentNullException("s");

      if (s.Length == 0)
        return false;

      for (int i = 0; i < s.Length; i++)
      {
        if (!char.IsWhiteSpace(s[i]))
          return false;
      }

      return true;
    }

    /// <summary>
    /// Nulls an empty string.
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns>Null if the string was null, otherwise the string unchanged.</returns>
    public static string NullEmptyString(string s)
    {
      return (string.IsNullOrEmpty(s)) ? null : s;
    }

    public static StringWriter CreateStringWriter(int capacity)
    {
      StringBuilder sb = new StringBuilder(capacity);
      StringWriter sw = new StringWriter(sb, CultureInfo.InvariantCulture);

      return sw;
    }

    public static int? GetLength(string value)
    {
      if (value == null)
        return null;
      else
        return value.Length;
    }

    public static void ToCharAsUnicode(char c, char[] buffer)
    {
      buffer[0] = '\\';
      buffer[1] = 'u';
      buffer[2] = MathUtils.IntToHex((c >> 12) & '\x000f');
      buffer[3] = MathUtils.IntToHex((c >> 8) & '\x000f');
      buffer[4] = MathUtils.IntToHex((c >> 4) & '\x000f');
      buffer[5] = MathUtils.IntToHex(c & '\x000f');
    }

    public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
    {
      if (source == null)
        throw new ArgumentNullException("source");
      if (valueSelector == null)
        throw new ArgumentNullException("valueSelector");

      var caseInsensitiveResults = source.Where(s => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase));
      if (caseInsensitiveResults.Count() <= 1)
      {
        return caseInsensitiveResults.SingleOrDefault();
      }
      else
      {
        // multiple results returned. now filter using case sensitivity
        var caseSensitiveResults = source.Where(s => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal));
        return caseSensitiveResults.SingleOrDefault();
      }
    }

    public static string ToCamelCase(string s)
    {
      if (string.IsNullOrEmpty(s))
        return s;

      if (!char.IsUpper(s[0]))
        return s;

      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < s.Length; i++)
      {
        bool hasNext = (i + 1 < s.Length);
        if ((i == 0 || !hasNext) || char.IsUpper(s[i + 1]))
        {
          char lowerCase;
#if !NETFX_CORE
          lowerCase = char.ToLower(s[i], CultureInfo.InvariantCulture);
#else
          lowerCase = char.ToLower(s[i]);
#endif

          sb.Append(lowerCase);
        }
        else
        {
          sb.Append(s.Substring(i));
          break;
        }
      }

      return sb.ToString();
    }

    public static bool IsHighSurrogate(char c)
    {
#if !(SILVERLIGHT || PORTABLE)
      return char.IsHighSurrogate(c);
#else
      return (c >= 55296 && c <= 56319);
#endif
    }

    public static bool IsLowSurrogate(char c)
    {
#if !(SILVERLIGHT || PORTABLE)
      return char.IsLowSurrogate(c);
#else
      return (c >= 56320 && c <= 57343);
#endif
    }
  }
}
#endregion Utilities_StringUtils.cs

/// ********   File: \Utilities\ThreadSafeStore.cs
#region Utilities_ThreadSafeStore.cs

#if NET20
#endif

namespace Newtonsoft.Json.Utilities
{
  internal class ThreadSafeStore<TKey, TValue>
  {
    private readonly object _lock = new object();
    private Dictionary<TKey, TValue> _store;
    private readonly Func<TKey, TValue> _creator;

    public ThreadSafeStore(Func<TKey, TValue> creator)
    {
      if (creator == null)
        throw new ArgumentNullException("creator");

      _creator = creator;
      _store = new Dictionary<TKey, TValue>();
    }

    public TValue Get(TKey key)
    {
      TValue value;
      if (!_store.TryGetValue(key, out value))
        return AddValue(key);

      return value;
    }

    private TValue AddValue(TKey key)
    {
      TValue value = _creator(key);

      lock (_lock)
      {
        if (_store == null)
        {
          _store = new Dictionary<TKey, TValue>();
          _store[key] = value;
        }
        else
        {
          // double check locking
          TValue checkValue;
          if (_store.TryGetValue(key, out checkValue))
            return checkValue;

          Dictionary<TKey, TValue> newStore = new Dictionary<TKey, TValue>(_store);
          newStore[key] = value;

#if !NETFX_CORE
          Thread.MemoryBarrier();
#endif
          _store = newStore;
        }

        return value;
      }
    }
  }
}
#endregion Utilities_ThreadSafeStore.cs

/// ********   File: \Utilities\TypeExtensions.cs
#region Utilities_TypeExtensions.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json.Utilities
{
  internal static class TypeExtensions
  {
#if NETFX_CORE
    private static BindingFlags DefaultFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance;

    public static MethodInfo GetGetMethod(this PropertyInfo propertyInfo)
    {
      return propertyInfo.GetGetMethod(false);
    }

    public static MethodInfo GetGetMethod(this PropertyInfo propertyInfo, bool nonPublic)
    {
      MethodInfo getMethod = propertyInfo.GetMethod;
      if (getMethod != null && (getMethod.IsPublic || nonPublic))
        return getMethod;

      return null;
    }

    public static MethodInfo GetSetMethod(this PropertyInfo propertyInfo)
    {
      return propertyInfo.GetSetMethod(false);
    }

    public static MethodInfo GetSetMethod(this PropertyInfo propertyInfo, bool nonPublic)
    {
      MethodInfo setMethod = propertyInfo.SetMethod;
      if (setMethod != null && (setMethod.IsPublic || nonPublic))
        return setMethod;

      return null;
    }

    public static bool IsSubclassOf(this Type type, Type c)
    {
      return type.GetTypeInfo().IsSubclassOf(c);
    }

    public static bool IsAssignableFrom(this Type type, Type c)
    {
      return type.GetTypeInfo().IsAssignableFrom(c.GetTypeInfo());
    }
#endif

    public static MemberTypes MemberType(this MemberInfo memberInfo)
    {
#if !(NETFX_CORE || PORTABLE)
      return memberInfo.MemberType;
#else
      if (memberInfo is PropertyInfo)
        return MemberTypes.Property;
      else if (memberInfo is FieldInfo)
        return MemberTypes.Field;
      else if (memberInfo is EventInfo)
        return MemberTypes.Event;
      else if (memberInfo is MethodInfo)
        return MemberTypes.Method;
      else
        return MemberTypes.Other;
#endif
    }

    public static bool ContainsGenericParameters(this Type type)
    {
#if !NETFX_CORE
      return type.ContainsGenericParameters;
#else
      return type.GetTypeInfo().ContainsGenericParameters;
#endif
    }

    public static bool IsInterface(this Type type)
    {
#if !NETFX_CORE
      return type.IsInterface;
#else
      return type.GetTypeInfo().IsInterface;
#endif
    }

    public static bool IsGenericType(this Type type)
    {
#if !NETFX_CORE
      return type.IsGenericType;
#else
      return type.GetTypeInfo().IsGenericType;
#endif
    }

    public static bool IsGenericTypeDefinition(this Type type)
    {
#if !NETFX_CORE
      return type.IsGenericTypeDefinition;
#else
      return type.GetTypeInfo().IsGenericTypeDefinition;
#endif
    }

    public static Type BaseType(this Type type)
    {
#if !NETFX_CORE
      return type.BaseType;
#else
      return type.GetTypeInfo().BaseType;
#endif
    }

    public static bool IsEnum(this Type type)
    {
#if !NETFX_CORE
      return type.IsEnum;
#else
      return type.GetTypeInfo().IsEnum;
#endif
    }

    public static bool IsClass(this Type type)
    {
#if !NETFX_CORE
      return type.IsClass;
#else
      return type.GetTypeInfo().IsClass;
#endif
    }

    public static bool IsSealed(this Type type)
    {
#if !NETFX_CORE
      return type.IsSealed;
#else
      return type.GetTypeInfo().IsSealed;
#endif
    }

#if PORTABLE
    public static PropertyInfo GetProperty(this Type type, string name, BindingFlags bindingFlags, object placeholder1, Type propertyType, IList<Type> indexParameters, object placeholder2)
    {
      IList<PropertyInfo> propertyInfos = type.GetProperties(bindingFlags);

      return propertyInfos.Where(p =>
      {
        if (name != null && name != p.Name)
          return false;
        if (propertyType != null && propertyType != p.PropertyType)
          return false;
        if (indexParameters != null)
        {
          if (!p.GetIndexParameters().Select(ip => ip.ParameterType).SequenceEqual(indexParameters))
            return false;
        }

        return true;
      }).SingleOrDefault();
    }

    public static IEnumerable<MemberInfo> GetMember(this Type type, string name, MemberTypes memberType, BindingFlags bindingFlags)
    {
      return type.GetMembers(bindingFlags).Where(m =>
        {
          if (name != null && name != m.Name)
            return false;
          if (m.MemberType() != memberType)
            return false;

          return true;
        });
    }
#endif

#if NETFX_CORE
    public static bool IsDefined(this Type type, Type attributeType, bool inherit)
    {
      return type.GetTypeInfo().CustomAttributes.Any(a => a.AttributeType == attributeType);
    }

    public static MethodInfo GetMethod(this Type type, string name)
    {
      return type.GetMethod(name, DefaultFlags);
    }

    public static MethodInfo GetMethod(this Type type, string name, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetDeclaredMethod(name);
    }

    public static MethodInfo GetMethod(this Type type, IList<Type> parameterTypes)
    {
      return type.GetMethod(null, parameterTypes);
    }

    public static MethodInfo GetMethod(this Type type, string name, IList<Type> parameterTypes)
    {
      return type.GetMethod(name, DefaultFlags, null, parameterTypes, null);
    }

    public static MethodInfo GetMethod(this Type type, string name, BindingFlags bindingFlags, object placeHolder1, IList<Type> parameterTypes, object placeHolder2)
    {
      return type.GetTypeInfo().DeclaredMethods.Where(m =>
      {
        if (name != null && m.Name != name)
          return false;

        if (!TestAccessibility(m, bindingFlags))
          return false;

        return m.GetParameters().Select(p => p.ParameterType).SequenceEqual(parameterTypes);
      }).SingleOrDefault();
    }

    public static PropertyInfo GetProperty(this Type type, string name, BindingFlags bindingFlags, object placeholder1, Type propertyType, IList<Type> indexParameters, object placeholder2)
    {
      return type.GetTypeInfo().DeclaredProperties.Where(p =>
      {
        if (name != null && name != p.Name)
          return false;
        if (propertyType != null && propertyType != p.PropertyType)
          return false;
        if (indexParameters != null)
        {
          if (!p.GetIndexParameters().Select(ip => ip.ParameterType).SequenceEqual(indexParameters))
            return false;
        }

        return true;
      }).SingleOrDefault();
    }

    public static IEnumerable<MemberInfo> GetMember(this Type type, string name, MemberTypes memberType, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetMembersRecursive().Where(m =>
      {
        if (name != null && name != m.Name)
          return false;
        if (m.MemberType() != memberType)
          return false;
        if (!TestAccessibility(m, bindingFlags))
          return false;

        return true;
      });
    }

    public static IEnumerable<ConstructorInfo> GetConstructors(this Type type)
    {
      return type.GetConstructors(DefaultFlags);
    }

    public static IEnumerable<ConstructorInfo> GetConstructors(this Type type, BindingFlags bindingFlags)
    {
      return type.GetConstructors(bindingFlags, null);
    }

    private static IEnumerable<ConstructorInfo> GetConstructors(this Type type, BindingFlags bindingFlags, IList<Type> parameterTypes)
    {
      return type.GetTypeInfo().DeclaredConstructors.Where(c =>
      {
        if (!TestAccessibility(c, bindingFlags))
          return false;

        if (parameterTypes != null && !c.GetParameters().Select(p => p.ParameterType).SequenceEqual(parameterTypes))
          return false;

        return true;
      });
    }

    public static ConstructorInfo GetConstructor(this Type type, IList<Type> parameterTypes)
    {
      return type.GetConstructor(DefaultFlags, null, parameterTypes, null);
    }

    public static ConstructorInfo GetConstructor(this Type type, BindingFlags bindingFlags, object placeholder1, IList<Type> parameterTypes, object placeholder2)
    {
      return type.GetConstructors(bindingFlags, parameterTypes).SingleOrDefault();
    }

    public static MemberInfo[] GetMember(this Type type, string member)
    {
      return type.GetMember(member, DefaultFlags);
    }

    public static MemberInfo[] GetMember(this Type type, string member, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetMembersRecursive().Where(m => m.Name == member && TestAccessibility(m, bindingFlags)).ToArray();
    }

    public static MemberInfo GetField(this Type type, string member)
    {
      return type.GetField(member, DefaultFlags);
    }

    public static MemberInfo GetField(this Type type, string member, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetDeclaredField(member);
    }

    public static IEnumerable<PropertyInfo> GetProperties(this Type type, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetPropertiesRecursive().Where(p => TestAccessibility(p, bindingFlags));
    }

    private static IList<MemberInfo> GetMembersRecursive(this TypeInfo type)
    {
      TypeInfo t = type;
      IList<MemberInfo> members = new List<MemberInfo>();
      while (t != null)
      {
        foreach (var member in t.DeclaredMembers)
        {
          if (!members.Any(p => p.Name == member.Name))
            members.Add(member);
        }
        t = (t.BaseType != null) ? t.BaseType.GetTypeInfo() : null;
      }

      return members;
    }

    private static IList<PropertyInfo> GetPropertiesRecursive(this TypeInfo type)
    {
      TypeInfo t = type;
      IList<PropertyInfo> properties = new List<PropertyInfo>();
      while (t != null)
      {
        foreach (var member in t.DeclaredProperties)
        {
          if (!properties.Any(p => p.Name == member.Name))
            properties.Add(member);
        }
        t = (t.BaseType != null) ? t.BaseType.GetTypeInfo() : null;
      }

      return properties;
    }

    private static IList<FieldInfo> GetFieldsRecursive(this TypeInfo type)
    {
      TypeInfo t = type;
      IList<FieldInfo> fields = new List<FieldInfo>();
      while (t != null)
      {
        foreach (var member in t.DeclaredFields)
        {
          if (!fields.Any(p => p.Name == member.Name))
            fields.Add(member);
        }
        t = (t.BaseType != null) ? t.BaseType.GetTypeInfo() : null;
      }

      return fields;
    }

    public static IEnumerable<MethodInfo> GetMethods(this Type type, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().DeclaredMethods;
    }

    public static PropertyInfo GetProperty(this Type type, string name)
    {
      return type.GetProperty(name, DefaultFlags);
    }

    public static PropertyInfo GetProperty(this Type type, string name, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetDeclaredProperty(name);
    }

    public static IEnumerable<FieldInfo> GetFields(this Type type)
    {
      return type.GetFields(DefaultFlags);
    }

    public static IEnumerable<FieldInfo> GetFields(this Type type, BindingFlags bindingFlags)
    {
      return type.GetTypeInfo().GetFieldsRecursive().Where(f => TestAccessibility(f, bindingFlags)).ToList();
    }

    private static bool TestAccessibility(PropertyInfo member, BindingFlags bindingFlags)
    {
      if (member.GetMethod != null && TestAccessibility(member.GetMethod, bindingFlags))
        return true;

      if (member.SetMethod != null && TestAccessibility(member.SetMethod, bindingFlags))
        return true;

      return false;
    }

    private static bool TestAccessibility(MemberInfo member, BindingFlags bindingFlags)
    {
      if (member is FieldInfo)
      {
        return TestAccessibility((FieldInfo)member, bindingFlags);
      }
      else if (member is MethodBase)
      {
        return TestAccessibility((MethodBase)member, bindingFlags);
      }
      else if (member is PropertyInfo)
      {
        return TestAccessibility((PropertyInfo)member, bindingFlags);
      }

      throw new Exception("Unexpected member type.");
    }

    private static bool TestAccessibility(FieldInfo member, BindingFlags bindingFlags)
    {
      bool visibility = (member.IsPublic && bindingFlags.HasFlag(BindingFlags.Public)) ||
        (!member.IsPublic && bindingFlags.HasFlag(BindingFlags.NonPublic));

      bool instance = (member.IsStatic && bindingFlags.HasFlag(BindingFlags.Static)) ||
        (!member.IsStatic && bindingFlags.HasFlag(BindingFlags.Instance));

      return visibility && instance;
    }

    private static bool TestAccessibility(MethodBase member, BindingFlags bindingFlags)
    {
      bool visibility = (member.IsPublic && bindingFlags.HasFlag(BindingFlags.Public)) ||
        (!member.IsPublic && bindingFlags.HasFlag(BindingFlags.NonPublic));

      bool instance = (member.IsStatic && bindingFlags.HasFlag(BindingFlags.Static)) ||
        (!member.IsStatic && bindingFlags.HasFlag(BindingFlags.Instance));

      return visibility && instance;
    }

    public static Type[] GetGenericArguments(this Type type)
    {
      return type.GetTypeInfo().GenericTypeArguments;
    }

    public static IEnumerable<Type> GetInterfaces(this Type type)
    {
      return type.GetTypeInfo().ImplementedInterfaces;
    }

    public static IEnumerable<MethodInfo> GetMethods(this Type type)
    {
      return type.GetTypeInfo().DeclaredMethods;
    }
#endif

    public static bool IsAbstract(this Type type)
    {
#if !NETFX_CORE
      return type.IsAbstract;
#else
      return type.GetTypeInfo().IsAbstract;
#endif
    }

    public static bool IsVisible(this Type type)
    {
#if !NETFX_CORE
      return type.IsVisible;
#else
      return type.GetTypeInfo().IsVisible;
#endif
    }

    public static bool IsValueType(this Type type)
    {
#if !NETFX_CORE
      return type.IsValueType;
#else
      return type.GetTypeInfo().IsValueType;
#endif
    }

    public static bool AssignableToTypeName(this Type type, string fullTypeName, out Type match)
    {
      Type current = type;

      while (current != null)
      {
        if (string.Equals(current.FullName, fullTypeName, StringComparison.Ordinal))
        {
          match = current;
          return true;
        }

        current = current.BaseType();
      }

      foreach (Type i in type.GetInterfaces())
      {
        if (string.Equals(i.Name, fullTypeName, StringComparison.Ordinal))
        {
          match = type;
          return true;
        }
      }

      match = null;
      return false;
    }

    public static bool AssignableToTypeName(this Type type, string fullTypeName)
    {
      Type match;
      return type.AssignableToTypeName(fullTypeName, out match);
    }

    public static MethodInfo GetGenericMethod(this Type type, string name, params Type[] parameterTypes)
    {
      var methods = type.GetMethods().Where(method => method.Name == name);

      foreach (var method in methods)
      {
        if (method.HasParameters(parameterTypes))
          return method;
      }

      return null;
    }

    public static bool HasParameters(this MethodInfo method, params Type[] parameterTypes)
    {
      var methodParameters = method.GetParameters().Select(parameter => parameter.ParameterType).ToArray();

      if (methodParameters.Length != parameterTypes.Length)
        return false;

      for (int i = 0; i < methodParameters.Length; i++)
        if (methodParameters[i].ToString() != parameterTypes[i].ToString())
          return false;

      return true;
    }

    public static IEnumerable<Type> GetAllInterfaces(this Type target)
    {
      foreach (var i in target.GetInterfaces())
      {
        yield return i;
        foreach (var ci in i.GetInterfaces())
        {
          yield return ci;
        }
      }
    }

    public static IEnumerable<MethodInfo> GetAllMethods(this Type target)
    {
      var allTypes = target.GetAllInterfaces().ToList();
      allTypes.Add(target);

      return from type in allTypes
             from method in type.GetMethods()
             select method;
    }
  }
}
#endregion Utilities_TypeExtensions.cs

/// ********   File: \Utilities\ValidationUtils.cs
#region Utilities_ValidationUtils.cs

namespace Newtonsoft.Json.Utilities
{
  internal static class ValidationUtils
  {
    public static void ArgumentNotNullOrEmpty(string value, string parameterName)
    {
      if (value == null)
        throw new ArgumentNullException(parameterName);

      if (value.Length == 0)
        throw new ArgumentException("'{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName), parameterName);
    }

    public static void ArgumentTypeIsEnum(Type enumType, string parameterName)
    {
      ArgumentNotNull(enumType, "enumType");

      if (!enumType.IsEnum())
        throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture, enumType), parameterName);
    }

    public static void ArgumentNotNullOrEmpty<T>(ICollection<T> collection, string parameterName)
    {
      ArgumentNotNullOrEmpty<T>(collection, parameterName, "Collection '{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName));
    }

    public static void ArgumentNotNullOrEmpty<T>(ICollection<T> collection, string parameterName, string message)
    {
      if (collection == null)
        throw new ArgumentNullException(parameterName);

      if (collection.Count == 0)
        throw new ArgumentException(message, parameterName);
    }

    public static void ArgumentNotNull(object value, string parameterName)
    {
      if (value == null)
        throw new ArgumentNullException(parameterName);
    }

    public static void ArgumentConditionTrue(bool condition, string parameterName, string message)
    {
      if (!condition)
        throw new ArgumentException(message, parameterName);
    }
  }
}
#endregion Utilities_ValidationUtils.cs

/// ********   File: \ConstructorHandling.cs
#region ConstructorHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how constructors are used when initializing objects during deserialization by the <see cref="JsonSerializer"/>.
  /// </summary>
  public enum ConstructorHandling
  {
    /// <summary>
    /// First attempt to use the public default constructor, then fall back to single paramatized constructor, then the non-public default constructor.
    /// </summary>
    Default = 0,
    /// <summary>
    /// Json.NET will use a non-public default constructor before falling back to a paramatized constructor.
    /// </summary>
    AllowNonPublicDefaultConstructor = 1
  }
}
#endregion ConstructorHandling.cs

/// ********   File: \DateFormatHandling.cs
#region DateFormatHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how dates are formatted when writing JSON text.
  /// </summary>
  public enum DateFormatHandling
  {
    /// <summary>
    /// Dates are written in the ISO 8601 format, e.g. "2012-03-21T05:40Z".
    /// </summary>
    IsoDateFormat,
    /// <summary>
    /// Dates are written in the Microsoft JSON format, e.g. "\/Date(1198908717056)\/".
    /// </summary>
    MicrosoftDateFormat
  }
}
#endregion DateFormatHandling.cs

/// ********   File: \DateParseHandling.cs
#region DateParseHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON text.
  /// </summary>
  public enum DateParseHandling
  {
    /// <summary>
    /// Date formatted strings are not parsed to a date type and are read as strings.
    /// </summary>
    None,
    /// <summary>
    /// Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="DateTime"/>.
    /// </summary>
    DateTime,
#if !NET20
    /// <summary>
    /// Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="DateTimeOffset"/>.
    /// </summary>
    DateTimeOffset
#endif
  }
}
#endregion DateParseHandling.cs

/// ********   File: \DateTimeZoneHandling.cs
#region DateTimeZoneHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how to treat the time value when converting between string and <see cref="DateTime"/>.
  /// </summary>
  public enum DateTimeZoneHandling
  {
    /// <summary>
    /// Treat as local time. If the <see cref="DateTime"/> object represents a Coordinated Universal Time (UTC), it is converted to the local time.
    /// </summary>
    Local,
    /// <summary>
    /// Treat as a UTC. If the <see cref="DateTime"/> object represents a local time, it is converted to a UTC.
    /// </summary>
    Utc,
    /// <summary>
    /// Treat as a local time if a <see cref="DateTime"/> is being converted to a string.
    /// If a string is being converted to <see cref="DateTime"/>, convert to a local time if a time zone is specified.
    /// </summary>
    Unspecified,
    /// <summary>
    /// Time zone information should be preserved when converting.
    /// </summary>
    RoundtripKind
  }
}
#endregion DateTimeZoneHandling.cs

/// ********   File: \DefaultValueHandling.cs
#region DefaultValueHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies default value handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingObject" title="DefaultValueHandling Class" />
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingExample" title="DefaultValueHandling Ignore Example" />
  /// </example>
  [Flags]
  public enum DefaultValueHandling
  {
    /// <summary>
    /// Include members where the member value is the same as the member's default value when serializing objects.
    /// Included members are written to JSON. Has no effect when deserializing.
    /// </summary>
    Include = 0,
    /// <summary>
    /// Ignore members where the member value is the same as the member's default value when serializing objects
    /// so that is is not written to JSON.
    /// This option will ignore all default values (e.g. <c>null</c> for objects and nullable typesl; <c>0</c> for integers,
    /// decimals and floating point numbers; and <c>false</c> for booleans). The default value ignored can be changed by
    /// placing the <see cref="DefaultValueAttribute"/> on the property.
    /// </summary>
    Ignore = 1,
    /// <summary>
    /// Members with a default value but no JSON will be set to their default value when deserializing.
    /// </summary>
    Populate = 2,
    /// <summary>
    /// Ignore members where the member value is the same as the member's default value when serializing objects
    /// and sets members to their default value when deserializing.
    /// </summary>
    IgnoreAndPopulate = Ignore | Populate
  }
}
#endregion DefaultValueHandling.cs

/// ********   File: \FormatterAssemblyStyle.cs
#region FormatterAssemblyStyle.cs
#if SILVERLIGHT || PocketPC || NETFX_CORE || PORTABLE
namespace System.Runtime.Serialization.Formatters
{
  /// <summary>
  /// Indicates the method that will be used during deserialization for locating and loading assemblies.
  /// </summary>
  public enum FormatterAssemblyStyle
  {
    /// <summary>
    /// In simple mode, the assembly used during deserialization need not match exactly the assembly used during serialization. Specifically, the version numbers need not match as the LoadWithPartialName method is used to load the assembly.
    /// </summary>
    Simple,
    /// <summary>
    /// In full mode, the assembly used during deserialization must match exactly the assembly used during serialization. The Load method of the Assembly class is used to load the assembly.
    /// </summary>
    Full
  }
}
#endif
#endregion FormatterAssemblyStyle.cs

/// ********   File: \Formatting.cs
#region Formatting.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies formatting options for the <see cref="JsonTextWriter"/>.
  /// </summary>
  public enum Formatting
  {
    /// <summary>
    /// No special formatting is applied. This is the default.
    /// </summary>
    None,
    /// <summary>
    /// Causes child objects to be indented according to the <see cref="JsonTextWriter.Indentation"/> and <see cref="JsonTextWriter.IndentChar"/> settings.
    /// </summary>
    Indented
  }
}
#endregion Formatting.cs

/// ********   File: \IJsonLineInfo.cs
#region IJsonLineInfo.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Provides an interface to enable a class to return line and position information.
  /// </summary>
  public interface IJsonLineInfo
  {
    /// <summary>
    /// Gets a value indicating whether the class can return line information.
    /// </summary>
    /// <returns>
    /// 	<c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
    /// </returns>
    bool HasLineInfo();

    /// <summary>
    /// Gets the current line number.
    /// </summary>
    /// <value>The current line number or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    int LineNumber { get; }
    /// <summary>
    /// Gets the current line position.
    /// </summary>
    /// <value>The current line position or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    int LinePosition { get; }
  }
}
#endregion IJsonLineInfo.cs

/// ********   File: \JsonArrayAttribute.cs
#region JsonArrayAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> how to serialize the collection.
  /// </summary>
  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
  public sealed class JsonArrayAttribute : JsonContainerAttribute
  {
    private bool _allowNullItems;

    /// <summary>
    /// Gets or sets a value indicating whether null items are allowed in the collection.
    /// </summary>
    /// <value><c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
    public bool AllowNullItems
    {
      get { return _allowNullItems; }
      set { _allowNullItems = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonArrayAttribute"/> class.
    /// </summary>
    public JsonArrayAttribute()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonObjectAttribute"/> class with a flag indicating whether the array can contain null items
    /// </summary>
    /// <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
    public JsonArrayAttribute(bool allowNullItems)
    {
      _allowNullItems = allowNullItems;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonArrayAttribute"/> class with the specified container Id.
    /// </summary>
    /// <param name="id">The container Id.</param>
    public JsonArrayAttribute(string id)
      : base(id)
    {
    }
  }
}
#endregion JsonArrayAttribute.cs

/// ********   File: \JsonConstructorAttribute.cs
#region JsonConstructorAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> to use the specified constructor when deserializing that object.
  /// </summary>
  [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
  public sealed class JsonConstructorAttribute : Attribute
  {
  }
}
#endregion JsonConstructorAttribute.cs

/// ********   File: \JsonContainerAttribute.cs
#region JsonContainerAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> how to serialize the object.
  /// </summary>
  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
  public abstract class JsonContainerAttribute : Attribute
  {
    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    /// <value>The id.</value>
    public string Id { get; set; }
    /// <summary>
    /// Gets or sets the title.
    /// </summary>
    /// <value>The title.</value>
    public string Title { get; set; }
    /// <summary>
    /// Gets or sets the description.
    /// </summary>
    /// <value>The description.</value>
    public string Description { get; set; }

    /// <summary>
    /// Gets the collection's items converter.
    /// </summary>
    /// <value>The collection's items converter.</value>
    public Type ItemConverterType { get; set; }

    // yuck. can't set nullable properties on an attribute in C#
    // have to use this approach to get an unset default state
    internal bool? _isReference;
    internal bool? _itemIsReference;
    internal ReferenceLoopHandling? _itemReferenceLoopHandling;
    internal TypeNameHandling? _itemTypeNameHandling;

    /// <summary>
    /// Gets or sets a value that indicates whether to preserve object references.
    /// </summary>
    /// <value>
    /// 	<c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
    /// </value>
    public bool IsReference
    {
      get { return _isReference ?? default(bool); }
      set { _isReference = value; }
    }

    /// <summary>
    /// Gets or sets a value that indicates whether to preserve collection's items references.
    /// </summary>
    /// <value>
    /// 	<c>true</c> to keep collection's items object references; otherwise, <c>false</c>. The default is <c>false</c>.
    /// </value>
    public bool ItemIsReference
    {
      get { return _itemIsReference ?? default(bool); }
      set { _itemIsReference = value; }
    }

    /// <summary>
    /// Gets or sets the reference loop handling used when serializing the collection's items.
    /// </summary>
    /// <value>The reference loop handling.</value>
    public ReferenceLoopHandling ItemReferenceLoopHandling
    {
      get { return _itemReferenceLoopHandling ?? default(ReferenceLoopHandling); }
      set { _itemReferenceLoopHandling = value; }
    }

    /// <summary>
    /// Gets or sets the type name handling used when serializing the collection's items.
    /// </summary>
    /// <value>The type name handling.</value>
    public TypeNameHandling ItemTypeNameHandling
    {
      get { return _itemTypeNameHandling ?? default(TypeNameHandling); }
      set { _itemTypeNameHandling = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonContainerAttribute"/> class.
    /// </summary>
    protected JsonContainerAttribute()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonContainerAttribute"/> class with the specified container Id.
    /// </summary>
    /// <param name="id">The container Id.</param>
    protected JsonContainerAttribute(string id)
    {
      Id = id;
    }
  }
}
#endregion JsonContainerAttribute.cs

/// ********   File: \JsonConvert.cs
#region JsonConvert.cs

#if !(NET20 || NET35 || SILVERLIGHT || PORTABLE)
#endif
#if !NET20 && (!SILVERLIGHT || WINDOWS_PHONE) && !PORTABLE
#endif
#if NETFX_CORE
#endif

namespace Newtonsoft.Json
{
  /// <summary>
  /// Provides methods for converting between common language runtime types and JSON types.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="SerializeObject" title="Serializing and Deserializing JSON with JsonConvert" />
  /// </example>
  public static class JsonConvert
  {
    /// <summary>
    /// Represents JavaScript's boolean value true as a string. This field is read-only.
    /// </summary>
    public static readonly string True = "true";

    /// <summary>
    /// Represents JavaScript's boolean value false as a string. This field is read-only.
    /// </summary>
    public static readonly string False = "false";

    /// <summary>
    /// Represents JavaScript's null as a string. This field is read-only.
    /// </summary>
    public static readonly string Null = "null";

    /// <summary>
    /// Represents JavaScript's undefined as a string. This field is read-only.
    /// </summary>
    public static readonly string Undefined = "undefined";

    /// <summary>
    /// Represents JavaScript's positive infinity as a string. This field is read-only.
    /// </summary>
    public static readonly string PositiveInfinity = "Infinity";

    /// <summary>
    /// Represents JavaScript's negative infinity as a string. This field is read-only.
    /// </summary>
    public static readonly string NegativeInfinity = "-Infinity";

    /// <summary>
    /// Represents JavaScript's NaN as a string. This field is read-only.
    /// </summary>
    public static readonly string NaN = "NaN";

    internal static readonly long InitialJavaScriptDateTicks = 621355968000000000;

    /// <summary>
    /// Converts the <see cref="DateTime"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="DateTime"/>.</returns>
    public static string ToString(DateTime value)
    {
      return ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
    }

    /// <summary>
    /// Converts the <see cref="DateTime"/> to its JSON string representation using the <see cref="DateFormatHandling"/> specified.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <param name="format">The format the date will be converted to.</param>
    /// <param name="timeZoneHandling">The time zone handling when the date is converted to a string.</param>
    /// <returns>A JSON string representation of the <see cref="DateTime"/>.</returns>
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
    {
      DateTime updatedDateTime = EnsureDateTime(value, timeZoneHandling);

      using (StringWriter writer = StringUtils.CreateStringWriter(64))
      {
        WriteDateTimeString(writer, updatedDateTime, updatedDateTime.GetUtcOffset(), updatedDateTime.Kind, format, '"');
        return writer.ToString();
      }
    }

    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
    {
      switch (timeZone)
      {
        case DateTimeZoneHandling.Local:
          value = SwitchToLocalTime(value);
          break;
        case DateTimeZoneHandling.Utc:
          value = SwitchToUtcTime(value);
          break;
        case DateTimeZoneHandling.Unspecified:
          value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
          break;
        case DateTimeZoneHandling.RoundtripKind:
          break;
        default:
          throw new ArgumentException("Invalid date time handling value.");
      }

      return value;
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Converts the <see cref="DateTimeOffset"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="DateTimeOffset"/>.</returns>
    public static string ToString(DateTimeOffset value)
    {
      return ToString(value, DateFormatHandling.IsoDateFormat);
    }

    /// <summary>
    /// Converts the <see cref="DateTimeOffset"/> to its JSON string representation using the <see cref="DateFormatHandling"/> specified.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <param name="format">The format the date will be converted to.</param>
    /// <returns>A JSON string representation of the <see cref="DateTimeOffset"/>.</returns>
    public static string ToString(DateTimeOffset value, DateFormatHandling format)
    {
      return ToString(value, format, '"');
    }

    internal static string ToString(DateTimeOffset value, DateFormatHandling format, char quoteChar)
    {
      using (StringWriter writer = StringUtils.CreateStringWriter(64))
      {
        WriteDateTimeString(writer, (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, format, quoteChar);
        return writer.ToString();
      }
    }
#endif

    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, char quoteChar)
    {
      WriteDateTimeString(writer, value, value.GetUtcOffset(), value.Kind, format, quoteChar);
    }

    internal static void WriteDateTimeString(TextWriter writer, DateTime value, TimeSpan offset, DateTimeKind kind, DateFormatHandling format, char quoteChar)
    {
      if (format == DateFormatHandling.MicrosoftDateFormat)
      {
        long javaScriptTicks = ConvertDateTimeToJavaScriptTicks(value, offset);

        writer.Write(quoteChar);
        writer.Write(@"\/Date(");
        writer.Write(javaScriptTicks);

        switch (kind)
        {
          case DateTimeKind.Unspecified:
            if (value != DateTime.MaxValue && value != DateTime.MinValue)
              WriteDateTimeOffset(writer, offset, format);
            break;
          case DateTimeKind.Local:
            WriteDateTimeOffset(writer, offset, format);
            break;
        }

        writer.Write(@")\/");
        writer.Write(quoteChar);
      }
      else
      {
        writer.Write(quoteChar);
        writer.Write(value.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFF", CultureInfo.InvariantCulture));

        switch (kind)
        {
          case DateTimeKind.Local:
            WriteDateTimeOffset(writer, offset, format);
            break;
          case DateTimeKind.Utc:
            writer.Write("Z");
            break;
        }

        writer.Write(quoteChar);
      }
    }

    internal static void WriteDateTimeOffset(TextWriter writer, TimeSpan offset, DateFormatHandling format)
    {
      writer.Write((offset.Ticks >= 0L) ? "+" : "-");

      int absHours = Math.Abs(offset.Hours);
      if (absHours < 10)
        writer.Write(0);
      writer.Write(absHours);

      if (format == DateFormatHandling.IsoDateFormat)
        writer.Write(':');

      int absMinutes = Math.Abs(offset.Minutes);
      if (absMinutes < 10)
        writer.Write(0);
      writer.Write(absMinutes);
    }

    private static long ToUniversalTicks(DateTime dateTime)
    {
      if (dateTime.Kind == DateTimeKind.Utc)
        return dateTime.Ticks;

      return ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
    }

    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
    {
      // special case min and max value
      // they never have a timezone appended to avoid issues
      if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
        return dateTime.Ticks;

      long ticks = dateTime.Ticks - offset.Ticks;
      if (ticks > 3155378975999999999L)
        return 3155378975999999999L;

      if (ticks < 0L)
        return 0L;

      return ticks;
    }

    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
    {
      long universialTicks = ToUniversalTicks(dateTime, offset);

      return UniversialTicksToJavaScriptTicks(universialTicks);
    }

    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
    {
      return ConvertDateTimeToJavaScriptTicks(dateTime, true);
    }

    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
    {
      long ticks = (convertToUtc) ? ToUniversalTicks(dateTime) : dateTime.Ticks;

      return UniversialTicksToJavaScriptTicks(ticks);
    }

    private static long UniversialTicksToJavaScriptTicks(long universialTicks)
    {
      long javaScriptTicks = (universialTicks - InitialJavaScriptDateTicks)/10000;

      return javaScriptTicks;
    }

    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
    {
      DateTime dateTime = new DateTime((javaScriptTicks*10000) + InitialJavaScriptDateTicks, DateTimeKind.Utc);

      return dateTime;
    }

    private static DateTime SwitchToLocalTime(DateTime value)
    {
      switch (value.Kind)
      {
        case DateTimeKind.Unspecified:
          return new DateTime(value.Ticks, DateTimeKind.Local);

        case DateTimeKind.Utc:
          return value.ToLocalTime();

        case DateTimeKind.Local:
          return value;
      }
      return value;
    }

    private static DateTime SwitchToUtcTime(DateTime value)
    {
      switch (value.Kind)
      {
        case DateTimeKind.Unspecified:
          return new DateTime(value.Ticks, DateTimeKind.Utc);

        case DateTimeKind.Utc:
          return value;

        case DateTimeKind.Local:
          return value.ToUniversalTime();
      }
      return value;
    }

    /// <summary>
    /// Converts the <see cref="Boolean"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Boolean"/>.</returns>
    public static string ToString(bool value)
    {
      return (value) ? True : False;
    }

    /// <summary>
    /// Converts the <see cref="Char"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Char"/>.</returns>
    public static string ToString(char value)
    {
      return ToString(char.ToString(value));
    }

    /// <summary>
    /// Converts the <see cref="Enum"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Enum"/>.</returns>
    public static string ToString(Enum value)
    {
      return value.ToString("D");
    }

    /// <summary>
    /// Converts the <see cref="Int32"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Int32"/>.</returns>
    public static string ToString(int value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="Int16"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Int16"/>.</returns>
    public static string ToString(short value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="UInt16"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="UInt16"/>.</returns>
    [CLSCompliant(false)]
    public static string ToString(ushort value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="UInt32"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="UInt32"/>.</returns>
    [CLSCompliant(false)]
    public static string ToString(uint value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="Int64"/>  to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Int64"/>.</returns>
    public static string ToString(long value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="UInt64"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="UInt64"/>.</returns>
    [CLSCompliant(false)]
    public static string ToString(ulong value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="Single"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Single"/>.</returns>
    public static string ToString(float value)
    {
      return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Converts the <see cref="Double"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Double"/>.</returns>
    public static string ToString(double value)
    {
      return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
    }

    private static string EnsureDecimalPlace(double value, string text)
    {
      if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1)
        return text;

      return text + ".0";
    }

    private static string EnsureDecimalPlace(string text)
    {
      if (text.IndexOf('.') != -1)
        return text;

      return text + ".0";
    }

    /// <summary>
    /// Converts the <see cref="Byte"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Byte"/>.</returns>
    public static string ToString(byte value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="SByte"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="SByte"/>.</returns>
    [CLSCompliant(false)]
    public static string ToString(sbyte value)
    {
      return value.ToString(null, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Converts the <see cref="Decimal"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="SByte"/>.</returns>
    public static string ToString(decimal value)
    {
      return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
    }

    /// <summary>
    /// Converts the <see cref="Guid"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Guid"/>.</returns>
    public static string ToString(Guid value)
    {
      return ToString(value, '"');
    }

    internal static string ToString(Guid value, char quoteChar)
    {
      string text = null;

#if !(NETFX_CORE || PORTABLE)
      text = value.ToString("D", CultureInfo.InvariantCulture);
#else
      text = value.ToString("D");
#endif

      return quoteChar + text + quoteChar;
    }

    /// <summary>
    /// Converts the <see cref="TimeSpan"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="TimeSpan"/>.</returns>
    public static string ToString(TimeSpan value)
    {
      return ToString(value, '"');
    }

    internal static string ToString(TimeSpan value, char quoteChar)
    {
      return ToString(value.ToString(), quoteChar);
    }

    /// <summary>
    /// Converts the <see cref="Uri"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Uri"/>.</returns>
    public static string ToString(Uri value)
    {
      if (value == null)
        return Null;

      return ToString(value, '"');
    }

    internal static string ToString(Uri value, char quoteChar)
    {
      return ToString(value.ToString(), quoteChar);
    }

    /// <summary>
    /// Converts the <see cref="String"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="String"/>.</returns>
    public static string ToString(string value)
    {
      return ToString(value, '"');
    }

    /// <summary>
    /// Converts the <see cref="String"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <param name="delimiter">The string delimiter character.</param>
    /// <returns>A JSON string representation of the <see cref="String"/>.</returns>
    public static string ToString(string value, char delimiter)
    {
      if (delimiter != '"' && delimiter != '\'')
        throw new ArgumentException("Delimiter must be a single or double quote.", "delimiter");

      return JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, true);
    }

    /// <summary>
    /// Converts the <see cref="Object"/> to its JSON string representation.
    /// </summary>
    /// <param name="value">The value to convert.</param>
    /// <returns>A JSON string representation of the <see cref="Object"/>.</returns>
    public static string ToString(object value)
    {
      if (value == null)
        return Null;

      IConvertible convertible = ConvertUtils.ToConvertible(value);

      if (convertible != null)
      {
        switch (convertible.GetTypeCode())
        {
          case TypeCode.String:
            return ToString(convertible.ToString(CultureInfo.InvariantCulture));
          case TypeCode.Char:
            return ToString(convertible.ToChar(CultureInfo.InvariantCulture));
          case TypeCode.Boolean:
            return ToString(convertible.ToBoolean(CultureInfo.InvariantCulture));
          case TypeCode.SByte:
            return ToString(convertible.ToSByte(CultureInfo.InvariantCulture));
          case TypeCode.Int16:
            return ToString(convertible.ToInt16(CultureInfo.InvariantCulture));
          case TypeCode.UInt16:
            return ToString(convertible.ToUInt16(CultureInfo.InvariantCulture));
          case TypeCode.Int32:
            return ToString(convertible.ToInt32(CultureInfo.InvariantCulture));
          case TypeCode.Byte:
            return ToString(convertible.ToByte(CultureInfo.InvariantCulture));
          case TypeCode.UInt32:
            return ToString(convertible.ToUInt32(CultureInfo.InvariantCulture));
          case TypeCode.Int64:
            return ToString(convertible.ToInt64(CultureInfo.InvariantCulture));
          case TypeCode.UInt64:
            return ToString(convertible.ToUInt64(CultureInfo.InvariantCulture));
          case TypeCode.Single:
            return ToString(convertible.ToSingle(CultureInfo.InvariantCulture));
          case TypeCode.Double:
            return ToString(convertible.ToDouble(CultureInfo.InvariantCulture));
          case TypeCode.DateTime:
            return ToString(convertible.ToDateTime(CultureInfo.InvariantCulture));
          case TypeCode.Decimal:
            return ToString(convertible.ToDecimal(CultureInfo.InvariantCulture));
#if !(NETFX_CORE || PORTABLE)
          case TypeCode.DBNull:
            return Null;
#endif
        }
      }
#if !PocketPC && !NET20
      else if (value is DateTimeOffset)
      {
        return ToString((DateTimeOffset) value);
      }
#endif
      else if (value is Guid)
      {
        return ToString((Guid) value);
      }
      else if (value is Uri)
      {
        return ToString((Uri) value);
      }
      else if (value is TimeSpan)
      {
        return ToString((TimeSpan) value);
      }

      throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
    }

    private static bool IsJsonPrimitiveTypeCode(TypeCode typeCode)
    {
      switch (typeCode)
      {
        case TypeCode.String:
        case TypeCode.Char:
        case TypeCode.Boolean:
        case TypeCode.SByte:
        case TypeCode.Int16:
        case TypeCode.UInt16:
        case TypeCode.Int32:
        case TypeCode.Byte:
        case TypeCode.UInt32:
        case TypeCode.Int64:
        case TypeCode.UInt64:
        case TypeCode.Single:
        case TypeCode.Double:
        case TypeCode.DateTime:
        case TypeCode.Decimal:
#if !(NETFX_CORE || PORTABLE)
        case TypeCode.DBNull:
#endif
          return true;
        default:
          return false;
      }
    }

    internal static bool IsJsonPrimitiveType(Type type)
    {
      if (ReflectionUtils.IsNullableType(type))
        type = Nullable.GetUnderlyingType(type);

#if !PocketPC && !NET20
      if (type == typeof (DateTimeOffset))
        return true;
#endif
      if (type == typeof (byte[]))
        return true;
      if (type == typeof (Uri))
        return true;
      if (type == typeof (TimeSpan))
        return true;
      if (type == typeof (Guid))
        return true;

      return IsJsonPrimitiveTypeCode(ConvertUtils.GetTypeCode(type));
    }

    #region Serialize
    /// <summary>
    /// Serializes the specified object to a JSON string.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <returns>A JSON string representation of the object.</returns>
    public static string SerializeObject(object value)
    {
      return SerializeObject(value, Formatting.None, (JsonSerializerSettings) null);
    }

    /// <summary>
    /// Serializes the specified object to a JSON string.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <returns>
    /// A JSON string representation of the object.
    /// </returns>
    public static string SerializeObject(object value, Formatting formatting)
    {
      return SerializeObject(value, formatting, (JsonSerializerSettings) null);
    }

    /// <summary>
    /// Serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="converters">A collection converters used while serializing.</param>
    /// <returns>A JSON string representation of the object.</returns>
    public static string SerializeObject(object value, params JsonConverter[] converters)
    {
      return SerializeObject(value, Formatting.None, converters);
    }

    /// <summary>
    /// Serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="converters">A collection converters used while serializing.</param>
    /// <returns>A JSON string representation of the object.</returns>
    public static string SerializeObject(object value, Formatting formatting, params JsonConverter[] converters)
    {
      JsonSerializerSettings settings = (converters != null && converters.Length > 0)
                                          ? new JsonSerializerSettings {Converters = converters}
                                          : null;

      return SerializeObject(value, formatting, settings);
    }

    /// <summary>
    /// Serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="settings">The <see cref="JsonSerializerSettings"/> used to serialize the object.
    /// If this is null, default serialization settings will be is used.</param>
    /// <returns>
    /// A JSON string representation of the object.
    /// </returns>
    public static string SerializeObject(object value, JsonSerializerSettings settings)
    {
      return SerializeObject(value, Formatting.None, settings);
    }

    /// <summary>
    /// Serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="settings">The <see cref="JsonSerializerSettings"/> used to serialize the object.
    /// If this is null, default serialization settings will be is used.</param>
    /// <returns>
    /// A JSON string representation of the object.
    /// </returns>
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
    {
      JsonSerializer jsonSerializer = JsonSerializer.Create(settings);

      StringBuilder sb = new StringBuilder(256);
      StringWriter sw = new StringWriter(sb, CultureInfo.InvariantCulture);
      using (JsonTextWriter jsonWriter = new JsonTextWriter(sw))
      {
        jsonWriter.Formatting = formatting;

        jsonSerializer.Serialize(jsonWriter, value);
      }

      return sw.ToString();
    }

#if !(NET20 || NET35 || SILVERLIGHT || PORTABLE)
    /// <summary>
    /// Asynchronously serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <returns>
    /// A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
    /// </returns>
    public static Task<string> SerializeObjectAsync(object value)
    {
      return SerializeObjectAsync(value, Formatting.None, null);
    }

    /// <summary>
    /// Asynchronously serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <returns>
    /// A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
    /// </returns>
    public static Task<string> SerializeObjectAsync(object value, Formatting formatting)
    {
      return SerializeObjectAsync(value, formatting, null);
    }

    /// <summary>
    /// Asynchronously serializes the specified object to a JSON string using a collection of <see cref="JsonConverter"/>.
    /// </summary>
    /// <param name="value">The object to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="settings">The <see cref="JsonSerializerSettings"/> used to serialize the object.
    /// If this is null, default serialization settings will be is used.</param>
    /// <returns>
    /// A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
    /// </returns>
    public static Task<string> SerializeObjectAsync(object value, Formatting formatting, JsonSerializerSettings settings)
    {
      return Task.Factory.StartNew(() => SerializeObject(value, formatting, settings));
    }
#endif
    #endregion

    #region Deserialize
    /// <summary>
    /// Deserializes the JSON to a .NET object.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <returns>The deserialized object from the Json string.</returns>
    public static object DeserializeObject(string value)
    {
      return DeserializeObject(value, null, (JsonSerializerSettings) null);
    }

    /// <summary>
    /// Deserializes the JSON to a .NET object.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>The deserialized object from the JSON string.</returns>
    public static object DeserializeObject(string value, JsonSerializerSettings settings)
    {
      return DeserializeObject(value, null, settings);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="type">The <see cref="Type"/> of object being deserialized.</param>
    /// <returns>The deserialized object from the Json string.</returns>
    public static object DeserializeObject(string value, Type type)
    {
      return DeserializeObject(value, type, (JsonSerializerSettings) null);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <typeparam name="T">The type of the object to deserialize to.</typeparam>
    /// <param name="value">The JSON to deserialize.</param>
    /// <returns>The deserialized object from the Json string.</returns>
    public static T DeserializeObject<T>(string value)
    {
      return DeserializeObject<T>(value, (JsonSerializerSettings) null);
    }

    /// <summary>
    /// Deserializes the JSON to the given anonymous type.
    /// </summary>
    /// <typeparam name="T">
    /// The anonymous type to deserialize to. This can't be specified
    /// traditionally and must be infered from the anonymous type passed
    /// as a parameter.
    /// </typeparam>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="anonymousTypeObject">The anonymous type object.</param>
    /// <returns>The deserialized anonymous type from the JSON string.</returns>
    public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
    {
      return DeserializeObject<T>(value);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <typeparam name="T">The type of the object to deserialize to.</typeparam>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="converters">Converters to use while deserializing.</param>
    /// <returns>The deserialized object from the JSON string.</returns>
    public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
    {
      return (T) DeserializeObject(value, typeof (T), converters);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <typeparam name="T">The type of the object to deserialize to.</typeparam>
    /// <param name="value">The object to deserialize.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>The deserialized object from the JSON string.</returns>
    public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
    {
      return (T) DeserializeObject(value, typeof (T), settings);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="type">The type of the object to deserialize.</param>
    /// <param name="converters">Converters to use while deserializing.</param>
    /// <returns>The deserialized object from the JSON string.</returns>
    public static object DeserializeObject(string value, Type type, params JsonConverter[] converters)
    {
      JsonSerializerSettings settings = (converters != null && converters.Length > 0)
                                          ? new JsonSerializerSettings {Converters = converters}
                                          : null;

      return DeserializeObject(value, type, settings);
    }

    /// <summary>
    /// Deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="type">The type of the object to deserialize to.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>The deserialized object from the JSON string.</returns>
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
    {
      ValidationUtils.ArgumentNotNull(value, "value");

      StringReader sr = new StringReader(value);
      JsonSerializer jsonSerializer = JsonSerializer.Create(settings);

      // by default DeserializeObject should check for additional content
      if (!jsonSerializer.IsCheckAdditionalContentSet())
        jsonSerializer.CheckAdditionalContent = true;

      return jsonSerializer.Deserialize(new JsonTextReader(sr), type);
    }

#if !(NET20 || NET35 || SILVERLIGHT || PORTABLE)
    /// <summary>
    /// Asynchronously deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <typeparam name="T">The type of the object to deserialize to.</typeparam>
    /// <param name="value">The JSON to deserialize.</param>
    /// <returns>
    /// A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
    /// </returns>
    public static Task<T> DeserializeObjectAsync<T>(string value)
    {
      return DeserializeObjectAsync<T>(value, null);
    }

    /// <summary>
    /// Asynchronously deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <typeparam name="T">The type of the object to deserialize to.</typeparam>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
    /// </returns>
    public static Task<T> DeserializeObjectAsync<T>(string value, JsonSerializerSettings settings)
    {
      return Task.Factory.StartNew(() => DeserializeObject<T>(value, settings));
    }

    /// <summary>
    /// Asynchronously deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <returns>
    /// A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
    /// </returns>
    public static Task<object> DeserializeObjectAsync(string value)
    {
      return DeserializeObjectAsync(value, null, null);
    }

    /// <summary>
    /// Asynchronously deserializes the JSON to the specified .NET type.
    /// </summary>
    /// <param name="value">The JSON to deserialize.</param>
    /// <param name="type">The type of the object to deserialize to.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
    /// </returns>
    public static Task<object> DeserializeObjectAsync(string value, Type type, JsonSerializerSettings settings)
    {
      return Task.Factory.StartNew(() => DeserializeObject(value, type, settings));
    }
#endif
    #endregion

    /// <summary>
    /// Populates the object with values from the JSON string.
    /// </summary>
    /// <param name="value">The JSON to populate values from.</param>
    /// <param name="target">The target object to populate values onto.</param>
    public static void PopulateObject(string value, object target)
    {
      PopulateObject(value, target, null);
    }

    /// <summary>
    /// Populates the object with values from the JSON string.
    /// </summary>
    /// <param name="value">The JSON to populate values from.</param>
    /// <param name="target">The target object to populate values onto.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
    {
      StringReader sr = new StringReader(value);
      JsonSerializer jsonSerializer = JsonSerializer.Create(settings);

      using (JsonReader jsonReader = new JsonTextReader(sr))
      {
        jsonSerializer.Populate(jsonReader, target);

        if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
          throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
      }
    }

#if !(NET20 || NET35 || SILVERLIGHT || PORTABLE)
    /// <summary>
    /// Asynchronously populates the object with values from the JSON string.
    /// </summary>
    /// <param name="value">The JSON to populate values from.</param>
    /// <param name="target">The target object to populate values onto.</param>
    /// <param name="settings">
    /// The <see cref="JsonSerializerSettings"/> used to deserialize the object.
    /// If this is null, default serialization settings will be is used.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous populate operation.
    /// </returns>
    public static Task PopulateObjectAsync(string value, object target, JsonSerializerSettings settings)
    {
      return Task.Factory.StartNew(() => PopulateObject(value, target, settings));
    }
#endif

#if !(SILVERLIGHT || PORTABLE || NETFX_CORE)
    /// <summary>
    /// Serializes the XML node to a JSON string.
    /// </summary>
    /// <param name="node">The node to serialize.</param>
    /// <returns>A JSON string of the XmlNode.</returns>
    public static string SerializeXmlNode(XmlNode node)
    {
      return SerializeXmlNode(node, Formatting.None);
    }

    /// <summary>
    /// Serializes the XML node to a JSON string.
    /// </summary>
    /// <param name="node">The node to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <returns>A JSON string of the XmlNode.</returns>
    public static string SerializeXmlNode(XmlNode node, Formatting formatting)
    {
      XmlNodeConverter converter = new XmlNodeConverter();

      return SerializeObject(node, formatting, converter);
    }

    /// <summary>
    /// Serializes the XML node to a JSON string.
    /// </summary>
    /// <param name="node">The node to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="omitRootObject">Omits writing the root object.</param>
    /// <returns>A JSON string of the XmlNode.</returns>
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
    {
      XmlNodeConverter converter = new XmlNodeConverter {OmitRootObject = omitRootObject};

      return SerializeObject(node, formatting, converter);
    }

    /// <summary>
    /// Deserializes the XmlNode from a JSON string.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <returns>The deserialized XmlNode</returns>
    public static XmlDocument DeserializeXmlNode(string value)
    {
      return DeserializeXmlNode(value, null);
    }

    /// <summary>
    /// Deserializes the XmlNode from a JSON string nested in a root elment.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
    /// <returns>The deserialized XmlNode</returns>
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
    {
      return DeserializeXmlNode(value, deserializeRootElementName, false);
    }

    /// <summary>
    /// Deserializes the XmlNode from a JSON string nested in a root elment.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
    /// <param name="writeArrayAttribute">
    /// A flag to indicate whether to write the Json.NET array attribute.
    /// This attribute helps preserve arrays when converting the written XML back to JSON.
    /// </param>
    /// <returns>The deserialized XmlNode</returns>
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
    {
      XmlNodeConverter converter = new XmlNodeConverter();
      converter.DeserializeRootElementName = deserializeRootElementName;
      converter.WriteArrayAttribute = writeArrayAttribute;

      return (XmlDocument) DeserializeObject(value, typeof (XmlDocument), converter);
    }
#endif

#if !NET20 && (!(SILVERLIGHT || PORTABLE) || WINDOWS_PHONE)
    /// <summary>
    /// Serializes the <see cref="XNode"/> to a JSON string.
    /// </summary>
    /// <param name="node">The node to convert to JSON.</param>
    /// <returns>A JSON string of the XNode.</returns>
    public static string SerializeXNode(XObject node)
    {
      return SerializeXNode(node, Formatting.None);
    }

    /// <summary>
    /// Serializes the <see cref="XNode"/> to a JSON string.
    /// </summary>
    /// <param name="node">The node to convert to JSON.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <returns>A JSON string of the XNode.</returns>
    public static string SerializeXNode(XObject node, Formatting formatting)
    {
      return SerializeXNode(node, formatting, false);
    }

    /// <summary>
    /// Serializes the <see cref="XNode"/> to a JSON string.
    /// </summary>
    /// <param name="node">The node to serialize.</param>
    /// <param name="formatting">Indicates how the output is formatted.</param>
    /// <param name="omitRootObject">Omits writing the root object.</param>
    /// <returns>A JSON string of the XNode.</returns>
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
    {
      XmlNodeConverter converter = new XmlNodeConverter {OmitRootObject = omitRootObject};

      return SerializeObject(node, formatting, converter);
    }

    /// <summary>
    /// Deserializes the <see cref="XNode"/> from a JSON string.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <returns>The deserialized XNode</returns>
    public static XDocument DeserializeXNode(string value)
    {
      return DeserializeXNode(value, null);
    }

    /// <summary>
    /// Deserializes the <see cref="XNode"/> from a JSON string nested in a root elment.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
    /// <returns>The deserialized XNode</returns>
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName)
    {
      return DeserializeXNode(value, deserializeRootElementName, false);
    }

    /// <summary>
    /// Deserializes the <see cref="XNode"/> from a JSON string nested in a root elment.
    /// </summary>
    /// <param name="value">The JSON string.</param>
    /// <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
    /// <param name="writeArrayAttribute">
    /// A flag to indicate whether to write the Json.NET array attribute.
    /// This attribute helps preserve arrays when converting the written XML back to JSON.
    /// </param>
    /// <returns>The deserialized XNode</returns>
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
    {
      XmlNodeConverter converter = new XmlNodeConverter();
      converter.DeserializeRootElementName = deserializeRootElementName;
      converter.WriteArrayAttribute = writeArrayAttribute;

      return (XDocument) DeserializeObject(value, typeof (XDocument), converter);
    }
#endif
  }
}
#endregion JsonConvert.cs

/// ********   File: \JsonConverter.cs
#region JsonConverter.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Converts an object to and from JSON.
  /// </summary>
  public abstract class JsonConverter
  {
    /// <summary>
    /// Writes the JSON representation of the object.
    /// </summary>
    /// <param name="writer">The <see cref="JsonWriter"/> to write to.</param>
    /// <param name="value">The value.</param>
    /// <param name="serializer">The calling serializer.</param>
    public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    /// <returns>The object value.</returns>
    public abstract object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);

    /// <summary>
    /// Determines whether this instance can convert the specified object type.
    /// </summary>
    /// <param name="objectType">Type of the object.</param>
    /// <returns>
    /// 	<c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
    /// </returns>
    public abstract bool CanConvert(Type objectType);

    /// <summary>
    /// Gets the <see cref="JsonSchema"/> of the JSON produced by the JsonConverter.
    /// </summary>
    /// <returns>The <see cref="JsonSchema"/> of the JSON produced by the JsonConverter.</returns>
    public virtual JsonSchema GetSchema()
    {
      return null;
    }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonConverter"/> can read JSON.
    /// </summary>
    /// <value><c>true</c> if this <see cref="JsonConverter"/> can read JSON; otherwise, <c>false</c>.</value>
    public virtual bool CanRead
    {
       get { return true; }
    }

    /// <summary>
    /// Gets a value indicating whether this <see cref="JsonConverter"/> can write JSON.
    /// </summary>
    /// <value><c>true</c> if this <see cref="JsonConverter"/> can write JSON; otherwise, <c>false</c>.</value>
    public virtual bool CanWrite
    {
      get { return true; }
    }
  }
}
#endregion JsonConverter.cs

/// ********   File: \JsonConverterAttribute.cs
#region JsonConverterAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> to use the specified <see cref="JsonConverter"/> when serializing the member or class.
  /// </summary>
  [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Enum | AttributeTargets.Parameter, AllowMultiple = false)]
  public sealed class JsonConverterAttribute : Attribute
  {
    private readonly Type _converterType;

    /// <summary>
    /// Gets the type of the converter.
    /// </summary>
    /// <value>The type of the converter.</value>
    public Type ConverterType
    {
      get { return _converterType; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonConverterAttribute"/> class.
    /// </summary>
    /// <param name="converterType">Type of the converter.</param>
    public JsonConverterAttribute(Type converterType)
    {
      if (converterType == null)
        throw new ArgumentNullException("converterType");

      _converterType = converterType;
    }

    internal static JsonConverter CreateJsonConverterInstance(Type converterType)
    {
      try
      {
        return (JsonConverter)Activator.CreateInstance(converterType);
      }
      catch (Exception ex)
      {
        throw new JsonException("Error creating {0}".FormatWith(CultureInfo.InvariantCulture, converterType), ex);
      }
    }
  }
}
#endregion JsonConverterAttribute.cs

/// ********   File: \JsonConverterCollection.cs
#region JsonConverterCollection.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Represents a collection of <see cref="JsonConverter"/>.
  /// </summary>
  public class JsonConverterCollection : Collection<JsonConverter>
  {
  }
}

#endregion JsonConverterCollection.cs

/// ********   File: \JsonDictionaryAttribute.cs
#region JsonDictionaryAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> how to serialize the collection.
  /// </summary>
  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
  public sealed class JsonDictionaryAttribute : JsonContainerAttribute
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonDictionaryAttribute"/> class.
    /// </summary>
    public JsonDictionaryAttribute()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonDictionaryAttribute"/> class with the specified container Id.
    /// </summary>
    /// <param name="id">The container Id.</param>
    public JsonDictionaryAttribute(string id)
      : base(id)
    {
    }
  }
}
#endregion JsonDictionaryAttribute.cs

/// ********   File: \JsonException.cs
#region JsonException.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// The exception thrown when an error occurs during Json serialization or deserialization.
  /// </summary>
#if !(SILVERLIGHT || WINDOWS_PHONE || NETFX_CORE || PORTABLE)
  [Serializable]
#endif
  public class JsonException : Exception
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonException"/> class.
    /// </summary>
    public JsonException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonException"/> class
    /// with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public JsonException(string message)
      : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonException"/> class
    /// with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    public JsonException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

#if !(WINDOWS_PHONE || SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonException"/> class.
    /// </summary>
    /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
    /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
    /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
    public JsonException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
    }
#endif
  }
}
#endregion JsonException.cs

/// ********   File: \JsonIgnoreAttribute.cs
#region JsonIgnoreAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> not to serialize the public field or public read/write property value.
  /// </summary>
  [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false)]
  public sealed class JsonIgnoreAttribute : Attribute
  {
  }
}
#endregion JsonIgnoreAttribute.cs

/// ********   File: \JsonObjectAttribute.cs
#region JsonObjectAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> how to serialize the object.
  /// </summary>
  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
  public sealed class JsonObjectAttribute : JsonContainerAttribute
  {
    private MemberSerialization _memberSerialization = MemberSerialization.OptOut;

    // yuck. can't set nullable properties on an attribute in C#
    // have to use this approach to get an unset default state
    internal Required? _itemRequired;

    /// <summary>
    /// Gets or sets the member serialization.
    /// </summary>
    /// <value>The member serialization.</value>
    public MemberSerialization MemberSerialization
    {
      get { return _memberSerialization; }
      set { _memberSerialization = value; }
    }

    /// <summary>
    /// Gets or sets a value that indicates whether the object's properties are required.
    /// </summary>
    /// <value>
    /// 	A value indicating whether the object's properties are required.
    /// </value>
    public Required ItemRequired
    {
      get { return _itemRequired ?? default(Required); }
      set { _itemRequired = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonObjectAttribute"/> class.
    /// </summary>
    public JsonObjectAttribute()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonObjectAttribute"/> class with the specified member serialization.
    /// </summary>
    /// <param name="memberSerialization">The member serialization.</param>
    public JsonObjectAttribute(MemberSerialization memberSerialization)
    {
      MemberSerialization = memberSerialization;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonObjectAttribute"/> class with the specified container Id.
    /// </summary>
    /// <param name="id">The container Id.</param>
    public JsonObjectAttribute(string id)
      : base(id)
    {
    }
  }
}
#endregion JsonObjectAttribute.cs

/// ********   File: \JsonPosition.cs
#region JsonPosition.cs

namespace Newtonsoft.Json
{
  internal enum JsonContainerType
  {
    None,
    Object,
    Array,
    Constructor
  }

  internal struct JsonPosition
  {
    internal JsonContainerType Type;
    internal int Position;
    internal string PropertyName;
    internal bool HasIndex;

    public JsonPosition(JsonContainerType type)
    {
      Type = type;
      HasIndex = TypeHasIndex(type);
      Position = -1;
      PropertyName = null;
    }

    internal void WriteTo(StringBuilder sb)
    {
      switch (Type)
      {
        case JsonContainerType.Object:
          if (sb.Length > 0)
            sb.Append(".");
          sb.Append(PropertyName);
          break;
        case JsonContainerType.Array:
        case JsonContainerType.Constructor:
          sb.Append("[");
          sb.Append(Position);
          sb.Append("]");
          break;
      }
    }

    internal static bool TypeHasIndex(JsonContainerType type)
    {
      return (type == JsonContainerType.Array || type == JsonContainerType.Constructor);
    }

    internal static string BuildPath(IEnumerable<JsonPosition> positions)
    {
      StringBuilder sb = new StringBuilder();

      foreach (JsonPosition state in positions)
      {
        state.WriteTo(sb);
      }

      return sb.ToString();
    }

    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
    {
      // don't add a fullstop and space when message ends with a new line
      if (!message.EndsWith(Environment.NewLine))
      {
        message = message.Trim();

        if (!message.EndsWith("."))
          message += ".";

        message += " ";
      }

      message += "Path '{0}'".FormatWith(CultureInfo.InvariantCulture, path);

      if (lineInfo != null && lineInfo.HasLineInfo())
        message += ", line {0}, position {1}".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);

      message += ".";

      return message;
    }
  }
}
#endregion JsonPosition.cs

/// ********   File: \JsonPropertyAttribute.cs
#region JsonPropertyAttribute.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Instructs the <see cref="JsonSerializer"/> to always serialize the member with the specified name.
  /// </summary>
  [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter, AllowMultiple = false)]
  public sealed class JsonPropertyAttribute : Attribute
  {
    // yuck. can't set nullable properties on an attribute in C#
    // have to use this approach to get an unset default state
    internal NullValueHandling? _nullValueHandling;
    internal DefaultValueHandling? _defaultValueHandling;
    internal ReferenceLoopHandling? _referenceLoopHandling;
    internal ObjectCreationHandling? _objectCreationHandling;
    internal TypeNameHandling? _typeNameHandling;
    internal bool? _isReference;
    internal int? _order;
    internal Required? _required;
    internal bool? _itemIsReference;
    internal ReferenceLoopHandling? _itemReferenceLoopHandling;
    internal TypeNameHandling? _itemTypeNameHandling;

    /// <summary>
    /// Gets or sets the converter used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items converter.</value>
    public Type ItemConverterType { get; set; }

    /// <summary>
    /// Gets or sets the null value handling used when serializing this property.
    /// </summary>
    /// <value>The null value handling.</value>
    public NullValueHandling NullValueHandling
    {
      get { return _nullValueHandling ?? default(NullValueHandling); }
      set { _nullValueHandling = value; }
    }

    /// <summary>
    /// Gets or sets the default value handling used when serializing this property.
    /// </summary>
    /// <value>The default value handling.</value>
    public DefaultValueHandling DefaultValueHandling
    {
      get { return _defaultValueHandling ?? default(DefaultValueHandling); }
      set { _defaultValueHandling = value; }
    }

    /// <summary>
    /// Gets or sets the reference loop handling used when serializing this property.
    /// </summary>
    /// <value>The reference loop handling.</value>
    public ReferenceLoopHandling ReferenceLoopHandling
    {
      get { return _referenceLoopHandling ?? default(ReferenceLoopHandling); }
      set { _referenceLoopHandling = value; }
    }

    /// <summary>
    /// Gets or sets the object creation handling used when deserializing this property.
    /// </summary>
    /// <value>The object creation handling.</value>
    public ObjectCreationHandling ObjectCreationHandling
    {
      get { return _objectCreationHandling ?? default(ObjectCreationHandling); }
      set { _objectCreationHandling = value; }
    }

    /// <summary>
    /// Gets or sets the type name handling used when serializing this property.
    /// </summary>
    /// <value>The type name handling.</value>
    public TypeNameHandling TypeNameHandling
    {
      get { return _typeNameHandling ?? default(TypeNameHandling); }
      set { _typeNameHandling = value; }
    }

    /// <summary>
    /// Gets or sets whether this property's value is serialized as a reference.
    /// </summary>
    /// <value>Whether this property's value is serialized as a reference.</value>
    public bool IsReference
    {
      get { return _isReference ?? default(bool); }
      set { _isReference = value; }
    }

    /// <summary>
    /// Gets or sets the order of serialization and deserialization of a member.
    /// </summary>
    /// <value>The numeric order of serialization or deserialization.</value>
    public int Order
    {
      get { return _order ?? default(int); }
      set { _order = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether this property is required.
    /// </summary>
    /// <value>
    /// 	A value indicating whether this property is required.
    /// </value>
    public Required Required
    {
      get { return _required ?? Required.Default; }
      set { _required = value; }
    }

    /// <summary>
    /// Gets or sets the name of the property.
    /// </summary>
    /// <value>The name of the property.</value>
    public string PropertyName { get; set; }

    /// <summary>
    /// Gets or sets the the reference loop handling used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items reference loop handling.</value>
    public ReferenceLoopHandling ItemReferenceLoopHandling
    {
      get { return _itemReferenceLoopHandling ?? default(ReferenceLoopHandling); }
      set { _itemReferenceLoopHandling = value; }
    }

    /// <summary>
    /// Gets or sets the the type name handling used when serializing the property's collection items.
    /// </summary>
    /// <value>The collection's items type name handling.</value>
    public TypeNameHandling ItemTypeNameHandling
    {
      get { return _itemTypeNameHandling ?? default(TypeNameHandling); }
      set { _itemTypeNameHandling = value; }
    }

    /// <summary>
    /// Gets or sets whether this property's collection items are serialized as a reference.
    /// </summary>
    /// <value>Whether this property's collection items are serialized as a reference.</value>
    public bool ItemIsReference
    {
      get { return _itemIsReference ?? default(bool); }
      set { _itemIsReference = value; }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonPropertyAttribute"/> class.
    /// </summary>
    public JsonPropertyAttribute()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonPropertyAttribute"/> class with the specified name.
    /// </summary>
    /// <param name="propertyName">Name of the property.</param>
    public JsonPropertyAttribute(string propertyName)
    {
      PropertyName = propertyName;
    }
  }
}
#endregion JsonPropertyAttribute.cs

/// ********   File: \JsonReader.cs
#region JsonReader.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json
{
  /// <summary>
  /// Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
  /// </summary>
  public abstract class JsonReader : IDisposable
  {
    /// <summary>
    /// Specifies the state of the reader.
    /// </summary>
    protected internal enum State
    {
      /// <summary>
      /// The Read method has not been called.
      /// </summary>
      Start,
      /// <summary>
      /// The end of the file has been reached successfully.
      /// </summary>
      Complete,
      /// <summary>
      /// Reader is at a property.
      /// </summary>
      Property,
      /// <summary>
      /// Reader is at the start of an object.
      /// </summary>
      ObjectStart,
      /// <summary>
      /// Reader is in an object.
      /// </summary>
      Object,
      /// <summary>
      /// Reader is at the start of an array.
      /// </summary>
      ArrayStart,
      /// <summary>
      /// Reader is in an array.
      /// </summary>
      Array,
      /// <summary>
      /// The Close method has been called.
      /// </summary>
      Closed,
      /// <summary>
      /// Reader has just read a value.
      /// </summary>
      PostValue,
      /// <summary>
      /// Reader is at the start of a constructor.
      /// </summary>
      ConstructorStart,
      /// <summary>
      /// Reader in a constructor.
      /// </summary>
      Constructor,
      /// <summary>
      /// An error occurred that prevents the read operation from continuing.
      /// </summary>
      Error,
      /// <summary>
      /// The end of the file has been reached successfully.
      /// </summary>
      Finished
    }

    // current Token data
    private JsonToken _tokenType;
    private object _value;
    private char _quoteChar;
    internal State _currentState;
    internal ReadType _readType;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private int? _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    private readonly List<JsonPosition> _stack;

    /// <summary>
    /// Gets the current reader state.
    /// </summary>
    /// <value>The current reader state.</value>
    protected State CurrentState
    {
      get { return _currentState; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the underlying stream or
    /// <see cref="TextReader"/> should be closed when the reader is closed.
    /// </summary>
    /// <value>
    /// true to close the underlying stream or <see cref="TextReader"/> when
    /// the reader is closed; otherwise false. The default is true.
    /// </value>
    public bool CloseInput { get; set; }

    /// <summary>
    /// Gets the quotation mark character used to enclose the value of a string.
    /// </summary>
    public virtual char QuoteChar
    {
      get { return _quoteChar; }
      protected internal set { _quoteChar = value; }
    }

    /// <summary>
    /// Get or set how <see cref="DateTime"/> time zones are handling when reading JSON.
    /// </summary>
    public DateTimeZoneHandling DateTimeZoneHandling
    {
      get { return _dateTimeZoneHandling; }
      set { _dateTimeZoneHandling = value; }
    }

    /// <summary>
    /// Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
    /// </summary>
    public DateParseHandling DateParseHandling
    {
      get { return _dateParseHandling; }
      set { _dateParseHandling = value; }
    }

    /// <summary>
    /// Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="JsonReaderException"/>.
    /// </summary>
    public int? MaxDepth
    {
      get { return _maxDepth; }
      set
      {
        if (value <= 0)
          throw new ArgumentException("Value must be positive.", "value");

        _maxDepth = value;
      }
    }

    /// <summary>
    /// Gets the type of the current JSON token. 
    /// </summary>
    public virtual JsonToken TokenType
    {
      get { return _tokenType; }
    }

    /// <summary>
    /// Gets the text value of the current JSON token.
    /// </summary>
    public virtual object Value
    {
      get { return _value; }
    }

    /// <summary>
    /// Gets The Common Language Runtime (CLR) type for the current JSON token.
    /// </summary>
    public virtual Type ValueType
    {
      get { return (_value != null) ? _value.GetType() : null; }
    }

    /// <summary>
    /// Gets the depth of the current token in the JSON document.
    /// </summary>
    /// <value>The depth of the current token in the JSON document.</value>
    public virtual int Depth
    {
      get
      {
        int depth = _stack.Count;
        if (IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)
          return depth;
        else
          return depth + 1;
      }
    }

    /// <summary>
    /// Gets the path of the current JSON token. 
    /// </summary>
    public virtual string Path
    {
      get
      {
        if (_currentPosition.Type == JsonContainerType.None)
          return string.Empty;

        bool insideContainer = (_currentState != State.ArrayStart
          && _currentState != State.ConstructorStart
          && _currentState != State.ObjectStart);

        IEnumerable<JsonPosition> positions = (!insideContainer)
          ? _stack
          : _stack.Concat(new[] {_currentPosition});

        return JsonPosition.BuildPath(positions);
      }
    }

    /// <summary>
    /// Gets or sets the culture used when reading JSON. Defaults to <see cref="CultureInfo.InvariantCulture"/>.
    /// </summary>
    public CultureInfo Culture
    {
      get { return _culture ?? CultureInfo.InvariantCulture; }
      set { _culture = value; }
    }

    internal JsonPosition GetPosition(int depth)
    {
      if (depth < _stack.Count)
        return _stack[depth];

      return _currentPosition;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReader"/> class with the specified <see cref="TextReader"/>.
    /// </summary>
    protected JsonReader()
    {
      _currentState = State.Start;
      _stack = new List<JsonPosition>(4);
      _dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
      _dateParseHandling = DateParseHandling.DateTime;

      CloseInput = true;
    }

    private void Push(JsonContainerType value)
    {
      UpdateScopeWithFinishedValue();

      if (_currentPosition.Type == JsonContainerType.None)
      {
        _currentPosition = new JsonPosition(value);
      }
      else
      {
        _stack.Add(_currentPosition);
        _currentPosition = new JsonPosition(value);

        // this is a little hacky because Depth increases when first property/value is written but only testing here is faster/simpler
        if (_maxDepth != null && Depth + 1 > _maxDepth && !_hasExceededMaxDepth)
        {
          _hasExceededMaxDepth = true;
          throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture, _maxDepth));
        }
      }
    }

    private JsonContainerType Pop()
    {
      JsonPosition oldPosition;
      if (_stack.Count > 0)
      {
        oldPosition = _currentPosition;
        _currentPosition = _stack[_stack.Count - 1];
        _stack.RemoveAt(_stack.Count - 1);
      }
      else
      {
        oldPosition = _currentPosition;
        _currentPosition = new JsonPosition();
      }

      if (_maxDepth != null && Depth <= _maxDepth)
        _hasExceededMaxDepth = false;

      return oldPosition.Type;
    }

    private JsonContainerType Peek()
    {
      return _currentPosition.Type;
    }

    /// <summary>
    /// Reads the next JSON token from the stream.
    /// </summary>
    /// <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>
    public abstract bool Read();

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Int32}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public abstract int? ReadAsInt32();

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="String"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public abstract string ReadAsString();

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
    /// </summary>
    /// <returns>A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
    public abstract byte[] ReadAsBytes();

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Decimal}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public abstract decimal? ReadAsDecimal();

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public abstract DateTime? ReadAsDateTime();

#if !NET20
    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{DateTimeOffset}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public abstract DateTimeOffset? ReadAsDateTimeOffset();
#endif

    internal virtual bool ReadInternal()
    {
      throw new NotImplementedException();
    }

#if !NET20
    internal DateTimeOffset? ReadAsDateTimeOffsetInternal()
    {
      _readType = ReadType.ReadAsDateTimeOffset;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (TokenType == JsonToken.Date)
      {
        if (Value is DateTime)
          SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value));

        return (DateTimeOffset)Value;
      }

      if (TokenType == JsonToken.Null)
        return null;

      DateTimeOffset dt;
      if (TokenType == JsonToken.String)
      {
        string s = (string)Value;
        if (string.IsNullOrEmpty(s))
        {
          SetToken(JsonToken.Null);
          return null;
        }

        if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
        {
          SetToken(JsonToken.Date, dt);
          return dt;
        }
        else
        {
          throw JsonReaderException.Create(this, "Could not convert string to DateTimeOffset: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
        }
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }
#endif

    internal byte[] ReadAsBytesInternal()
    {
      _readType = ReadType.ReadAsBytes;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (IsWrappedInTypeObject())
      {
        byte[] data = ReadAsBytes();
        ReadInternal();
        SetToken(JsonToken.Bytes, data);
        return data;
      }

      // attempt to convert possible base 64 string to bytes
      if (TokenType == JsonToken.String)
      {
        string s = (string)Value;
        byte[] data = (s.Length == 0) ? new byte[0] : Convert.FromBase64String(s);
        SetToken(JsonToken.Bytes, data);
      }

      if (TokenType == JsonToken.Null)
        return null;

      if (TokenType == JsonToken.Bytes)
        return (byte[])Value;

      if (TokenType == JsonToken.StartArray)
      {
        List<byte> data = new List<byte>();

        while (ReadInternal())
        {
          switch (TokenType)
          {
            case JsonToken.Integer:
              data.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
              break;
            case JsonToken.EndArray:
              byte[] d = data.ToArray();
              SetToken(JsonToken.Bytes, d);
              return d;
            case JsonToken.Comment:
              // skip
              break;
            default:
              throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
          }
        }

        throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }

    internal decimal? ReadAsDecimalInternal()
    {
      _readType = ReadType.ReadAsDecimal;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (TokenType == JsonToken.Integer || TokenType == JsonToken.Float)
      {
        if (!(Value is decimal))
          SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture));

        return (decimal)Value;
      }

      if (TokenType == JsonToken.Null)
        return null;

      decimal d;
      if (TokenType == JsonToken.String)
      {
        string s = (string)Value;
        if (string.IsNullOrEmpty(s))
        {
          SetToken(JsonToken.Null);
          return null;
        }

        if (decimal.TryParse(s, NumberStyles.Number, Culture, out d))
        {
          SetToken(JsonToken.Float, d);
          return d;
        }
        else
        {
          throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
        }
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }

    internal int? ReadAsInt32Internal()
    {
      _readType = ReadType.ReadAsInt32;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (TokenType == JsonToken.Integer || TokenType == JsonToken.Float)
      {
        if (!(Value is int))
          SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture));

        return (int)Value;
      }

      if (TokenType == JsonToken.Null)
        return null;

      int i;
      if (TokenType == JsonToken.String)
      {
        string s = (string)Value;
        if (string.IsNullOrEmpty(s))
        {
          SetToken(JsonToken.Null);
          return null;
        }

        if (int.TryParse(s, NumberStyles.Integer, Culture, out i))
        {
          SetToken(JsonToken.Integer, i);
          return i;
        }
        else
        {
          throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
        }
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }

    internal string ReadAsStringInternal()
    {
      _readType = ReadType.ReadAsString;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (TokenType == JsonToken.String)
        return (string)Value;

      if (TokenType == JsonToken.Null)
        return null;

      if (IsPrimitiveToken(TokenType))
      {
        if (Value != null)
        {
          string s;
          if (ConvertUtils.IsConvertible(Value))
            s = ConvertUtils.ToConvertible(Value).ToString(Culture);
          else if (Value is IFormattable)
            s = ((IFormattable)Value).ToString(null, Culture);
          else
            s = Value.ToString();

          SetToken(JsonToken.String, s);
          return s;
        }
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }

    internal DateTime? ReadAsDateTimeInternal()
    {
      _readType = ReadType.ReadAsDateTime;

      do
      {
        if (!ReadInternal())
        {
          SetToken(JsonToken.None);
          return null;
        }
      } while (TokenType == JsonToken.Comment);

      if (TokenType == JsonToken.Date)
        return (DateTime)Value;

      if (TokenType == JsonToken.Null)
        return null;

      DateTime dt;
      if (TokenType == JsonToken.String)
      {
        string s = (string)Value;
        if (string.IsNullOrEmpty(s))
        {
          SetToken(JsonToken.Null);
          return null;
        }

        if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
        {
          dt = JsonConvert.EnsureDateTime(dt, DateTimeZoneHandling);
          SetToken(JsonToken.Date, dt);
          return dt;
        }
        else
        {
          throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
        }
      }

      if (TokenType == JsonToken.EndArray)
        return null;

      throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
    }

    private bool IsWrappedInTypeObject()
    {
      _readType = ReadType.Read;

      if (TokenType == JsonToken.StartObject)
      {
        if (!ReadInternal())
          throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");

        if (Value.ToString() == "$type")
        {
          ReadInternal();
          if (Value != null && Value.ToString().StartsWith("System.Byte[]"))
          {
            ReadInternal();
            if (Value.ToString() == "$value")
            {
              return true;
            }
          }
        }

        throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
      }

      return false;
    }

    /// <summary>
    /// Skips the children of the current token.
    /// </summary>
    public void Skip()
    {
      if (TokenType == JsonToken.PropertyName)
        Read();

      if (IsStartToken(TokenType))
      {
        int depth = Depth;

        while (Read() && (depth < Depth))
        {
        }
      }
    }

    /// <summary>
    /// Sets the current token.
    /// </summary>
    /// <param name="newToken">The new token.</param>
    protected void SetToken(JsonToken newToken)
    {
      SetToken(newToken, null);
    }

    /// <summary>
    /// Sets the current token and value.
    /// </summary>
    /// <param name="newToken">The new token.</param>
    /// <param name="value">The value.</param>
    protected void SetToken(JsonToken newToken, object value)
    {
      _tokenType = newToken;
      _value = value;

      switch (newToken)
      {
        case JsonToken.StartObject:
          _currentState = State.ObjectStart;
          Push(JsonContainerType.Object);
          break;
        case JsonToken.StartArray:
          _currentState = State.ArrayStart;
          Push(JsonContainerType.Array);
          break;
        case JsonToken.StartConstructor:
          _currentState = State.ConstructorStart;
          Push(JsonContainerType.Constructor);
          break;
        case JsonToken.EndObject:
          ValidateEnd(JsonToken.EndObject);
          break;
        case JsonToken.EndArray:
          ValidateEnd(JsonToken.EndArray);
          break;
        case JsonToken.EndConstructor:
          ValidateEnd(JsonToken.EndConstructor);
          break;
        case JsonToken.PropertyName:
          _currentState = State.Property;

          _currentPosition.PropertyName = (string) value;
          break;
        case JsonToken.Undefined:
        case JsonToken.Integer:
        case JsonToken.Float:
        case JsonToken.Boolean:
        case JsonToken.Null:
        case JsonToken.Date:
        case JsonToken.String:
        case JsonToken.Raw:
        case JsonToken.Bytes:
          _currentState = (Peek() != JsonContainerType.None) ? State.PostValue : State.Finished;

          UpdateScopeWithFinishedValue();
          break;
      }
    }

    private void UpdateScopeWithFinishedValue()
    {
      if (_currentPosition.HasIndex)
        _currentPosition.Position++;
    }

    private void ValidateEnd(JsonToken endToken)
    {
      JsonContainerType currentObject = Pop();

      if (GetTypeForCloseToken(endToken) != currentObject)
        throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture, endToken, currentObject));

      _currentState = (Peek() != JsonContainerType.None) ? State.PostValue : State.Finished;
    }

    /// <summary>
    /// Sets the state based on current token type.
    /// </summary>
    protected void SetStateBasedOnCurrent()
    {
      JsonContainerType currentObject = Peek();

      switch (currentObject)
      {
        case JsonContainerType.Object:
          _currentState = State.Object;
          break;
        case JsonContainerType.Array:
          _currentState = State.Array;
          break;
        case JsonContainerType.Constructor:
          _currentState = State.Constructor;
          break;
        case JsonContainerType.None:
          _currentState = State.Finished;
          break;
        default:
          throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture, currentObject));
      }
    }

    internal static bool IsPrimitiveToken(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.Integer:
        case JsonToken.Float:
        case JsonToken.String:
        case JsonToken.Boolean:
        case JsonToken.Undefined:
        case JsonToken.Null:
        case JsonToken.Date:
        case JsonToken.Bytes:
          return true;
        default:
          return false;
      }
    }

    internal static bool IsStartToken(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.StartObject:
        case JsonToken.StartArray:
        case JsonToken.StartConstructor:
          return true;
        default:
          return false;
      }
    }

    private JsonContainerType GetTypeForCloseToken(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.EndObject:
          return JsonContainerType.Object;
        case JsonToken.EndArray:
          return JsonContainerType.Array;
        case JsonToken.EndConstructor:
          return JsonContainerType.Constructor;
        default:
          throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture, token));
      }
    }

    /// <summary>
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
    /// </summary>
    void IDisposable.Dispose()
    {
      Dispose(true);
    }

    /// <summary>
    /// Releases unmanaged and - optionally - managed resources
    /// </summary>
    /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    protected virtual void Dispose(bool disposing)
    {
      if (_currentState != State.Closed && disposing)
        Close();
    }

    /// <summary>
    /// Changes the <see cref="State"/> to Closed. 
    /// </summary>
    public virtual void Close()
    {
      _currentState = State.Closed;
      _tokenType = JsonToken.None;
      _value = null;
    }
  }
}
#endregion JsonReader.cs

/// ********   File: \JsonReaderException.cs
#region JsonReaderException.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// The exception thrown when an error occurs while reading Json text.
  /// </summary>
#if !(SILVERLIGHT || WINDOWS_PHONE || NETFX_CORE || PORTABLE)
  [Serializable]
#endif
  public class JsonReaderException : JsonException
  {
    /// <summary>
    /// Gets the line number indicating where the error occurred.
    /// </summary>
    /// <value>The line number indicating where the error occurred.</value>
    public int LineNumber { get; private set; }

    /// <summary>
    /// Gets the line position indicating where the error occurred.
    /// </summary>
    /// <value>The line position indicating where the error occurred.</value>
    public int LinePosition { get; private set; }

    /// <summary>
    /// Gets the path to the JSON where the error occurred.
    /// </summary>
    /// <value>The path to the JSON where the error occurred.</value>
    public string Path { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReaderException"/> class.
    /// </summary>
    public JsonReaderException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReaderException"/> class
    /// with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public JsonReaderException(string message)
      : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReaderException"/> class
    /// with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    public JsonReaderException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

#if !(WINDOWS_PHONE || SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReaderException"/> class.
    /// </summary>
    /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
    /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
    /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
    public JsonReaderException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
    }
#endif

    internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition)
      : base(message, innerException)
    {
      Path = path;
      LineNumber = lineNumber;
      LinePosition = linePosition;
    }

    internal static JsonReaderException Create(JsonReader reader, string message)
    {
      return Create(reader, message, null);
    }

    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex)
    {
      return Create(reader as IJsonLineInfo, reader.Path, message, ex);
    }

    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
    {
      message = JsonPosition.FormatMessage(lineInfo, path, message);

      int lineNumber;
      int linePosition;
      if (lineInfo != null && lineInfo.HasLineInfo())
      {
        lineNumber = lineInfo.LineNumber;
        linePosition = lineInfo.LinePosition;
      }
      else
      {
        lineNumber = 0;
        linePosition = 0;
      }

      return new JsonReaderException(message, ex, path, lineNumber, linePosition);
    }
  }
}

#endregion JsonReaderException.cs

/// ********   File: \JsonSerializationException.cs
#region JsonSerializationException.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// The exception thrown when an error occurs during Json serialization or deserialization.
  /// </summary>
#if !(SILVERLIGHT || WINDOWS_PHONE || NETFX_CORE || PORTABLE)
  [Serializable]
#endif
  public class JsonSerializationException : JsonException
  {
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializationException"/> class.
    /// </summary>
    public JsonSerializationException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializationException"/> class
    /// with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public JsonSerializationException(string message)
      : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializationException"/> class
    /// with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    public JsonSerializationException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

#if !(WINDOWS_PHONE || SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializationException"/> class.
    /// </summary>
    /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
    /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
    /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
    public JsonSerializationException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
    }
#endif

    internal static JsonSerializationException Create(JsonReader reader, string message)
    {
      return Create(reader, message, null);
    }

    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex)
    {
      return Create(reader as IJsonLineInfo, reader.Path, message, ex);
    }

    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
    {
      message = JsonPosition.FormatMessage(lineInfo, path, message);

      return new JsonSerializationException(message, ex);
    }
  }
}
#endregion JsonSerializationException.cs

/// ********   File: \JsonSerializer.cs
#region JsonSerializer.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Serializes and deserializes objects into and from the JSON format.
  /// The <see cref="JsonSerializer"/> enables you to control how objects are encoded into JSON.
  /// </summary>
  public class JsonSerializer
  {
    #region Properties
    private TypeNameHandling _typeNameHandling;
    private FormatterAssemblyStyle _typeNameAssemblyFormat;
    private PreserveReferencesHandling _preserveReferencesHandling;
    private ReferenceLoopHandling _referenceLoopHandling;
    private MissingMemberHandling _missingMemberHandling;
    private ObjectCreationHandling _objectCreationHandling;
    private NullValueHandling _nullValueHandling;
    private DefaultValueHandling _defaultValueHandling;
    private ConstructorHandling _constructorHandling;
    private JsonConverterCollection _converters;
    private IContractResolver _contractResolver;
    private IReferenceResolver _referenceResolver;
    private ITraceWriter _traceWriter;
    private SerializationBinder _binder;
    private StreamingContext _context;
    private Formatting? _formatting;
    private DateFormatHandling? _dateFormatHandling;
    private DateTimeZoneHandling? _dateTimeZoneHandling;
    private DateParseHandling? _dateParseHandling;
    private CultureInfo _culture;
    private int? _maxDepth;
    private bool _maxDepthSet;
    private bool? _checkAdditionalContent;

    /// <summary>
    /// Occurs when the <see cref="JsonSerializer"/> errors during serialization and deserialization.
    /// </summary>
    public virtual event EventHandler<ErrorEventArgs> Error;

    /// <summary>
    /// Gets or sets the <see cref="IReferenceResolver"/> used by the serializer when resolving references.
    /// </summary>
    public virtual IReferenceResolver ReferenceResolver
    {
      get
      {
        if (_referenceResolver == null)
          _referenceResolver = new DefaultReferenceResolver();

        return _referenceResolver;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException("value", "Reference resolver cannot be null.");

        _referenceResolver = value;
      }
    }

    /// <summary>
    /// Gets or sets the <see cref="SerializationBinder"/> used by the serializer when resolving type names.
    /// </summary>
    public virtual SerializationBinder Binder
    {
      get
      {
        return _binder;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException("value", "Serialization binder cannot be null.");

        _binder = value;
      }
    }

    /// <summary>
    /// Gets or sets the <see cref="ITraceWriter"/> used by the serializer when writing trace messages.
    /// </summary>
    /// <value>The trace writer.</value>
    public virtual ITraceWriter TraceWriter
    {
      get
      {
        return _traceWriter;
      }
      set
      {
        _traceWriter = value;
      }
    }

    /// <summary>
    /// Gets or sets how type name writing and reading is handled by the serializer.
    /// </summary>
    public virtual TypeNameHandling TypeNameHandling
    {
      get { return _typeNameHandling; }
      set
      {
        if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
          throw new ArgumentOutOfRangeException("value");

        _typeNameHandling = value;
      }
    }

    /// <summary>
    /// Gets or sets how a type name assembly is written and resolved by the serializer.
    /// </summary>
    /// <value>The type name assembly format.</value>
    public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
    {
      get { return _typeNameAssemblyFormat; }
      set
      {
        if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
          throw new ArgumentOutOfRangeException("value");

        _typeNameAssemblyFormat = value;
      }
    }

    /// <summary>
    /// Gets or sets how object references are preserved by the serializer.
    /// </summary>
    public virtual PreserveReferencesHandling PreserveReferencesHandling
    {
      get { return _preserveReferencesHandling; }
      set
      {
        if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
          throw new ArgumentOutOfRangeException("value");

        _preserveReferencesHandling = value;
      }
    }

    /// <summary>
    /// Get or set how reference loops (e.g. a class referencing itself) is handled.
    /// </summary>
    public virtual ReferenceLoopHandling ReferenceLoopHandling
    {
      get { return _referenceLoopHandling; }
      set
      {
        if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
          throw new ArgumentOutOfRangeException("value");

        _referenceLoopHandling = value;
      }
    }

    /// <summary>
    /// Get or set how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
    /// </summary>
    public virtual MissingMemberHandling MissingMemberHandling
    {
      get { return _missingMemberHandling; }
      set
      {
        if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
          throw new ArgumentOutOfRangeException("value");

        _missingMemberHandling = value;
      }
    }

    /// <summary>
    /// Get or set how null values are handled during serialization and deserialization.
    /// </summary>
    public virtual NullValueHandling NullValueHandling
    {
      get { return _nullValueHandling; }
      set
      {
        if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
          throw new ArgumentOutOfRangeException("value");

        _nullValueHandling = value;
      }
    }

    /// <summary>
    /// Get or set how null default are handled during serialization and deserialization.
    /// </summary>
    public virtual DefaultValueHandling DefaultValueHandling
    {
      get { return _defaultValueHandling; }
      set
      {
        if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
          throw new ArgumentOutOfRangeException("value");

        _defaultValueHandling = value;
      }
    }

    /// <summary>
    /// Gets or sets how objects are created during deserialization.
    /// </summary>
    /// <value>The object creation handling.</value>
    public virtual ObjectCreationHandling ObjectCreationHandling
    {
      get { return _objectCreationHandling; }
      set
      {
        if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
          throw new ArgumentOutOfRangeException("value");

        _objectCreationHandling = value;
      }
    }

    /// <summary>
    /// Gets or sets how constructors are used during deserialization.
    /// </summary>
    /// <value>The constructor handling.</value>
    public virtual ConstructorHandling ConstructorHandling
    {
      get { return _constructorHandling; }
      set
      {
        if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
          throw new ArgumentOutOfRangeException("value");

        _constructorHandling = value;
      }
    }

    /// <summary>
    /// Gets a collection <see cref="JsonConverter"/> that will be used during serialization.
    /// </summary>
    /// <value>Collection <see cref="JsonConverter"/> that will be used during serialization.</value>
    public virtual JsonConverterCollection Converters
    {
      get
      {
        if (_converters == null)
          _converters = new JsonConverterCollection();

        return _converters;
      }
    }

    /// <summary>
    /// Gets or sets the contract resolver used by the serializer when
    /// serializing .NET objects to JSON and vice versa.
    /// </summary>
    public virtual IContractResolver ContractResolver
    {
      get
      {
        if (_contractResolver == null)
          _contractResolver = DefaultContractResolver.Instance;

        return _contractResolver;
      }
      set { _contractResolver = value; }
    }

    /// <summary>
    /// Gets or sets the <see cref="StreamingContext"/> used by the serializer when invoking serialization callback methods.
    /// </summary>
    /// <value>The context.</value>
    public virtual StreamingContext Context
    {
      get { return _context; }
      set { _context = value; }
    }

    /// <summary>
    /// Indicates how JSON text output is formatted.
    /// </summary>
    public virtual Formatting Formatting
    {
      get { return _formatting ?? JsonSerializerSettings.DefaultFormatting; }
      set { _formatting = value; }
    }

    /// <summary>
    /// Get or set how dates are written to JSON text.
    /// </summary>
    public virtual DateFormatHandling DateFormatHandling
    {
      get { return _dateFormatHandling ?? JsonSerializerSettings.DefaultDateFormatHandling; }
      set { _dateFormatHandling = value; }
    }

    /// <summary>
    /// Get or set how <see cref="DateTime"/> time zones are handling during serialization and deserialization.
    /// </summary>
    public virtual DateTimeZoneHandling DateTimeZoneHandling
    {
      get { return _dateTimeZoneHandling ?? JsonSerializerSettings.DefaultDateTimeZoneHandling; }
      set { _dateTimeZoneHandling = value; }
    }

    /// <summary>
    /// Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
    /// </summary>
    public virtual DateParseHandling DateParseHandling
    {
      get { return _dateParseHandling ?? JsonSerializerSettings.DefaultDateParseHandling; }
      set { _dateParseHandling = value; }
    }

    /// <summary>
    /// Gets or sets the culture used when reading JSON. Defaults to <see cref="CultureInfo.InvariantCulture"/>.
    /// </summary>
    public virtual CultureInfo Culture
    {
      get { return _culture ?? JsonSerializerSettings.DefaultCulture; }
      set { _culture = value; }
    }

    /// <summary>
    /// Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="JsonReaderException"/>.
    /// </summary>
    public virtual int? MaxDepth
    {
      get { return _maxDepth; }
      set
      {
        if (value <= 0)
          throw new ArgumentException("Value must be positive.", "value");

        _maxDepth = value;
        _maxDepthSet = true;
      }
    }

    /// <summary>
    /// Gets a value indicating whether there will be a check for additional JSON content after deserializing an object.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if there will be a check for additional JSON content after deserializing an object; otherwise, <c>false</c>.
    /// </value>
    public virtual bool CheckAdditionalContent
    {
      get { return _checkAdditionalContent ?? JsonSerializerSettings.DefaultCheckAdditionalContent; }
      set { _checkAdditionalContent = value; }
    }

    internal bool IsCheckAdditionalContentSet()
    {
      return (_checkAdditionalContent != null);
    }

    #endregion

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializer"/> class.
    /// </summary>
    public JsonSerializer()
    {
      _referenceLoopHandling = JsonSerializerSettings.DefaultReferenceLoopHandling;
      _missingMemberHandling = JsonSerializerSettings.DefaultMissingMemberHandling;
      _nullValueHandling = JsonSerializerSettings.DefaultNullValueHandling;
      _defaultValueHandling = JsonSerializerSettings.DefaultDefaultValueHandling;
      _objectCreationHandling = JsonSerializerSettings.DefaultObjectCreationHandling;
      _preserveReferencesHandling = JsonSerializerSettings.DefaultPreserveReferencesHandling;
      _constructorHandling = JsonSerializerSettings.DefaultConstructorHandling;
      _typeNameHandling = JsonSerializerSettings.DefaultTypeNameHandling;
      _context = JsonSerializerSettings.DefaultContext;
      _binder = DefaultSerializationBinder.Instance;
    }

    /// <summary>
    /// Creates a new <see cref="JsonSerializer"/> instance using the specified <see cref="JsonSerializerSettings"/>.
    /// </summary>
    /// <param name="settings">The settings to be applied to the <see cref="JsonSerializer"/>.</param>
    /// <returns>A new <see cref="JsonSerializer"/> instance using the specified <see cref="JsonSerializerSettings"/>.</returns>
    public static JsonSerializer Create(JsonSerializerSettings settings)
    {
      JsonSerializer jsonSerializer = new JsonSerializer();

      if (settings != null)
      {
        if (!CollectionUtils.IsNullOrEmpty(settings.Converters))
          jsonSerializer.Converters.AddRange(settings.Converters);

        // serializer specific
        jsonSerializer.TypeNameHandling = settings.TypeNameHandling;
        jsonSerializer.TypeNameAssemblyFormat = settings.TypeNameAssemblyFormat;
        jsonSerializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
        jsonSerializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
        jsonSerializer.MissingMemberHandling = settings.MissingMemberHandling;
        jsonSerializer.ObjectCreationHandling = settings.ObjectCreationHandling;
        jsonSerializer.NullValueHandling = settings.NullValueHandling;
        jsonSerializer.DefaultValueHandling = settings.DefaultValueHandling;
        jsonSerializer.ConstructorHandling = settings.ConstructorHandling;
        jsonSerializer.Context = settings.Context;
        jsonSerializer._checkAdditionalContent = settings._checkAdditionalContent;

        // reader/writer specific
        // unset values won't override reader/writer set values
        jsonSerializer._formatting = settings._formatting;
        jsonSerializer._dateFormatHandling = settings._dateFormatHandling;
        jsonSerializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
        jsonSerializer._dateParseHandling = settings._dateParseHandling;
        jsonSerializer._culture = settings._culture;
        jsonSerializer._maxDepth = settings._maxDepth;
        jsonSerializer._maxDepthSet = settings._maxDepthSet;

        if (settings.Error != null)
          jsonSerializer.Error += settings.Error;

        if (settings.ContractResolver != null)
          jsonSerializer.ContractResolver = settings.ContractResolver;
        if (settings.ReferenceResolver != null)
          jsonSerializer.ReferenceResolver = settings.ReferenceResolver;
        if (settings.TraceWriter != null)
          jsonSerializer.TraceWriter = settings.TraceWriter;
        if (settings.Binder != null)
          jsonSerializer.Binder = settings.Binder;
      }

      return jsonSerializer;
    }

    /// <summary>
    /// Populates the JSON values onto the target object.
    /// </summary>
    /// <param name="reader">The <see cref="TextReader"/> that contains the JSON structure to reader values from.</param>
    /// <param name="target">The target object to populate values onto.</param>
    public void Populate(TextReader reader, object target)
    {
      Populate(new JsonTextReader(reader), target);
    }

    /// <summary>
    /// Populates the JSON values onto the target object.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> that contains the JSON structure to reader values from.</param>
    /// <param name="target">The target object to populate values onto.</param>
    public void Populate(JsonReader reader, object target)
    {
      PopulateInternal(reader, target);
    }

    internal virtual void PopulateInternal(JsonReader reader, object target)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");
      ValidationUtils.ArgumentNotNull(target, "target");

      JsonSerializerInternalReader serializerReader = new JsonSerializerInternalReader(this);
      serializerReader.Populate(reader, target);
    }

    /// <summary>
    /// Deserializes the Json structure contained by the specified <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> that contains the JSON structure to deserialize.</param>
    /// <returns>The <see cref="Object"/> being deserialized.</returns>
    public object Deserialize(JsonReader reader)
    {
      return Deserialize(reader, null);
    }

    /// <summary>
    /// Deserializes the Json structure contained by the specified <see cref="StringReader"/>
    /// into an instance of the specified type.
    /// </summary>
    /// <param name="reader">The <see cref="TextReader"/> containing the object.</param>
    /// <param name="objectType">The <see cref="Type"/> of object being deserialized.</param>
    /// <returns>The instance of <paramref name="objectType"/> being deserialized.</returns>
    public object Deserialize(TextReader reader, Type objectType)
    {
      return Deserialize(new JsonTextReader(reader), objectType);
    }

    /// <summary>
    /// Deserializes the Json structure contained by the specified <see cref="JsonReader"/>
    /// into an instance of the specified type.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> containing the object.</param>
    /// <typeparam name="T">The type of the object to deserialize.</typeparam>
    /// <returns>The instance of <typeparamref name="T"/> being deserialized.</returns>
    public T Deserialize<T>(JsonReader reader)
    {
      return (T)Deserialize(reader, typeof(T));
    }

    /// <summary>
    /// Deserializes the Json structure contained by the specified <see cref="JsonReader"/>
    /// into an instance of the specified type.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> containing the object.</param>
    /// <param name="objectType">The <see cref="Type"/> of object being deserialized.</param>
    /// <returns>The instance of <paramref name="objectType"/> being deserialized.</returns>
    public object Deserialize(JsonReader reader, Type objectType)
    {
      return DeserializeInternal(reader, objectType);
    }

    internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      // set serialization options onto reader
      CultureInfo previousCulture = null;
      if (_culture != null && reader.Culture != _culture)
      {
        previousCulture = reader.Culture;
        reader.Culture = _culture;
      }
      DateTimeZoneHandling? previousDateTimeZoneHandling = null;
      if (_dateTimeZoneHandling != null && reader.DateTimeZoneHandling != _dateTimeZoneHandling)
      {
        previousDateTimeZoneHandling = reader.DateTimeZoneHandling;
        reader.DateTimeZoneHandling = _dateTimeZoneHandling.Value;
      }
      DateParseHandling? previousDateParseHandling = null;
      if (_dateParseHandling != null && reader.DateParseHandling != _dateParseHandling)
      {
        previousDateParseHandling = reader.DateParseHandling;
        reader.DateParseHandling = _dateParseHandling.Value;
      }
      int? previousMaxDepth = null;
      if (_maxDepthSet && reader.MaxDepth != _maxDepth)
      {
        previousMaxDepth = reader.MaxDepth;
        reader.MaxDepth = _maxDepth;
      }

      JsonSerializerInternalReader serializerReader = new JsonSerializerInternalReader(this);
      object value = serializerReader.Deserialize(reader, objectType, CheckAdditionalContent);

      // reset reader back to previous options
      if (previousCulture != null)
        reader.Culture = previousCulture;
      if (previousDateTimeZoneHandling != null)
        reader.DateTimeZoneHandling = previousDateTimeZoneHandling.Value;
      if (previousDateParseHandling != null)
        reader.DateParseHandling = previousDateParseHandling.Value;
      if (_maxDepthSet)
        reader.MaxDepth = previousMaxDepth;

      return value;
    }

    /// <summary>
    /// Serializes the specified <see cref="Object"/> and writes the Json structure
    /// to a <c>Stream</c> using the specified <see cref="TextWriter"/>. 
    /// </summary>
    /// <param name="textWriter">The <see cref="TextWriter"/> used to write the Json structure.</param>
    /// <param name="value">The <see cref="Object"/> to serialize.</param>
    public void Serialize(TextWriter textWriter, object value)
    {
      Serialize(new JsonTextWriter(textWriter), value);
    }

    /// <summary>
    /// Serializes the specified <see cref="Object"/> and writes the Json structure
    /// to a <c>Stream</c> using the specified <see cref="JsonWriter"/>. 
    /// </summary>
    /// <param name="jsonWriter">The <see cref="JsonWriter"/> used to write the Json structure.</param>
    /// <param name="value">The <see cref="Object"/> to serialize.</param>
    public void Serialize(JsonWriter jsonWriter, object value)
    {
      SerializeInternal(jsonWriter, value);
    }

    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value)
    {
      ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");

      // set serialization options onto writer
      Formatting? previousFormatting = null;
      if (_formatting != null && jsonWriter.Formatting != _formatting)
      {
        previousFormatting = jsonWriter.Formatting;
        jsonWriter.Formatting = _formatting.Value;
      }
      DateFormatHandling? previousDateFormatHandling = null;
      if (_dateFormatHandling != null && jsonWriter.DateFormatHandling != _dateFormatHandling)
      {
        previousDateFormatHandling = jsonWriter.DateFormatHandling;
        jsonWriter.DateFormatHandling = _dateFormatHandling.Value;
      }
      DateTimeZoneHandling? previousDateTimeZoneHandling = null;
      if (_dateTimeZoneHandling != null && jsonWriter.DateTimeZoneHandling != _dateTimeZoneHandling)
      {
        previousDateTimeZoneHandling = jsonWriter.DateTimeZoneHandling;
        jsonWriter.DateTimeZoneHandling = _dateTimeZoneHandling.Value;
      }
      
      JsonSerializerInternalWriter serializerWriter = new JsonSerializerInternalWriter(this);
      serializerWriter.Serialize(jsonWriter, value);

      // reset writer back to previous options
      if (previousFormatting != null)
        jsonWriter.Formatting = previousFormatting.Value;
      if (previousDateFormatHandling != null)
        jsonWriter.DateFormatHandling = previousDateFormatHandling.Value;
      if (previousDateTimeZoneHandling != null)
        jsonWriter.DateTimeZoneHandling = previousDateTimeZoneHandling.Value;
    }

    internal JsonConverter GetMatchingConverter(Type type)
    {
      return GetMatchingConverter(_converters, type);
    }

    internal static JsonConverter GetMatchingConverter(IList<JsonConverter> converters, Type objectType)
    {
#if DEBUG
      ValidationUtils.ArgumentNotNull(objectType, "objectType");
#endif

      if (converters != null)
      {
        for (int i = 0; i < converters.Count; i++)
        {
          JsonConverter converter = converters[i];

          if (converter.CanConvert(objectType))
            return converter;
        }
      }

      return null;
    }

    internal void OnError(ErrorEventArgs e)
    {
      EventHandler<ErrorEventArgs> error = Error;
      if (error != null)
        error(this, e);
    }
  }
}
#endregion JsonSerializer.cs

/// ********   File: \JsonSerializerSettings.cs
#region JsonSerializerSettings.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies the settings on a <see cref="JsonSerializer"/> object.
  /// </summary>
  public class JsonSerializerSettings
  {
    internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;
    internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;
    internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;
    internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;
    internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;
    internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;
    internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;
    internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;
    internal const FormatterAssemblyStyle DefaultTypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;
    internal static readonly StreamingContext DefaultContext;

    internal const Formatting DefaultFormatting = Formatting.None;
    internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;
    internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
    internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;
    internal static readonly CultureInfo DefaultCulture;
    internal const bool DefaultCheckAdditionalContent = false;

    internal Formatting? _formatting;
    internal DateFormatHandling? _dateFormatHandling;
    internal DateTimeZoneHandling? _dateTimeZoneHandling;
    internal DateParseHandling? _dateParseHandling;
    internal CultureInfo _culture;
    internal bool? _checkAdditionalContent;
    internal int? _maxDepth;
    internal bool _maxDepthSet;

    /// <summary>
    /// Gets or sets how reference loops (e.g. a class referencing itself) is handled.
    /// </summary>
    /// <value>Reference loop handling.</value>
    public ReferenceLoopHandling ReferenceLoopHandling { get; set; }

    /// <summary>
    /// Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
    /// </summary>
    /// <value>Missing member handling.</value>
    public MissingMemberHandling MissingMemberHandling { get; set; }

    /// <summary>
    /// Gets or sets how objects are created during deserialization.
    /// </summary>
    /// <value>The object creation handling.</value>
    public ObjectCreationHandling ObjectCreationHandling { get; set; }

    /// <summary>
    /// Gets or sets how null values are handled during serialization and deserialization.
    /// </summary>
    /// <value>Null value handling.</value>
    public NullValueHandling NullValueHandling { get; set; }

    /// <summary>
    /// Gets or sets how null default are handled during serialization and deserialization.
    /// </summary>
    /// <value>The default value handling.</value>
    public DefaultValueHandling DefaultValueHandling { get; set; }

    /// <summary>
    /// Gets or sets a collection <see cref="JsonConverter"/> that will be used during serialization.
    /// </summary>
    /// <value>The converters.</value>
    public IList<JsonConverter> Converters { get; set; }

    /// <summary>
    /// Gets or sets how object references are preserved by the serializer.
    /// </summary>
    /// <value>The preserve references handling.</value>
    public PreserveReferencesHandling PreserveReferencesHandling { get; set; }

    /// <summary>
    /// Gets or sets how type name writing and reading is handled by the serializer.
    /// </summary>
    /// <value>The type name handling.</value>
    public TypeNameHandling TypeNameHandling { get; set; }

    /// <summary>
    /// Gets or sets how a type name assembly is written and resolved by the serializer.
    /// </summary>
    /// <value>The type name assembly format.</value>
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; set; }

    /// <summary>
    /// Gets or sets how constructors are used during deserialization.
    /// </summary>
    /// <value>The constructor handling.</value>
    public ConstructorHandling ConstructorHandling { get; set; }

    /// <summary>
    /// Gets or sets the contract resolver used by the serializer when
    /// serializing .NET objects to JSON and vice versa.
    /// </summary>
    /// <value>The contract resolver.</value>
    public IContractResolver ContractResolver { get; set; }

    /// <summary>
    /// Gets or sets the <see cref="IReferenceResolver"/> used by the serializer when resolving references.
    /// </summary>
    /// <value>The reference resolver.</value>
    public IReferenceResolver ReferenceResolver { get; set; }

    /// <summary>
    /// Gets or sets the <see cref="ITraceWriter"/> used by the serializer when writing trace messages.
    /// </summary>
    /// <value>The trace writer.</value>
    public ITraceWriter TraceWriter { get; set; }

    /// <summary>
    /// Gets or sets the <see cref="SerializationBinder"/> used by the serializer when resolving type names.
    /// </summary>
    /// <value>The binder.</value>
    public SerializationBinder Binder { get; set; }

    /// <summary>
    /// Gets or sets the error handler called during serialization and deserialization.
    /// </summary>
    /// <value>The error handler called during serialization and deserialization.</value>
    public EventHandler<ErrorEventArgs> Error { get; set; }

    /// <summary>
    /// Gets or sets the <see cref="StreamingContext"/> used by the serializer when invoking serialization callback methods.
    /// </summary>
    /// <value>The context.</value>
    public StreamingContext Context { get; set; }

    /// <summary>
    /// Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="JsonReaderException"/>.
    /// </summary>
    public int? MaxDepth
    {
      get { return _maxDepth; }
      set
      {
        if (value <= 0)
          throw new ArgumentException("Value must be positive.", "value");

        _maxDepth = value;
        _maxDepthSet = true;
      }
    }

    /// <summary>
    /// Indicates how JSON text output is formatted.
    /// </summary>
    public Formatting Formatting
    {
      get { return _formatting ?? DefaultFormatting; }
      set { _formatting = value; }
    }

    /// <summary>
    /// Get or set how dates are written to JSON text.
    /// </summary>
    public DateFormatHandling DateFormatHandling
    {
      get { return _dateFormatHandling ?? DefaultDateFormatHandling; }
      set { _dateFormatHandling = value; }
    }

    /// <summary>
    /// Get or set how <see cref="DateTime"/> time zones are handling during serialization and deserialization.
    /// </summary>
    public DateTimeZoneHandling DateTimeZoneHandling
    {
      get { return _dateTimeZoneHandling ?? DefaultDateTimeZoneHandling; }
      set { _dateTimeZoneHandling = value; }
    }

    /// <summary>
    /// Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
    /// </summary>
    public DateParseHandling DateParseHandling
    {
      get { return _dateParseHandling ?? DefaultDateParseHandling; }
      set { _dateParseHandling = value; }
    }

    /// <summary>
    /// Gets or sets the culture used when reading JSON. Defaults to <see cref="CultureInfo.InvariantCulture"/>.
    /// </summary>
    public CultureInfo Culture
    {
      get { return _culture ?? DefaultCulture; }
      set { _culture = value; }
    }

    /// <summary>
    /// Gets a value indicating whether there will be a check for additional content after deserializing an object.
    /// </summary>
    /// <value>
    /// 	<c>true</c> if there will be a check for additional content after deserializing an object; otherwise, <c>false</c>.
    /// </value>
    public bool CheckAdditionalContent
    {
      get { return _checkAdditionalContent ?? DefaultCheckAdditionalContent; }
      set { _checkAdditionalContent = value; }
    }

    static JsonSerializerSettings()
    {
      DefaultContext = new StreamingContext();
      DefaultCulture = CultureInfo.InvariantCulture;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSerializerSettings"/> class.
    /// </summary>
    public JsonSerializerSettings()
    {
      ReferenceLoopHandling = DefaultReferenceLoopHandling;
      MissingMemberHandling = DefaultMissingMemberHandling;
      ObjectCreationHandling = DefaultObjectCreationHandling;
      NullValueHandling = DefaultNullValueHandling;
      DefaultValueHandling = DefaultDefaultValueHandling;
      PreserveReferencesHandling = DefaultPreserveReferencesHandling;
      TypeNameHandling = DefaultTypeNameHandling;
      TypeNameAssemblyFormat = DefaultTypeNameAssemblyFormat;
      Context = DefaultContext;

      Converters = new List<JsonConverter>();
    }
  }
}
#endregion JsonSerializerSettings.cs

/// ********   File: \JsonTextReader.cs
#region JsonTextReader.cs

namespace Newtonsoft.Json
{
  internal enum ReadType
  {
    Read,
    ReadAsInt32,
    ReadAsBytes,
    ReadAsString,
    ReadAsDecimal,
    ReadAsDateTime,
#if !NET20
    ReadAsDateTimeOffset
#endif
  }

  /// <summary>
  /// Represents a reader that provides fast, non-cached, forward-only access to JSON text data.
  /// </summary>
  public class JsonTextReader : JsonReader, IJsonLineInfo
  {
    private const char UnicodeReplacementChar = '\uFFFD';

    private readonly TextReader _reader;
    private char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _buffer;
    private StringReference _stringReference;

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonReader"/> class with the specified <see cref="TextReader"/>.
    /// </summary>
    /// <param name="reader">The <c>TextReader</c> containing the XML data to read.</param>
    public JsonTextReader(TextReader reader)
    {
      if (reader == null)
        throw new ArgumentNullException("reader");

      _reader = reader;
      _lineNumber = 1;
      _chars = new char[4097];
    }

    internal void SetCharBuffer(char[] chars)
    {
      _chars = chars;
    }

    private StringBuffer GetBuffer()
    {
      if (_buffer == null)
      {
        _buffer = new StringBuffer(4096);
      }
      else
      {
        _buffer.Position = 0;
      }

      return _buffer;
    }

    private void OnNewLine(int pos)
    {
      _lineNumber++;
      _lineStartPos = pos - 1;
    }

    private void ParseString(char quote)
    {
      _charPos++;

      ShiftBufferIfNeeded();
      ReadStringIntoBuffer(quote);

      if (_readType == ReadType.ReadAsBytes)
      {
        byte[] data;
        if (_stringReference.Length == 0)
        {
          data = new byte[0];
        }
        else
        {
          data = Convert.FromBase64CharArray(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length);
        }

        SetToken(JsonToken.Bytes, data);
      }
      else if (_readType == ReadType.ReadAsString)
      {
        string text = _stringReference.ToString();

        SetToken(JsonToken.String, text);
        QuoteChar = quote;
      }
      else
      {
        string text = _stringReference.ToString();

        if (_dateParseHandling != DateParseHandling.None)
        {
          if (text.Length > 0)
          {
            if (text[0] == '/')
            {
              if (text.StartsWith("/Date(", StringComparison.Ordinal) && text.EndsWith(")/", StringComparison.Ordinal))
              {
                ParseDateMicrosoft(text);
                return;
              }
            }
            else if (char.IsDigit(text[0]) && text.Length >= 19 && text.Length <= 40)
            {
              if (ParseDateIso(text))
                return;
            }
          }
        }

        SetToken(JsonToken.String, text);
        QuoteChar = quote;
      }
    }

    private bool ParseDateIso(string text)
    {
      const string isoDateFormat = "yyyy-MM-ddTHH:mm:ss.FFFFFFFK";

#if !NET20
      if (_readType == ReadType.ReadAsDateTimeOffset || (_readType == ReadType.Read && _dateParseHandling == DateParseHandling.DateTimeOffset))
      {
        DateTimeOffset dateTimeOffset;
        if (DateTimeOffset.TryParseExact(text, isoDateFormat, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dateTimeOffset))
        {
          SetToken(JsonToken.Date, dateTimeOffset);
          return true;
        }
      }
      else
#endif
      {
        DateTime dateTime;
        if (DateTime.TryParseExact(text, isoDateFormat, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dateTime))
        {
          dateTime = JsonConvert.EnsureDateTime(dateTime, DateTimeZoneHandling);

          SetToken(JsonToken.Date, dateTime);
          return true;
        }
      }

      return false;
    }

    private void ParseDateMicrosoft(string text)
    {
      string value = text.Substring(6, text.Length - 8);
      DateTimeKind kind = DateTimeKind.Utc;

      int index = value.IndexOf('+', 1);

      if (index == -1)
        index = value.IndexOf('-', 1);

      TimeSpan offset = TimeSpan.Zero;

      if (index != -1)
      {
        kind = DateTimeKind.Local;
        offset = ReadOffset(value.Substring(index));
        value = value.Substring(0, index);
      }

      long javaScriptTicks = long.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture);

      DateTime utcDateTime = JsonConvert.ConvertJavaScriptTicksToDateTime(javaScriptTicks);

#if !NET20
      if (_readType == ReadType.ReadAsDateTimeOffset || (_readType == ReadType.Read && _dateParseHandling == DateParseHandling.DateTimeOffset))
      {
        SetToken(JsonToken.Date, new DateTimeOffset(utcDateTime.Add(offset).Ticks, offset));
      }
      else
#endif
      {
        DateTime dateTime;

        switch (kind)
        {
          case DateTimeKind.Unspecified:
            dateTime = DateTime.SpecifyKind(utcDateTime.ToLocalTime(), DateTimeKind.Unspecified);
            break;
          case DateTimeKind.Local:
            dateTime = utcDateTime.ToLocalTime();
            break;
          default:
            dateTime = utcDateTime;
            break;
        }

        dateTime = JsonConvert.EnsureDateTime(dateTime, DateTimeZoneHandling);

        SetToken(JsonToken.Date, dateTime);
      }
    }

    private static void BlockCopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int count)
    {
      const int charByteCount = 2;

      Buffer.BlockCopy(src, srcOffset * charByteCount, dst, dstOffset * charByteCount, count * charByteCount);
    }

    private void ShiftBufferIfNeeded()
    {
      // once in the last 10% of the buffer shift the remainling content to the start to avoid
      // unnessesarly increasing the buffer size when reading numbers/strings
      int length = _chars.Length;
      if (length - _charPos <= length * 0.1)
      {
        int count = _charsUsed - _charPos;
        if (count > 0)
          BlockCopyChars(_chars, _charPos, _chars, 0, count);

        _lineStartPos -= _charPos;
        _charPos = 0;
        _charsUsed = count;
        _chars[_charsUsed] = '\0';
      }
    }

    private int ReadData(bool append)
    {
      return ReadData(append, 0);
    }

    private int ReadData(bool append, int charsRequired)
    {
      if (_isEndOfFile)
        return 0;

      // char buffer is full
      if (_charsUsed + charsRequired >= _chars.Length - 1)
      {
        if (append)
        {
          // copy to new array either double the size of the current or big enough to fit required content
          int newArrayLength = Math.Max(_chars.Length * 2, _charsUsed + charsRequired + 1);

          // increase the size of the buffer
          char[] dst = new char[newArrayLength];

          BlockCopyChars(_chars, 0, dst, 0, _chars.Length);

          _chars = dst;
        }
        else
        {
          int remainingCharCount = _charsUsed - _charPos;

          if (remainingCharCount + charsRequired + 1 >= _chars.Length)
          {
            // the remaining count plus the required is bigger than the current buffer size
            char[] dst = new char[remainingCharCount + charsRequired + 1];

            if (remainingCharCount > 0)
              BlockCopyChars(_chars, _charPos, dst, 0, remainingCharCount);

            _chars = dst;
          }
          else
          {
            // copy any remaining data to the beginning of the buffer if needed and reset positions
            if (remainingCharCount > 0)
              BlockCopyChars(_chars, _charPos, _chars, 0, remainingCharCount);
          }

          _lineStartPos -= _charPos;
          _charPos = 0;
          _charsUsed = remainingCharCount;
        }
      }

      int attemptCharReadCount = _chars.Length - _charsUsed - 1;

      int charsRead = _reader.Read(_chars, _charsUsed, attemptCharReadCount);

      _charsUsed += charsRead;

      if (charsRead == 0)
        _isEndOfFile = true;

      _chars[_charsUsed] = '\0';
      return charsRead;
    }

    private bool EnsureChars(int relativePosition, bool append)
    {
      if (_charPos + relativePosition >= _charsUsed)
        return ReadChars(relativePosition, append);

      return true;
    }

    private bool ReadChars(int relativePosition, bool append)
    {
      if (_isEndOfFile)
        return false;

      int charsRequired = _charPos + relativePosition - _charsUsed + 1;

      int totalCharsRead = 0;

      // it is possible that the TextReader doesn't return all data at once
      // repeat read until the required text is returned or the reader is out of content
      do
      {
        int charsRead = ReadData(append, charsRequired - totalCharsRead);

        // no more content
        if (charsRead == 0)
          break;

        totalCharsRead += charsRead;
      }
      while (totalCharsRead < charsRequired);

      if (totalCharsRead < charsRequired)
        return false;
      return true;
    }

    private static TimeSpan ReadOffset(string offsetText)
    {
      bool negative = (offsetText[0] == '-');

      int hours = int.Parse(offsetText.Substring(1, 2), NumberStyles.Integer, CultureInfo.InvariantCulture);
      int minutes = 0;
      if (offsetText.Length >= 5)
        minutes = int.Parse(offsetText.Substring(3, 2), NumberStyles.Integer, CultureInfo.InvariantCulture);

      TimeSpan offset = TimeSpan.FromHours(hours) + TimeSpan.FromMinutes(minutes);
      if (negative)
        offset = offset.Negate();

      return offset;
    }

    /// <summary>
    /// Reads the next JSON token from the stream.
    /// </summary>
    /// <returns>
    /// true if the next token was read successfully; false if there are no more tokens to read.
    /// </returns>
    [DebuggerStepThrough]
    public override bool Read()
    {
      _readType = ReadType.Read;
      if (!ReadInternal())
      {
        SetToken(JsonToken.None);
        return false;
      }

      return true;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
    /// </returns>
    public override byte[] ReadAsBytes()
    {
      return ReadAsBytesInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Decimal}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override decimal? ReadAsDecimal()
    {
      return ReadAsDecimalInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Int32}"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override int? ReadAsInt32()
    {
      return ReadAsInt32Internal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="String"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override string ReadAsString()
    {
      return ReadAsStringInternal();
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTime? ReadAsDateTime()
    {
      return ReadAsDateTimeInternal();
    }

#if !NET20
    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <returns>A <see cref="DateTimeOffset"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTimeOffset? ReadAsDateTimeOffset()
    {
      return ReadAsDateTimeOffsetInternal();
    }
#endif

    internal override bool ReadInternal()
    {
      while (true)
      {
        switch (_currentState)
        {
          case State.Start:
          case State.Property:
          case State.Array:
          case State.ArrayStart:
          case State.Constructor:
          case State.ConstructorStart:
            return ParseValue();
          case State.Complete:
            break;
          case State.Object:
          case State.ObjectStart:
            return ParseObject();
          case State.PostValue:
            // returns true if it hits
            // end of object or array
            if (ParsePostValue())
              return true;
            break;
          case State.Finished:
            if (EnsureChars(0, false))
            {
              EatWhitespace(false);
              if (_isEndOfFile)
              {
                return false;
              }
              if (_chars[_charPos] == '/')
              {
                ParseComment();
                return true;
              }
              else
              {
                throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
              }
            }
            return false;
          case State.Closed:
            break;
          case State.Error:
            break;
          default:
            throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, CurrentState));
        }
      }
    }

    private void ReadStringIntoBuffer(char quote)
    {
      int charPos = _charPos;
      int initialPosition = _charPos;
      int lastWritePosition = _charPos;
      StringBuffer buffer = null;

      while (true)
      {
        switch (_chars[charPos++])
        {
          case '\0':
            if (_charsUsed == charPos - 1)
            {
              charPos--;

              if (ReadData(true) == 0)
              {
                _charPos = charPos;
                throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
              }
            }
            break;
          case '\\':
            _charPos = charPos;
            if (!EnsureChars(0, true))
            {
              _charPos = charPos;
              throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
            }

            // start of escape sequence
            int escapeStartPos = charPos - 1;

            char currentChar = _chars[charPos];

            char writeChar;

            switch (currentChar)
            {
              case 'b':
                charPos++;
                writeChar = '\b';
                break;
              case 't':
                charPos++;
                writeChar = '\t';
                break;
              case 'n':
                charPos++;
                writeChar = '\n';
                break;
              case 'f':
                charPos++;
                writeChar = '\f';
                break;
              case 'r':
                charPos++;
                writeChar = '\r';
                break;
              case '\\':
                charPos++;
                writeChar = '\\';
                break;
              case '"':
              case '\'':
              case '/':
                writeChar = currentChar;
                charPos++;
                break;
              case 'u':
                charPos++;
                _charPos = charPos;
                writeChar = ParseUnicode();
                
                if (StringUtils.IsLowSurrogate(writeChar))
                {
                  // low surrogate with no preceding high surrogate; this char is replaced
                  writeChar = UnicodeReplacementChar;
                }
                else if (StringUtils.IsHighSurrogate(writeChar))
                {
                  bool anotherHighSurrogate;

                  // loop for handling situations where there are multiple consecutive high surrogates
                  do
                  {
                    anotherHighSurrogate = false;

                    // potential start of a surrogate pair
                    if (EnsureChars(2, true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
                    {
                      char highSurrogate = writeChar;

                      _charPos += 2;
                      writeChar = ParseUnicode();

                      if (StringUtils.IsLowSurrogate(writeChar))
                      {
                        // a valid surrogate pair!
                      }
                      else if (StringUtils.IsHighSurrogate(writeChar))
                      {
                        // another high surrogate; replace current and start check over
                        highSurrogate = UnicodeReplacementChar;
                        anotherHighSurrogate = true;
                      }
                      else
                      {
                        // high surrogate not followed by low surrogate; original char is replaced
                        highSurrogate = UnicodeReplacementChar;
                      }

                      if (buffer == null)
                        buffer = GetBuffer();

                      WriteCharToBuffer(buffer, highSurrogate, lastWritePosition, escapeStartPos);
                      lastWritePosition = _charPos;
                    }
                    else
                    {
                      // there are not enough remaining chars for the low surrogate or is not follow by unicode sequence
                      // replace high surrogate and continue on as usual
                      writeChar = UnicodeReplacementChar;
                    }
                  } while (anotherHighSurrogate);
                }

                charPos = _charPos;
                break;
              default:
                charPos++;
                _charPos = charPos;
                throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, @"\" + currentChar));
            }

            if (buffer == null)
              buffer = GetBuffer();

            WriteCharToBuffer(buffer, writeChar, lastWritePosition, escapeStartPos);

            lastWritePosition = charPos;
            break;
          case StringUtils.CarriageReturn:
            _charPos = charPos - 1;
            ProcessCarriageReturn(true);
            charPos = _charPos;
            break;
          case StringUtils.LineFeed:
            _charPos = charPos - 1;
            ProcessLineFeed();
            charPos = _charPos;
            break;
          case '"':
          case '\'':
            if (_chars[charPos - 1] == quote)
            {
              charPos--;

              if (initialPosition == lastWritePosition)
              {
                _stringReference = new StringReference(_chars, initialPosition, charPos - initialPosition);
              }
              else
              {
                if (buffer == null)
                  buffer = GetBuffer();

                if (charPos > lastWritePosition)
                  buffer.Append(_chars, lastWritePosition, charPos - lastWritePosition);

                _stringReference = new StringReference(buffer.GetInternalBuffer(), 0, buffer.Position);
              }

              charPos++;
              _charPos = charPos;
              return;
            }
            break;
        }
      }
    }

    private void WriteCharToBuffer(StringBuffer buffer, char writeChar, int lastWritePosition, int writeToPosition)
    {
      if (writeToPosition > lastWritePosition)
      {
        buffer.Append(_chars, lastWritePosition, writeToPosition - lastWritePosition);
      }

      buffer.Append(writeChar);
    }

    private char ParseUnicode()
    {
      char writeChar;
      if (EnsureChars(4, true))
      {
        string hexValues = new string(_chars, _charPos, 4);
        char hexChar = Convert.ToChar(int.Parse(hexValues, NumberStyles.HexNumber, NumberFormatInfo.InvariantInfo));
        writeChar = hexChar;

        _charPos += 4;
      }
      else
      {
        throw JsonReaderException.Create(this, "Unexpected end while parsing unicode character.");
      }
      return writeChar;
    }

    private void ReadNumberIntoBuffer()
    {
      int charPos = _charPos;

      while (true)
      {
        switch (_chars[charPos++])
        {
          case '\0':
            if (_charsUsed == charPos - 1)
            {
              charPos--;
              _charPos = charPos;
              if (ReadData(true) == 0)
                return;
            }
            break;
          case '-':
          case '+':
          case 'a':
          case 'A':
          case 'b':
          case 'B':
          case 'c':
          case 'C':
          case 'd':
          case 'D':
          case 'e':
          case 'E':
          case 'f':
          case 'F':
          case 'x':
          case 'X':
          case '.':
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            break;
          default:
            _charPos = charPos - 1;
            return;
        }
      }
    }

    private void ClearRecentString()
    {
      if (_buffer != null)
        _buffer.Position = 0;

      _stringReference = new StringReference();
    }

    private bool ParsePostValue()
    {
      while (true)
      {
        char currentChar = _chars[_charPos];

        switch (currentChar)
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(false) == 0)
              {
                _currentState = State.Finished;
                return false;
              }
            }
            else
            {
              _charPos++;
            }
            break;
          case '}':
            _charPos++;
            SetToken(JsonToken.EndObject);
            return true;
          case ']':
            _charPos++;
            SetToken(JsonToken.EndArray);
            return true;
          case ')':
            _charPos++;
            SetToken(JsonToken.EndConstructor);
            return true;
          case '/':
            ParseComment();
            return true;
          case ',':
            _charPos++;

            // finished parsing
            SetStateBasedOnCurrent();
            return false;
          case ' ':
          case StringUtils.Tab:
            // eat
            _charPos++;
            break;
          case StringUtils.CarriageReturn:
            ProcessCarriageReturn(false);
            break;
          case StringUtils.LineFeed:
            ProcessLineFeed();
            break;
          default:
            if (char.IsWhiteSpace(currentChar))
            {
              // eat
              _charPos++;
            }
            else
            {
              throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
            }
            break;
        }
      }
    }

    private bool ParseObject()
    {
      while (true)
      {
        char currentChar = _chars[_charPos];

        switch (currentChar)
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(false) == 0)
                return false;
            }
            else
            {
              _charPos++;
            }
            break;
          case '}':
            SetToken(JsonToken.EndObject);
            _charPos++;
            return true;
          case '/':
            ParseComment();
            return true;
          case StringUtils.CarriageReturn:
            ProcessCarriageReturn(false);
            break;
          case StringUtils.LineFeed:
            ProcessLineFeed();
            break;
          case ' ':
          case StringUtils.Tab:
            // eat
            _charPos++;
            break;
          default:
            if (char.IsWhiteSpace(currentChar))
            {
              // eat
              _charPos++;
            }
            else
            {
              return ParseProperty();
            }
            break;
        }
      }
    }

    private bool ParseProperty()
    {
      char firstChar = _chars[_charPos];
      char quoteChar;

      if (firstChar == '"' || firstChar == '\'')
      {
        _charPos++;
        quoteChar = firstChar;
        ShiftBufferIfNeeded();
        ReadStringIntoBuffer(quoteChar);
      }
      else if (ValidIdentifierChar(firstChar))
      {
        quoteChar = '\0';
        ShiftBufferIfNeeded();
        ParseUnquotedProperty();
      }
      else
      {
        throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
      }

      string propertyName = _stringReference.ToString();

      EatWhitespace(false);

      if (_chars[_charPos] != ':')
        throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));

      _charPos++;

      SetToken(JsonToken.PropertyName, propertyName);
      QuoteChar = quoteChar;
      ClearRecentString();

      return true;
    }

    private bool ValidIdentifierChar(char value)
    {
      return (char.IsLetterOrDigit(value) || value == '_' || value == '$');
    }

    private void ParseUnquotedProperty()
    {
      int initialPosition = _charPos;

      // parse unquoted property name until whitespace or colon
      while (true)
      {
        switch (_chars[_charPos])
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(true) == 0)
                throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");

              break;
            }

            _stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);
            return;
          default:
            char currentChar = _chars[_charPos];

            if (ValidIdentifierChar(currentChar))
            {
              _charPos++;
              break;
            }
            else if (char.IsWhiteSpace(currentChar) || currentChar == ':')
            {
              _stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);
              return;
            }

            throw JsonReaderException.Create(this, "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
        }
      }
    }

    private bool ParseValue()
    {
      while (true)
      {
        char currentChar = _chars[_charPos];

        switch (currentChar)
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(false) == 0)
                return false;
            }
            else
            {
              _charPos++;
            }
            break;
          case '"':
          case '\'':
            ParseString(currentChar);
            return true;
          case 't':
            ParseTrue();
            return true;
          case 'f':
            ParseFalse();
            return true;
          case 'n':
            if (EnsureChars(1, true))
            {
              char next = _chars[_charPos + 1];

              if (next == 'u')
                ParseNull();
              else if (next == 'e')
                ParseConstructor();
              else
                throw JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
            }
            else
            {
              throw JsonReaderException.Create(this, "Unexpected end.");
            }
            return true;
          case 'N':
            ParseNumberNaN();
            return true;
          case 'I':
            ParseNumberPositiveInfinity();
            return true;
          case '-':
            if (EnsureChars(1, true) && _chars[_charPos + 1] == 'I')
              ParseNumberNegativeInfinity();
            else
              ParseNumber();
            return true;
          case '/':
            ParseComment();
            return true;
          case 'u':
            ParseUndefined();
            return true;
          case '{':
            _charPos++;
            SetToken(JsonToken.StartObject);
            return true;
          case '[':
            _charPos++;
            SetToken(JsonToken.StartArray);
            return true;
          case ']':
            _charPos++;
            SetToken(JsonToken.EndArray);
            return true;
          case ',':
            // don't increment position, the next call to read will handle comma
            // this is done to handle multiple empty comma values
            SetToken(JsonToken.Undefined);
            return true;
          case ')':
            _charPos++;
            SetToken(JsonToken.EndConstructor);
            return true;
          case StringUtils.CarriageReturn:
            ProcessCarriageReturn(false);
            break;
          case StringUtils.LineFeed:
            ProcessLineFeed();
            break;
          case ' ':
          case StringUtils.Tab:
            // eat
            _charPos++;
            break;
          default:
            if (char.IsWhiteSpace(currentChar))
            {
              // eat
              _charPos++;
              break;
            }
            else if (char.IsNumber(currentChar) || currentChar == '-' || currentChar == '.')
            {
              ParseNumber();
              return true;
            }
            else
            {
              throw JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
            }
        }
      }
    }

    private void ProcessLineFeed()
    {
      _charPos++;
      OnNewLine(_charPos);
    }

    private void ProcessCarriageReturn(bool append)
    {
      _charPos++;

      if (EnsureChars(1, append) && _chars[_charPos] == StringUtils.LineFeed)
        _charPos++;

      OnNewLine(_charPos);
    }

    private bool EatWhitespace(bool oneOrMore)
    {
      bool finished = false;
      bool ateWhitespace = false;
      while (!finished)
      {
        char currentChar = _chars[_charPos];

        switch (currentChar)
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(false) == 0)
                finished = true;
            }
            else
            {
              _charPos++;
            }
            break;
          case StringUtils.CarriageReturn:
            ProcessCarriageReturn(false);
            break;
          case StringUtils.LineFeed:
            ProcessLineFeed();
            break;
          default:
            if (currentChar == ' ' || char.IsWhiteSpace(currentChar))
            {
              ateWhitespace = true;
              _charPos++;
            }
            else
            {
              finished = true;
            }
            break;
        }
      }

      return (!oneOrMore || ateWhitespace);
    }

    private void ParseConstructor()
    {
      if (MatchValueWithTrailingSeperator("new"))
      {
        EatWhitespace(false);

        int initialPosition = _charPos;
        int endPosition;

        while (true)
        {
          char currentChar = _chars[_charPos];
          if (currentChar == '\0')
          {
            if (_charsUsed == _charPos)
            {
              if (ReadData(true) == 0)
                throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
            }
            else
            {
              endPosition = _charPos;
              _charPos++;
              break;
            }
          }
          else if (char.IsLetterOrDigit(currentChar))
          {
            _charPos++;
          }
          else if (currentChar == StringUtils.CarriageReturn)
          {
            endPosition = _charPos;
            ProcessCarriageReturn(true);
            break;
          }
          else if (currentChar == StringUtils.LineFeed)
          {
            endPosition = _charPos;
            ProcessLineFeed();
            break;
          }
          else if (char.IsWhiteSpace(currentChar))
          {
            endPosition = _charPos;
            _charPos++;
            break;
          }
          else if (currentChar == '(')
          {
            endPosition = _charPos;
            break;
          }
          else
          {
            throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, currentChar));
          }
        }

        _stringReference = new StringReference(_chars, initialPosition, endPosition - initialPosition);
        string constructorName = _stringReference.ToString();

        EatWhitespace(false);

        if (_chars[_charPos] != '(')
          throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));

        _charPos++;

        ClearRecentString();

        SetToken(JsonToken.StartConstructor, constructorName);
      }
    }

    private void ParseNumber()
    {
      ShiftBufferIfNeeded();

      char firstChar = _chars[_charPos];
      int initialPosition = _charPos;

      ReadNumberIntoBuffer();

      _stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition);

      object numberValue;
      JsonToken numberType;

      bool singleDigit = (char.IsDigit(firstChar) && _stringReference.Length == 1);
      bool nonBase10 = (firstChar == '0' && _stringReference.Length > 1
        && _stringReference.Chars[_stringReference.StartIndex + 1] != '.'
        && _stringReference.Chars[_stringReference.StartIndex + 1] != 'e'
        && _stringReference.Chars[_stringReference.StartIndex + 1] != 'E');

      if (_readType == ReadType.ReadAsInt32)
      {
        if (singleDigit)
        {
          // digit char values start at 48
          numberValue = firstChar - 48;
        }
        else if (nonBase10)
        {
          string number = _stringReference.ToString();

          // decimal.Parse doesn't support parsing hexadecimal values
          int integer = number.StartsWith("0x", StringComparison.OrdinalIgnoreCase)
                           ? Convert.ToInt32(number, 16)
                           : Convert.ToInt32(number, 8);

          numberValue = integer;
        }
        else
        {
          string number = _stringReference.ToString();

          numberValue = Convert.ToInt32(number, CultureInfo.InvariantCulture);
        }

        numberType = JsonToken.Integer;
      }
      else if (_readType == ReadType.ReadAsDecimal)
      {
        if (singleDigit)
        {
          // digit char values start at 48
          numberValue = (decimal)firstChar - 48;
        }
        else if (nonBase10)
        {
          string number = _stringReference.ToString();

          // decimal.Parse doesn't support parsing hexadecimal values
          long integer = number.StartsWith("0x", StringComparison.OrdinalIgnoreCase)
                           ? Convert.ToInt64(number, 16)
                           : Convert.ToInt64(number, 8);

          numberValue = Convert.ToDecimal(integer);
        }
        else
        {
          string number = _stringReference.ToString();

          numberValue = decimal.Parse(number, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture);
        }

        numberType = JsonToken.Float;
      }
      else
      {
        if (singleDigit)
        {
          // digit char values start at 48
          numberValue = (long)firstChar - 48;
          numberType = JsonToken.Integer;
        }
        else if (nonBase10)
        {
          string number = _stringReference.ToString();

          numberValue = number.StartsWith("0x", StringComparison.OrdinalIgnoreCase)
                          ? Convert.ToInt64(number, 16)
                          : Convert.ToInt64(number, 8);
          numberType = JsonToken.Integer;
        }
        else
        {
          string number = _stringReference.ToString();

          // it's faster to do 3 indexof with single characters than an indexofany
          if (number.IndexOf('.') != -1 || number.IndexOf('E') != -1 || number.IndexOf('e') != -1)
          {
            numberValue = Convert.ToDouble(number, CultureInfo.InvariantCulture);
            numberType = JsonToken.Float;
          }
          else
          {
            try
            {
              numberValue = Convert.ToInt64(number, CultureInfo.InvariantCulture);
            }
            catch (OverflowException ex)
            {
              throw JsonReaderException.Create((JsonReader)this, "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture, number), ex);
            }

            numberType = JsonToken.Integer;
          }
        }
      }

      ClearRecentString();

      SetToken(numberType, numberValue);
    }

    private void ParseComment()
    {
      // should have already parsed / character before reaching this method
      _charPos++;

      if (!EnsureChars(1, false) || _chars[_charPos] != '*')
        throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
      else
        _charPos++;

      int initialPosition = _charPos;

      bool commentFinished = false;

      while (!commentFinished)
      {
        switch (_chars[_charPos])
        {
          case '\0':
            if (_charsUsed == _charPos)
            {
              if (ReadData(true) == 0)
                throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
            }
            else
            {
              _charPos++;
            }
            break;
          case '*':
            _charPos++;

            if (EnsureChars(0, true))
            {
              if (_chars[_charPos] == '/')
              {
                _stringReference = new StringReference(_chars, initialPosition, _charPos - initialPosition - 1);

                _charPos++;
                commentFinished = true;
              }
            }
            break;
          case StringUtils.CarriageReturn:
            ProcessCarriageReturn(true);
            break;
          case StringUtils.LineFeed:
            ProcessLineFeed();
            break;
          default:
            _charPos++;
            break;
        }
      }

      SetToken(JsonToken.Comment, _stringReference.ToString());

      ClearRecentString();
    }

    private bool MatchValue(string value)
    {
      if (!EnsureChars(value.Length - 1, true))
        return false;

      for (int i = 0; i < value.Length; i++)
      {
        if (_chars[_charPos + i] != value[i])
        {
          return false;
        }
      }

      _charPos += value.Length;

      return true;
    }

    private bool MatchValueWithTrailingSeperator(string value)
    {
      // will match value and then move to the next character, checking that it is a seperator character
      bool match = MatchValue(value);

      if (!match)
        return false;

      if (!EnsureChars(0, false))
        return true;

      return IsSeperator(_chars[_charPos]) || _chars[_charPos] == '\0';
    }

    private bool IsSeperator(char c)
    {
      switch (c)
      {
        case '}':
        case ']':
        case ',':
          return true;
        case '/':
          // check next character to see if start of a comment
          if (!EnsureChars(1, false))
            return false;

          return (_chars[_charPos + 1] == '*');
        case ')':
          if (CurrentState == State.Constructor || CurrentState == State.ConstructorStart)
            return true;
          break;
        case ' ':
        case StringUtils.Tab:
        case StringUtils.LineFeed:
        case StringUtils.CarriageReturn:
          return true;
        default:
          if (char.IsWhiteSpace(c))
            return true;
          break;
      }

      return false;
    }

    private void ParseTrue()
    {
      // check characters equal 'true'
      // and that it is followed by either a seperator character
      // or the text ends
      if (MatchValueWithTrailingSeperator(JsonConvert.True))
      {
        SetToken(JsonToken.Boolean, true);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing boolean value.");
      }
    }

    private void ParseNull()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.Null))
      {
        SetToken(JsonToken.Null);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing null value.");
      }
    }

    private void ParseUndefined()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.Undefined))
      {
        SetToken(JsonToken.Undefined);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing undefined value.");
      }
    }

    private void ParseFalse()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.False))
      {
        SetToken(JsonToken.Boolean, false);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing boolean value.");
      }
    }

    private void ParseNumberNegativeInfinity()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.NegativeInfinity))
      {
        SetToken(JsonToken.Float, double.NegativeInfinity);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing negative infinity value.");
      }
    }

    private void ParseNumberPositiveInfinity()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.PositiveInfinity))
      {
        SetToken(JsonToken.Float, double.PositiveInfinity);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing positive infinity value.");
      }
    }

    private void ParseNumberNaN()
    {
      if (MatchValueWithTrailingSeperator(JsonConvert.NaN))
      {
        SetToken(JsonToken.Float, double.NaN);
      }
      else
      {
        throw JsonReaderException.Create(this, "Error parsing NaN value.");
      }
    }

    /// <summary>
    /// Changes the state to closed. 
    /// </summary>
    public override void Close()
    {
      base.Close();

      if (CloseInput && _reader != null)
#if !(NETFX_CORE || PORTABLE)
        _reader.Close();
#else
        _reader.Dispose();
#endif

      if (_buffer != null)
        _buffer.Clear();
    }

    /// <summary>
    /// Gets a value indicating whether the class can return line information.
    /// </summary>
    /// <returns>
    /// 	<c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
    /// </returns>
    public bool HasLineInfo()
    {
      return true;
    }

    /// <summary>
    /// Gets the current line number.
    /// </summary>
    /// <value>
    /// The current line number or 0 if no line information is available (for example, HasLineInfo returns false).
    /// </value>
    public int LineNumber
    {
      get
      {
        if (CurrentState == State.Start && LinePosition == 0)
          return 0;

        return _lineNumber;
      }
    }

    /// <summary>
    /// Gets the current line position.
    /// </summary>
    /// <value>
    /// The current line position or 0 if no line information is available (for example, HasLineInfo returns false).
    /// </value>
    public int LinePosition
    {
      get { return _charPos - _lineStartPos; }
    }
  }
}
#endregion JsonTextReader.cs

/// ********   File: \JsonTextWriter.cs
#region JsonTextWriter.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
  /// </summary>
  public class JsonTextWriter : JsonWriter
  {
    private readonly TextWriter _writer;
    private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;

    private Base64Encoder Base64Encoder
    {
      get
      {
        if (_base64Encoder == null)
          _base64Encoder = new Base64Encoder(_writer);

        return _base64Encoder;
      }
    }

    /// <summary>
    /// Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="Formatting"/> is set to <c>Formatting.Indented</c>.
    /// </summary>
    public int Indentation
    {
      get { return _indentation; }
      set
      {
        if (value < 0)
          throw new ArgumentException("Indentation value must be greater than 0.");

        _indentation = value;
      }
    }

    /// <summary>
    /// Gets or sets which character to use to quote attribute values.
    /// </summary>
    public char QuoteChar
    {
      get { return _quoteChar; }
      set
      {
        if (value != '"' && value != '\'')
          throw new ArgumentException(@"Invalid JavaScript string quote character. Valid quote characters are ' and "".");

        _quoteChar = value;
      }
    }

    /// <summary>
    /// Gets or sets which character to use for indenting when <see cref="Formatting"/> is set to <c>Formatting.Indented</c>.
    /// </summary>
    public char IndentChar
    {
      get { return _indentChar; }
      set { _indentChar = value; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether object names will be surrounded with quotes.
    /// </summary>
    public bool QuoteName
    {
      get { return _quoteName; }
      set { _quoteName = value; }
    }

    /// <summary>
    /// Creates an instance of the <c>JsonWriter</c> class using the specified <see cref="TextWriter"/>. 
    /// </summary>
    /// <param name="textWriter">The <c>TextWriter</c> to write to.</param>
    public JsonTextWriter(TextWriter textWriter)
    {
      if (textWriter == null)
        throw new ArgumentNullException("textWriter");

      _writer = textWriter;
      _quoteChar = '"';
      _quoteName = true;
      _indentChar = ' ';
      _indentation = 2;
    }

    /// <summary>
    /// Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
    /// </summary>
    public override void Flush()
    {
      _writer.Flush();
    }

    /// <summary>
    /// Closes this stream and the underlying stream.
    /// </summary>
    public override void Close()
    {
      base.Close();

      if (CloseOutput && _writer != null)
#if !(NETFX_CORE || PORTABLE)
        _writer.Close();
#else
        _writer.Dispose();
#endif
    }

    /// <summary>
    /// Writes the beginning of a Json object.
    /// </summary>
    public override void WriteStartObject()
    {
      InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);

      _writer.Write("{");
    }

    /// <summary>
    /// Writes the beginning of a Json array.
    /// </summary>
    public override void WriteStartArray()
    {
      InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);

      _writer.Write("[");
    }

    /// <summary>
    /// Writes the start of a constructor with the given name.
    /// </summary>
    /// <param name="name">The name of the constructor.</param>
    public override void WriteStartConstructor(string name)
    {
      InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);

      _writer.Write("new ");
      _writer.Write(name);
      _writer.Write("(");
    }

    /// <summary>
    /// Writes the specified end token.
    /// </summary>
    /// <param name="token">The end token to write.</param>
    protected override void WriteEnd(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.EndObject:
          _writer.Write("}");
          break;
        case JsonToken.EndArray:
          _writer.Write("]");
          break;
        case JsonToken.EndConstructor:
          _writer.Write(")");
          break;
        default:
          throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null);
      }
    }

    /// <summary>
    /// Writes the property name of a name/value pair on a Json object.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    public override void WritePropertyName(string name)
    {
      InternalWritePropertyName(name);

      JavaScriptUtils.WriteEscapedJavaScriptString(_writer, name, _quoteChar, _quoteName, GetCharEscapeFlags(), StringEscapeHandling);

      _writer.Write(':');
    }

    private bool[] GetCharEscapeFlags()
    {
      if (StringEscapeHandling == StringEscapeHandling.EscapeHtml)
        return JavaScriptUtils.HtmlCharEscapeFlags;

      if (_quoteChar == '"')
        return JavaScriptUtils.DoubleQuoteCharEscapeFlags;
      
      return JavaScriptUtils.SingleQuoteCharEscapeFlags;
    }

    /// <summary>
    /// Writes indent characters.
    /// </summary>
    protected override void WriteIndent()
    {
      _writer.Write(Environment.NewLine);

      // levels of indentation multiplied by the indent count
      int currentIndentCount = Top*_indentation;

      while (currentIndentCount > 0)
      {
        // write up to a max of 10 characters at once to avoid creating too many new strings
        int writeCount = Math.Min(currentIndentCount, 10);

        _writer.Write(new string(_indentChar, writeCount));

        currentIndentCount -= writeCount;
      }
    }

    /// <summary>
    /// Writes the JSON value delimiter.
    /// </summary>
    protected override void WriteValueDelimiter()
    {
      _writer.Write(',');
    }

    /// <summary>
    /// Writes an indent space.
    /// </summary>
    protected override void WriteIndentSpace()
    {
      _writer.Write(' ');
    }

    private void WriteValueInternal(string value, JsonToken token)
    {
      _writer.Write(value);
    }

    #region WriteValue methods
    /// <summary>
    /// Writes a null value.
    /// </summary>
    public override void WriteNull()
    {
      InternalWriteNull();
      WriteValueInternal(JsonConvert.Null, JsonToken.Null);
    }

    /// <summary>
    /// Writes an undefined value.
    /// </summary>
    public override void WriteUndefined()
    {
      InternalWriteUndefined();
      WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
    }

    /// <summary>
    /// Writes raw JSON.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public override void WriteRaw(string json)
    {
      InternalWriteRaw();

      _writer.Write(json);
    }

    /// <summary>
    /// Writes a <see cref="String"/> value.
    /// </summary>
    /// <param name="value">The <see cref="String"/> value to write.</param>
    public override void WriteValue(string value)
    {
      InternalWriteValue(JsonToken.String);

      if (value == null)
        WriteValueInternal(JsonConvert.Null, JsonToken.Null);
      else
        JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, true, GetCharEscapeFlags(), StringEscapeHandling);
    }

    /// <summary>
    /// Writes a <see cref="Int32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int32"/> value to write.</param>
    public override void WriteValue(int value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt32"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(uint value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Int64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int64"/> value to write.</param>
    public override void WriteValue(long value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt64"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ulong value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Single"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Single"/> value to write.</param>
    public override void WriteValue(float value)
    {
      InternalWriteValue(JsonToken.Float);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Double"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Double"/> value to write.</param>
    public override void WriteValue(double value)
    {
      InternalWriteValue(JsonToken.Float);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Boolean"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Boolean"/> value to write.</param>
    public override void WriteValue(bool value)
    {
      InternalWriteValue(JsonToken.Boolean);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
    }

    /// <summary>
    /// Writes a <see cref="Int16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int16"/> value to write.</param>
    public override void WriteValue(short value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt16"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(ushort value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Char"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Char"/> value to write.</param>
    public override void WriteValue(char value)
    {
      InternalWriteValue(JsonToken.String);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Byte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Byte"/> value to write.</param>
    public override void WriteValue(byte value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="SByte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="SByte"/> value to write.</param>
    [CLSCompliant(false)]
    public override void WriteValue(sbyte value)
    {
      InternalWriteValue(JsonToken.Integer);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Decimal"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Decimal"/> value to write.</param>
    public override void WriteValue(decimal value)
    {
      InternalWriteValue(JsonToken.Float);
      WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="DateTime"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to write.</param>
    public override void WriteValue(DateTime value)
    {
      InternalWriteValue(JsonToken.Date);
      value = JsonConvert.EnsureDateTime(value, DateTimeZoneHandling);
      JsonConvert.WriteDateTimeString(_writer, value, DateFormatHandling, _quoteChar);
    }

    /// <summary>
    /// Writes a <see cref="T:Byte[]"/> value.
    /// </summary>
    /// <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
    public override void WriteValue(byte[] value)
    {
      if (value == null)
      {
        WriteNull();
      }
      else
      {
        InternalWriteValue(JsonToken.Bytes);
        _writer.Write(_quoteChar);
        Base64Encoder.Encode(value, 0, value.Length);
        Base64Encoder.Flush();
        _writer.Write(_quoteChar);
      }
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Writes a <see cref="DateTimeOffset"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to write.</param>
    public override void WriteValue(DateTimeOffset value)
    {
      InternalWriteValue(JsonToken.Date);
      WriteValueInternal(JsonConvert.ToString(value, DateFormatHandling, _quoteChar), JsonToken.Date);
    }
#endif

    /// <summary>
    /// Writes a <see cref="Guid"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to write.</param>
    public override void WriteValue(Guid value)
    {
      InternalWriteValue(JsonToken.String);
      WriteValueInternal(JsonConvert.ToString(value, _quoteChar), JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="TimeSpan"/> value.
    /// </summary>
    /// <param name="value">The <see cref="TimeSpan"/> value to write.</param>
    public override void WriteValue(TimeSpan value)
    {
      InternalWriteValue(JsonToken.String);
      WriteValueInternal(JsonConvert.ToString(value, _quoteChar), JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Uri"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Uri"/> value to write.</param>
    public override void WriteValue(Uri value)
    {
      if (value == null)
      {
        WriteNull();
      }
      else
      {
        InternalWriteValue(JsonToken.String);
        WriteValueInternal(JsonConvert.ToString(value, _quoteChar), JsonToken.String);
      }
    }
    #endregion

    /// <summary>
    /// Writes out a comment <code>/*...*/</code> containing the specified text. 
    /// </summary>
    /// <param name="text">Text to place inside the comment.</param>
    public override void WriteComment(string text)
    {
      InternalWriteComment();

      _writer.Write("/*");
      _writer.Write(text);
      _writer.Write("*/");
    }

    /// <summary>
    /// Writes out the given white space.
    /// </summary>
    /// <param name="ws">The string of white space characters.</param>
    public override void WriteWhitespace(string ws)
    {
      InternalWriteWhitespace(ws);

      _writer.Write(ws);
    }
  }
}
#endregion JsonTextWriter.cs

/// ********   File: \JsonToken.cs
#region JsonToken.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies the type of Json token.
  /// </summary>
  public enum JsonToken
  {
    /// <summary>
    /// This is returned by the <see cref="JsonReader"/> if a <see cref="JsonReader.Read"/> method has not been called. 
    /// </summary>
    None,
    /// <summary>
    /// An object start token.
    /// </summary>
    StartObject,
    /// <summary>
    /// An array start token.
    /// </summary>
    StartArray,
    /// <summary>
    /// A constructor start token.
    /// </summary>
    StartConstructor,
    /// <summary>
    /// An object property name.
    /// </summary>
    PropertyName,
    /// <summary>
    /// A comment.
    /// </summary>
    Comment,
    /// <summary>
    /// Raw JSON.
    /// </summary>
    Raw,
    /// <summary>
    /// An integer.
    /// </summary>
    Integer,
    /// <summary>
    /// A float.
    /// </summary>
    Float,
    /// <summary>
    /// A string.
    /// </summary>
    String,
    /// <summary>
    /// A boolean.
    /// </summary>
    Boolean,
    /// <summary>
    /// A null token.
    /// </summary>
    Null,
    /// <summary>
    /// An undefined token.
    /// </summary>
    Undefined,
    /// <summary>
    /// An object end token.
    /// </summary>
    EndObject,
    /// <summary>
    /// An array end token.
    /// </summary>
    EndArray,
    /// <summary>
    /// A constructor end token.
    /// </summary>
    EndConstructor,
    /// <summary>
    /// A Date.
    /// </summary>
    Date,
    /// <summary>
    /// Byte data.
    /// </summary>
    Bytes
  }
}
#endregion JsonToken.cs

/// ********   File: \JsonValidatingReader.cs
#region JsonValidatingReader.cs

#if NET20
#else
#endif

namespace Newtonsoft.Json
{
  /// <summary>
  /// Represents a reader that provides <see cref="JsonSchema"/> validation.
  /// </summary>
  public class JsonValidatingReader : JsonReader, IJsonLineInfo
  {
    private class SchemaScope
    {
      private readonly JTokenType _tokenType;
      private readonly IList<JsonSchemaModel> _schemas;
      private readonly Dictionary<string, bool> _requiredProperties;

      public string CurrentPropertyName { get; set; }
      public int ArrayItemCount { get; set; }

      public IList<JsonSchemaModel> Schemas
      {
        get { return _schemas; }
      }

      public Dictionary<string, bool> RequiredProperties
      {
        get { return _requiredProperties; }
      }

      public JTokenType TokenType
      {
        get { return _tokenType; }
      }

      public SchemaScope(JTokenType tokenType, IList<JsonSchemaModel> schemas)
      {
        _tokenType = tokenType;
        _schemas = schemas;

        _requiredProperties = schemas.SelectMany<JsonSchemaModel, string>(GetRequiredProperties).Distinct().ToDictionary(p => p, p => false);
      }

      private IEnumerable<string> GetRequiredProperties(JsonSchemaModel schema)
      {
        if (schema == null || schema.Properties == null)
          return Enumerable.Empty<string>();

        return schema.Properties.Where(p => p.Value.Required).Select(p => p.Key);
      }
    }

    private readonly JsonReader _reader;
    private readonly Stack<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;

    /// <summary>
    /// Sets an event handler for receiving schema validation errors.
    /// </summary>
    public event ValidationEventHandler ValidationEventHandler;

    /// <summary>
    /// Gets the text value of the current Json token.
    /// </summary>
    /// <value></value>
    public override object Value
    {
      get { return _reader.Value; }
    }

    /// <summary>
    /// Gets the depth of the current token in the JSON document.
    /// </summary>
    /// <value>The depth of the current token in the JSON document.</value>
    public override int Depth
    {
      get { return _reader.Depth; }
    }

    /// <summary>
    /// Gets the path of the current JSON token. 
    /// </summary>
    public override string Path
    {
      get { return _reader.Path; }
    }

    /// <summary>
    /// Gets the quotation mark character used to enclose the value of a string.
    /// </summary>
    /// <value></value>
    public override char QuoteChar
    {
      get { return _reader.QuoteChar; }
      protected internal set { }
    }

    /// <summary>
    /// Gets the type of the current Json token.
    /// </summary>
    /// <value></value>
    public override JsonToken TokenType
    {
      get { return _reader.TokenType; }
    }

    /// <summary>
    /// Gets the Common Language Runtime (CLR) type for the current Json token.
    /// </summary>
    /// <value></value>
    public override Type ValueType
    {
      get { return _reader.ValueType; }
    }

    private void Push(SchemaScope scope)
    {
      _stack.Push(scope);
      _currentScope = scope;
    }

    private SchemaScope Pop()
    {
      SchemaScope poppedScope = _stack.Pop();
      _currentScope = (_stack.Count != 0)
        ? _stack.Peek()
        : null;

      return poppedScope;
    }

    private IEnumerable<JsonSchemaModel> CurrentSchemas
    {
      get { return _currentScope.Schemas; }
    }

    private IEnumerable<JsonSchemaModel> CurrentMemberSchemas
    {
      get
      {
        if (_currentScope == null)
          return new List<JsonSchemaModel>(new [] { _model });

        if (_currentScope.Schemas == null || _currentScope.Schemas.Count == 0)
          return Enumerable.Empty<JsonSchemaModel>();

        switch (_currentScope.TokenType)
        {
          case JTokenType.None:
            return _currentScope.Schemas;
          case JTokenType.Object:
            {
              if (_currentScope.CurrentPropertyName == null)
                throw new JsonReaderException("CurrentPropertyName has not been set on scope.");

              IList<JsonSchemaModel> schemas = new List<JsonSchemaModel>();

              foreach (JsonSchemaModel schema in CurrentSchemas)
              {
                JsonSchemaModel propertySchema;
                if (schema.Properties != null && schema.Properties.TryGetValue(_currentScope.CurrentPropertyName, out propertySchema))
                {
                  schemas.Add(propertySchema);
                }
                if (schema.PatternProperties != null)
                {
                  foreach (KeyValuePair<string, JsonSchemaModel> patternProperty in schema.PatternProperties)
                  {
                    if (Regex.IsMatch(_currentScope.CurrentPropertyName, patternProperty.Key))
                    {
                      schemas.Add(patternProperty.Value);
                    }
                  }
                }

                if (schemas.Count == 0 && schema.AllowAdditionalProperties && schema.AdditionalProperties != null)
                  schemas.Add(schema.AdditionalProperties);
              }

              return schemas;
            }
          case JTokenType.Array:
            {
              IList<JsonSchemaModel> schemas = new List<JsonSchemaModel>();
              
              foreach (JsonSchemaModel schema in CurrentSchemas)
              {
                if (!CollectionUtils.IsNullOrEmpty(schema.Items))
                {
                  if (schema.Items.Count == 1)
                  {
                    schemas.Add(schema.Items[0]);
                  }
                  else
                  {
                    if (schema.Items.Count > (_currentScope.ArrayItemCount - 1))
                      schemas.Add(schema.Items[_currentScope.ArrayItemCount - 1]);
                  }
                }

                if (schema.AllowAdditionalProperties && schema.AdditionalProperties != null)
                  schemas.Add(schema.AdditionalProperties);
              }

              return schemas;
            }
          case JTokenType.Constructor:
            return Enumerable.Empty<JsonSchemaModel>();
          default:
            throw new ArgumentOutOfRangeException("TokenType", "Unexpected token type: {0}".FormatWith(CultureInfo.InvariantCulture, _currentScope.TokenType));
        }
      }
    }

    private void RaiseError(string message, JsonSchemaModel schema)
    {
      IJsonLineInfo lineInfo = this;

      string exceptionMessage = (lineInfo.HasLineInfo())
                                  ? message + " Line {0}, position {1}.".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition)
                                  : message;

      OnValidationEvent(new JsonSchemaException(exceptionMessage, null, Path, lineInfo.LineNumber, lineInfo.LinePosition));
    }

    private void OnValidationEvent(JsonSchemaException exception)
    {
      ValidationEventHandler handler = ValidationEventHandler;
      if (handler != null)
        handler(this, new ValidationEventArgs(exception));
      else
        throw exception;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonValidatingReader"/> class that
    /// validates the content returned from the given <see cref="JsonReader"/>.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read from while validating.</param>
    public JsonValidatingReader(JsonReader reader)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");
      _reader = reader;
      _stack = new Stack<SchemaScope>();
    }

    /// <summary>
    /// Gets or sets the schema.
    /// </summary>
    /// <value>The schema.</value>
    public JsonSchema Schema
    {
      get { return _schema; }
      set
      {
        if (TokenType != JsonToken.None)
          throw new InvalidOperationException("Cannot change schema while validating JSON.");

        _schema = value;
        _model = null;
      }
    }

    /// <summary>
    /// Gets the <see cref="JsonReader"/> used to construct this <see cref="JsonValidatingReader"/>.
    /// </summary>
    /// <value>The <see cref="JsonReader"/> specified in the constructor.</value>
    public JsonReader Reader
    {
      get { return _reader; }
    }

    private void ValidateInEnumAndNotDisallowed(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      JToken value = new JValue(_reader.Value);

      if (schema.Enum != null)
      {
        StringWriter sw = new StringWriter(CultureInfo.InvariantCulture);
        value.WriteTo(new JsonTextWriter(sw));
 
        if (!schema.Enum.ContainsValue(value, new JTokenEqualityComparer()))
          RaiseError("Value {0} is not defined in enum.".FormatWith(CultureInfo.InvariantCulture, sw.ToString()),
                     schema);
      }

      JsonSchemaType? currentNodeType = GetCurrentNodeSchemaType();
      if (currentNodeType != null)
      {
        if (JsonSchemaGenerator.HasFlag(schema.Disallow, currentNodeType.Value))
          RaiseError("Type {0} is disallowed.".FormatWith(CultureInfo.InvariantCulture, currentNodeType), schema);
      }
    }

    private JsonSchemaType? GetCurrentNodeSchemaType()
    {
      switch (_reader.TokenType)
      {
        case JsonToken.StartObject:
          return JsonSchemaType.Object;
        case JsonToken.StartArray:
          return JsonSchemaType.Array;
        case JsonToken.Integer:
          return JsonSchemaType.Integer;
        case JsonToken.Float:
          return JsonSchemaType.Float;
        case JsonToken.String:
          return JsonSchemaType.String;
        case JsonToken.Boolean:
          return JsonSchemaType.Boolean;
        case JsonToken.Null:
          return JsonSchemaType.Null;
        default:
          return null;
      }
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Int32}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Int32}"/>.</returns>
    public override int? ReadAsInt32()
    {
      int? i = _reader.ReadAsInt32();

      ValidateCurrentToken();
      return i;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="T:Byte[]"/>.
    /// </summary>
    /// <returns>
    /// A <see cref="T:Byte[]"/> or a null reference if the next JSON token is null.
    /// </returns>
    public override byte[] ReadAsBytes()
    {
      byte[] data = _reader.ReadAsBytes();

      ValidateCurrentToken();
      return data;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{Decimal}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{Decimal}"/>.</returns>
    public override decimal? ReadAsDecimal()
    {
      decimal? d = _reader.ReadAsDecimal();

      ValidateCurrentToken();
      return d;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="String"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override string ReadAsString()
    {
      string s = _reader.ReadAsString();

      ValidateCurrentToken();
      return s;
    }

    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTime}"/>.
    /// </summary>
    /// <returns>A <see cref="String"/>. This method will return <c>null</c> at the end of an array.</returns>
    public override DateTime? ReadAsDateTime()
    {
      DateTime? dateTime = _reader.ReadAsDateTime();

      ValidateCurrentToken();
      return dateTime;
    }

#if !NET20
    /// <summary>
    /// Reads the next JSON token from the stream as a <see cref="Nullable{DateTimeOffset}"/>.
    /// </summary>
    /// <returns>A <see cref="Nullable{DateTimeOffset}"/>.</returns>
    public override DateTimeOffset? ReadAsDateTimeOffset()
    {
      DateTimeOffset? dateTimeOffset = _reader.ReadAsDateTimeOffset();

      ValidateCurrentToken();
      return dateTimeOffset;
    }
#endif

    /// <summary>
    /// Reads the next JSON token from the stream.
    /// </summary>
    /// <returns>
    /// true if the next token was read successfully; false if there are no more tokens to read.
    /// </returns>
    public override bool Read()
    {
      if (!_reader.Read())
        return false;

      if (_reader.TokenType == JsonToken.Comment)
        return true;

      ValidateCurrentToken();
      return true;
    }

    private void ValidateCurrentToken()
    {
      // first time validate has been called. build model
      if (_model == null)
      {
        JsonSchemaModelBuilder builder = new JsonSchemaModelBuilder();
        _model = builder.Build(_schema);
      }

      switch (_reader.TokenType)
      {
        case JsonToken.StartObject:
          ProcessValue();
          IList<JsonSchemaModel> objectSchemas = CurrentMemberSchemas.Where(ValidateObject).ToList();
          Push(new SchemaScope(JTokenType.Object, objectSchemas));
          break;
        case JsonToken.StartArray:
          ProcessValue();
          IList<JsonSchemaModel> arraySchemas = CurrentMemberSchemas.Where(ValidateArray).ToList();
          Push(new SchemaScope(JTokenType.Array, arraySchemas));
          break;
        case JsonToken.StartConstructor:
          Push(new SchemaScope(JTokenType.Constructor, null));
          break;
        case JsonToken.PropertyName:
          foreach (JsonSchemaModel schema in CurrentSchemas)
          {
            ValidatePropertyName(schema);
          }
          break;
        case JsonToken.Raw:
          break;
        case JsonToken.Integer:
          ProcessValue();
          foreach (JsonSchemaModel schema in CurrentMemberSchemas)
          {
            ValidateInteger(schema);
          }
          break;
        case JsonToken.Float:
          ProcessValue();
          foreach (JsonSchemaModel schema in CurrentMemberSchemas)
          {
            ValidateFloat(schema);
          }
          break;
        case JsonToken.String:
          ProcessValue();
          foreach (JsonSchemaModel schema in CurrentMemberSchemas)
          {
            ValidateString(schema);
          }
          break;
        case JsonToken.Boolean:
          ProcessValue();
          foreach (JsonSchemaModel schema in CurrentMemberSchemas)
          {
            ValidateBoolean(schema);
          }
          break;
        case JsonToken.Null:
          ProcessValue();
          foreach (JsonSchemaModel schema in CurrentMemberSchemas)
          {
            ValidateNull(schema);
          }
          break;
        case JsonToken.Undefined:
          break;
        case JsonToken.EndObject:
          foreach (JsonSchemaModel schema in CurrentSchemas)
          {
            ValidateEndObject(schema);
          }
          Pop();
          break;
        case JsonToken.EndArray:
          foreach (JsonSchemaModel schema in CurrentSchemas)
          {
            ValidateEndArray(schema);
          }
          Pop();
          break;
        case JsonToken.EndConstructor:
          Pop();
          break;
        case JsonToken.Date:
        case JsonToken.Bytes:
          // these have no equivalent in JSON schema
          break;
        case JsonToken.None:
          // no content, do nothing
          break;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    private void ValidateEndObject(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      Dictionary<string, bool> requiredProperties = _currentScope.RequiredProperties;

      if (requiredProperties != null)
      {
        List<string> unmatchedRequiredProperties =
          requiredProperties.Where(kv => !kv.Value).Select(kv => kv.Key).ToList();

        if (unmatchedRequiredProperties.Count > 0)
          RaiseError("Required properties are missing from object: {0}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", unmatchedRequiredProperties.ToArray())), schema);
      }
    }

    private void ValidateEndArray(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      int arrayItemCount = _currentScope.ArrayItemCount;

      if (schema.MaximumItems != null && arrayItemCount > schema.MaximumItems)
        RaiseError("Array item count {0} exceeds maximum count of {1}.".FormatWith(CultureInfo.InvariantCulture, arrayItemCount, schema.MaximumItems), schema);

      if (schema.MinimumItems != null && arrayItemCount < schema.MinimumItems)
        RaiseError("Array item count {0} is less than minimum count of {1}.".FormatWith(CultureInfo.InvariantCulture, arrayItemCount, schema.MinimumItems), schema);
    }

    private void ValidateNull(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      if (!TestType(schema, JsonSchemaType.Null))
        return;

      ValidateInEnumAndNotDisallowed(schema);
    }

    private void ValidateBoolean(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      if (!TestType(schema, JsonSchemaType.Boolean))
        return;

      ValidateInEnumAndNotDisallowed(schema);
    }

    private void ValidateString(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      if (!TestType(schema, JsonSchemaType.String))
        return;

      ValidateInEnumAndNotDisallowed(schema);

      string value = _reader.Value.ToString();

      if (schema.MaximumLength != null && value.Length > schema.MaximumLength)
        RaiseError("String '{0}' exceeds maximum length of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.MaximumLength), schema);

      if (schema.MinimumLength != null && value.Length < schema.MinimumLength)
        RaiseError("String '{0}' is less than minimum length of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.MinimumLength), schema);

      if (schema.Patterns != null)
      {
        foreach (string pattern in schema.Patterns)
        {
          if (!Regex.IsMatch(value, pattern))
            RaiseError("String '{0}' does not match regex pattern '{1}'.".FormatWith(CultureInfo.InvariantCulture, value, pattern), schema);
        }
      }
    }

    private void ValidateInteger(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      if (!TestType(schema, JsonSchemaType.Integer))
        return;

      ValidateInEnumAndNotDisallowed(schema);
      
      long value = Convert.ToInt64(_reader.Value, CultureInfo.InvariantCulture);

      if (schema.Maximum != null)
      {
        if (value > schema.Maximum)
          RaiseError("Integer {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.Maximum), schema);
        if (schema.ExclusiveMaximum && value == schema.Maximum)
          RaiseError("Integer {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture, value, schema.Maximum), schema);
      }

      if (schema.Minimum != null)
      {
        if (value < schema.Minimum)
          RaiseError("Integer {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture, value, schema.Minimum), schema);
        if (schema.ExclusiveMinimum && value == schema.Minimum)
          RaiseError("Integer {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture, value, schema.Minimum), schema);
      }

      if (schema.DivisibleBy != null && !IsZero(value % schema.DivisibleBy.Value))
        RaiseError("Integer {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.DivisibleBy), schema);
    }

    private void ProcessValue()
    {
      if (_currentScope != null && _currentScope.TokenType == JTokenType.Array)
      {
        _currentScope.ArrayItemCount++;

        foreach (JsonSchemaModel currentSchema in CurrentSchemas)
        {
          if (currentSchema != null && currentSchema.Items != null && currentSchema.Items.Count > 1 && _currentScope.ArrayItemCount >= currentSchema.Items.Count)
            RaiseError("Index {0} has not been defined and the schema does not allow additional items.".FormatWith(CultureInfo.InvariantCulture, _currentScope.ArrayItemCount), currentSchema);
        }
      }
    }

    private void ValidateFloat(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      if (!TestType(schema, JsonSchemaType.Float))
        return;

      ValidateInEnumAndNotDisallowed(schema);
      
      double value = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);

      if (schema.Maximum != null)
      {
        if (value > schema.Maximum)
          RaiseError("Float {0} exceeds maximum value of {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.Maximum), schema);
        if (schema.ExclusiveMaximum && value == schema.Maximum)
          RaiseError("Float {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.Maximum), schema);
      }

      if (schema.Minimum != null)
      {
        if (value < schema.Minimum)
          RaiseError("Float {0} is less than minimum value of {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.Minimum), schema);
        if (schema.ExclusiveMinimum && value == schema.Minimum)
          RaiseError("Float {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.Minimum), schema);
      }

      if (schema.DivisibleBy != null && !IsZero(value % schema.DivisibleBy.Value))
        RaiseError("Float {0} is not evenly divisible by {1}.".FormatWith(CultureInfo.InvariantCulture, JsonConvert.ToString(value), schema.DivisibleBy), schema);
    }

    private static bool IsZero(double value)
    {
      const double epsilon = 2.2204460492503131e-016;

      return Math.Abs(value) < 10.0 * epsilon;
    }

    private void ValidatePropertyName(JsonSchemaModel schema)
    {
      if (schema == null)
        return;

      string propertyName = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);

      if (_currentScope.RequiredProperties.ContainsKey(propertyName))
        _currentScope.RequiredProperties[propertyName] = true;

      if (!schema.AllowAdditionalProperties)
      {
        bool propertyDefinied = IsPropertyDefinied(schema, propertyName);

        if (!propertyDefinied)
          RaiseError("Property '{0}' has not been defined and the schema does not allow additional properties.".FormatWith(CultureInfo.InvariantCulture, propertyName), schema);
      }

      _currentScope.CurrentPropertyName = propertyName;
    }

    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName)
    {
      if (schema.Properties != null && schema.Properties.ContainsKey(propertyName))
        return true;

      if (schema.PatternProperties != null)
      {
        foreach (string pattern in schema.PatternProperties.Keys)
        {
          if (Regex.IsMatch(propertyName, pattern))
            return true;
        }
      }

      return false;
    }

    private bool ValidateArray(JsonSchemaModel schema)
    {
      if (schema == null)
        return true;

      return (TestType(schema, JsonSchemaType.Array));
    }

    private bool ValidateObject(JsonSchemaModel schema)
    {
      if (schema == null)
        return true;

      return (TestType(schema, JsonSchemaType.Object));
    }

    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType)
    {
      if (!JsonSchemaGenerator.HasFlag(currentSchema.Type, currentType))
      {
        RaiseError("Invalid type. Expected {0} but got {1}.".FormatWith(CultureInfo.InvariantCulture, currentSchema.Type, currentType), currentSchema);
        return false;
      }

      return true;
    }

    bool IJsonLineInfo.HasLineInfo()
    {
      IJsonLineInfo lineInfo = _reader as IJsonLineInfo;
      return lineInfo != null && lineInfo.HasLineInfo();
    }

    int IJsonLineInfo.LineNumber
    {
      get
      {
        IJsonLineInfo lineInfo = _reader as IJsonLineInfo;
        return (lineInfo != null) ? lineInfo.LineNumber : 0;
      }
    }

    int IJsonLineInfo.LinePosition
    {
      get
      {
        IJsonLineInfo lineInfo = _reader as IJsonLineInfo;
        return (lineInfo != null) ? lineInfo.LinePosition : 0;
      }
    }
  }
}
#endregion JsonValidatingReader.cs

/// ********   File: \JsonWriter.cs
#region JsonWriter.cs

#if NETFX_CORE
#endif
#if NET20
#else
#endif

namespace Newtonsoft.Json
{
  /// <summary>
  /// Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
  /// </summary>
  public abstract class JsonWriter : IDisposable
  {
    internal enum State
    {
      Start,
      Property,
      ObjectStart,
      Object,
      ArrayStart,
      Array,
      ConstructorStart,
      Constructor,
      Closed,
      Error
    }

    // array that gives a new state based on the current state an the token being written
    private static readonly State[][] StateArray;

    internal static readonly State[][] StateArrayTempate = new[] {
//                                      Start                   PropertyName            ObjectStart         Object            ArrayStart              Array                   ConstructorStart        Constructor             Closed          Error
//                        
/* None                        */new[]{ State.Error,            State.Error,            State.Error,        State.Error,      State.Error,            State.Error,            State.Error,            State.Error,            State.Error,    State.Error },
/* StartObject                 */new[]{ State.ObjectStart,      State.ObjectStart,      State.Error,        State.Error,      State.ObjectStart,      State.ObjectStart,      State.ObjectStart,      State.ObjectStart,      State.Error,    State.Error },
/* StartArray                  */new[]{ State.ArrayStart,       State.ArrayStart,       State.Error,        State.Error,      State.ArrayStart,       State.ArrayStart,       State.ArrayStart,       State.ArrayStart,       State.Error,    State.Error },
/* StartConstructor            */new[]{ State.ConstructorStart, State.ConstructorStart, State.Error,        State.Error,      State.ConstructorStart, State.ConstructorStart, State.ConstructorStart, State.ConstructorStart, State.Error,    State.Error },
/* Property                    */new[]{ State.Property,         State.Error,            State.Property,     State.Property,   State.Error,            State.Error,            State.Error,            State.Error,            State.Error,    State.Error },
/* Comment                     */new[]{ State.Start,            State.Property,         State.ObjectStart,  State.Object,     State.ArrayStart,       State.Array,            State.Constructor,      State.Constructor,      State.Error,    State.Error },
/* Raw                         */new[]{ State.Start,            State.Property,         State.ObjectStart,  State.Object,     State.ArrayStart,       State.Array,            State.Constructor,      State.Constructor,      State.Error,    State.Error },
/* Value (this will be copied) */new[]{ State.Start,            State.Object,           State.Error,        State.Error,      State.Array,            State.Array,            State.Constructor,      State.Constructor,      State.Error,    State.Error }
		};

    internal static State[][] BuildStateArray()
    {
      var allStates = StateArrayTempate.ToList();
      var errorStates = StateArrayTempate[0];
      var valueStates = StateArrayTempate[7];

      foreach (JsonToken valueToken in EnumUtils.GetValues(typeof(JsonToken)))
      {
        if (allStates.Count <= (int)valueToken)
        {
          switch (valueToken)
          {
            case JsonToken.Integer:
            case JsonToken.Float:
            case JsonToken.String:
            case JsonToken.Boolean:
            case JsonToken.Null:
            case JsonToken.Undefined:
            case JsonToken.Date:
            case JsonToken.Bytes:
              allStates.Add(valueStates);
              break;
            default:
              allStates.Add(errorStates);
              break;
          }
        }
      }

      return allStates.ToArray();
    }

    static JsonWriter()
    {
      StateArray = BuildStateArray();
    }

    private readonly List<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;

    /// <summary>
    /// Gets or sets a value indicating whether the underlying stream or
    /// <see cref="TextReader"/> should be closed when the writer is closed.
    /// </summary>
    /// <value>
    /// true to close the underlying stream or <see cref="TextReader"/> when
    /// the writer is closed; otherwise false. The default is true.
    /// </value>
    public bool CloseOutput { get; set; }

    /// <summary>
    /// Gets the top.
    /// </summary>
    /// <value>The top.</value>
    protected internal int Top
    {
      get
      {
        int depth = _stack.Count;
        if (Peek() != JsonContainerType.None)
          depth++;

        return depth;
      }
    }

    /// <summary>
    /// Gets the state of the writer.
    /// </summary>
    public WriteState WriteState
    {
      get
      {
        switch (_currentState)
        {
          case State.Error:
            return WriteState.Error;
          case State.Closed:
            return WriteState.Closed;
          case State.Object:
          case State.ObjectStart:
            return WriteState.Object;
          case State.Array:
          case State.ArrayStart:
            return WriteState.Array;
          case State.Constructor:
          case State.ConstructorStart:
            return WriteState.Constructor;
          case State.Property:
            return WriteState.Property;
          case State.Start:
            return WriteState.Start;
          default:
            throw JsonWriterException.Create(this, "Invalid state: " + _currentState, null);
        }
      }
    }

    internal string ContainerPath
    {
      get
      {
        if (_currentPosition.Type == JsonContainerType.None)
          return string.Empty;

        return JsonPosition.BuildPath(_stack);
      }
    }

    /// <summary>
    /// Gets the path of the writer. 
    /// </summary>
    public string Path
    {
      get
      {
        if (_currentPosition.Type == JsonContainerType.None)
          return string.Empty;

        bool insideContainer = (_currentState != State.ArrayStart
          && _currentState != State.ConstructorStart
          && _currentState != State.ObjectStart);

        IEnumerable<JsonPosition> positions = (!insideContainer)
          ? _stack
          : _stack.Concat(new[] { _currentPosition });

        return JsonPosition.BuildPath(positions);
      }
    }

    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;

    /// <summary>
    /// Indicates how JSON text output is formatted.
    /// </summary>
    public Formatting Formatting
    {
      get { return _formatting; }
      set { _formatting = value; }
    }

    /// <summary>
    /// Get or set how dates are written to JSON text.
    /// </summary>
    public DateFormatHandling DateFormatHandling
    {
      get { return _dateFormatHandling; }
      set { _dateFormatHandling = value; }
    }

    /// <summary>
    /// Get or set how <see cref="DateTime"/> time zones are handling when writing JSON text.
    /// </summary>
    public DateTimeZoneHandling DateTimeZoneHandling
    {
      get { return _dateTimeZoneHandling; }
      set { _dateTimeZoneHandling = value; }
    }

    /// <summary>
    /// Get or set how strings are escaped when writing JSON text.
    /// </summary>
    public StringEscapeHandling StringEscapeHandling
    {
      get { return _stringEscapeHandling; }
      set { _stringEscapeHandling = value; }
    }

    /// <summary>
    /// Creates an instance of the <c>JsonWriter</c> class. 
    /// </summary>
    protected JsonWriter()
    {
      _stack = new List<JsonPosition>(4);
      _currentState = State.Start;
      _formatting = Formatting.None;
      _dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;

      CloseOutput = true;
    }

    internal void UpdateScopeWithFinishedValue()
    {
      if (_currentPosition.HasIndex)
          _currentPosition.Position++;
    }

    private void Push(JsonContainerType value)
    {
      if (_currentPosition.Type != JsonContainerType.None)
        _stack.Add(_currentPosition);

      _currentPosition = new JsonPosition(value);
    }

    private JsonContainerType Pop()
    {
      JsonPosition oldPosition = _currentPosition;

      if (_stack.Count > 0)
      {
        _currentPosition = _stack[_stack.Count - 1];
        _stack.RemoveAt(_stack.Count - 1);
      }
      else
      {
        _currentPosition = new JsonPosition();
      }

      return oldPosition.Type;
    }

    private JsonContainerType Peek()
    {
      return _currentPosition.Type;
    }

    /// <summary>
    /// Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
    /// </summary>
    public abstract void Flush();

    /// <summary>
    /// Closes this stream and the underlying stream.
    /// </summary>
    public virtual void Close()
    {
      AutoCompleteAll();
    }

    /// <summary>
    /// Writes the beginning of a Json object.
    /// </summary>
    public virtual void WriteStartObject()
    {
      InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
    }

    internal void InternalWriteStart(JsonToken token, JsonContainerType container)
    {
      UpdateScopeWithFinishedValue();
      AutoComplete(token);
      Push(container);
    }

    /// <summary>
    /// Writes the end of a Json object.
    /// </summary>
    public virtual void WriteEndObject()
    {
      InternalWriteEnd(JsonContainerType.Object);
    }

    /// <summary>
    /// Writes the beginning of a Json array.
    /// </summary>
    public virtual void WriteStartArray()
    {
      InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
    }

    /// <summary>
    /// Writes the end of an array.
    /// </summary>
    public virtual void WriteEndArray()
    {
      InternalWriteEnd(JsonContainerType.Array);
    }

    /// <summary>
    /// Writes the start of a constructor with the given name.
    /// </summary>
    /// <param name="name">The name of the constructor.</param>
    public virtual void WriteStartConstructor(string name)
    {
      InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
    }

    /// <summary>
    /// Writes the end constructor.
    /// </summary>
    public virtual void WriteEndConstructor()
    {
      InternalWriteEnd(JsonContainerType.Constructor);
    }

    internal void InternalWriteEnd(JsonContainerType container)
    {
      AutoCompleteClose(container);
    }

    /// <summary>
    /// Writes the property name of a name/value pair on a Json object.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    public virtual void WritePropertyName(string name)
    {
      InternalWritePropertyName(name);
    }

    internal void InternalWritePropertyName(string name)
    {
      _currentPosition.PropertyName = name;
      AutoComplete(JsonToken.PropertyName);
    }

    /// <summary>
    /// Writes the end of the current Json object or array.
    /// </summary>
    public virtual void WriteEnd()
    {
      WriteEnd(Peek());
    }

    /// <summary>
    /// Writes the current <see cref="JsonReader"/> token.
    /// </summary>
    /// <param name="reader">The <see cref="JsonReader"/> to read the token from.</param>
    public void WriteToken(JsonReader reader)
    {
      ValidationUtils.ArgumentNotNull(reader, "reader");

      int initialDepth;

      if (reader.TokenType == JsonToken.None)
        initialDepth = -1;
      else if (!IsStartToken(reader.TokenType))
        initialDepth = reader.Depth + 1;
      else
        initialDepth = reader.Depth;

      WriteToken(reader, initialDepth);
    }

    internal void WriteToken(JsonReader reader, int initialDepth)
    {
      do
      {
        switch (reader.TokenType)
        {
          case JsonToken.None:
            // read to next
            break;
          case JsonToken.StartObject:
            WriteStartObject();
            break;
          case JsonToken.StartArray:
            WriteStartArray();
            break;
          case JsonToken.StartConstructor:
            string constructorName = reader.Value.ToString();
            // write a JValue date when the constructor is for a date
            if (string.Equals(constructorName, "Date", StringComparison.Ordinal))
              WriteConstructorDate(reader);
            else
              WriteStartConstructor(reader.Value.ToString());
            break;
          case JsonToken.PropertyName:
            WritePropertyName(reader.Value.ToString());
            break;
          case JsonToken.Comment:
            WriteComment((reader.Value != null) ? reader.Value.ToString() : null);
            break;
          case JsonToken.Integer:
            WriteValue(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
            break;
          case JsonToken.Float:
            object value = reader.Value;

            if (value is decimal)
              WriteValue((decimal)value);
            else if (value is double)
              WriteValue((double)value);
            else if (value is float)
              WriteValue((float)value);
            else
              WriteValue(Convert.ToDouble(value, CultureInfo.InvariantCulture));
            break;
          case JsonToken.String:
            WriteValue(reader.Value.ToString());
            break;
          case JsonToken.Boolean:
            WriteValue(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
            break;
          case JsonToken.Null:
            WriteNull();
            break;
          case JsonToken.Undefined:
            WriteUndefined();
            break;
          case JsonToken.EndObject:
            WriteEndObject();
            break;
          case JsonToken.EndArray:
            WriteEndArray();
            break;
          case JsonToken.EndConstructor:
            WriteEndConstructor();
            break;
          case JsonToken.Date:
#if !PocketPC && !NET20
            if (reader.Value is DateTimeOffset)
              WriteValue((DateTimeOffset)reader.Value);
            else
#endif
              WriteValue(Convert.ToDateTime(reader.Value, CultureInfo.InvariantCulture));
            break;
          case JsonToken.Raw:
            WriteRawValue((reader.Value != null) ? reader.Value.ToString() : null);
            break;
          case JsonToken.Bytes:
            WriteValue((byte[])reader.Value);
            break;
          default:
            throw MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", reader.TokenType, "Unexpected token type.");
        }
      }
      while (
        // stop if we have reached the end of the token being read
        initialDepth - 1 < reader.Depth - (IsEndToken(reader.TokenType) ? 1 : 0)
        && reader.Read());
    }

    private void WriteConstructorDate(JsonReader reader)
    {
      if (!reader.Read())
        throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
      if (reader.TokenType != JsonToken.Integer)
        throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType, null);

      long ticks = (long)reader.Value;
      DateTime date = JsonConvert.ConvertJavaScriptTicksToDateTime(ticks);

      if (!reader.Read())
        throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
      if (reader.TokenType != JsonToken.EndConstructor)
        throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + reader.TokenType, null);

      WriteValue(date);
    }

    private bool IsEndToken(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.EndObject:
        case JsonToken.EndArray:
        case JsonToken.EndConstructor:
          return true;
        default:
          return false;
      }
    }

    private bool IsStartToken(JsonToken token)
    {
      switch (token)
      {
        case JsonToken.StartObject:
        case JsonToken.StartArray:
        case JsonToken.StartConstructor:
          return true;
        default:
          return false;
      }
    }

    private void WriteEnd(JsonContainerType type)
    {
      switch (type)
      {
        case JsonContainerType.Object:
          WriteEndObject();
          break;
        case JsonContainerType.Array:
          WriteEndArray();
          break;
        case JsonContainerType.Constructor:
          WriteEndConstructor();
          break;
        default:
          throw JsonWriterException.Create(this, "Unexpected type when writing end: " + type, null);
      }
    }

    private void AutoCompleteAll()
    {
      while (Top > 0)
      {
        WriteEnd();
      }
    }

    private JsonToken GetCloseTokenForType(JsonContainerType type)
    {
      switch (type)
      {
        case JsonContainerType.Object:
          return JsonToken.EndObject;
        case JsonContainerType.Array:
          return JsonToken.EndArray;
        case JsonContainerType.Constructor:
          return JsonToken.EndConstructor;
        default:
          throw JsonWriterException.Create(this, "No close token for type: " + type, null);
      }
    }

    private void AutoCompleteClose(JsonContainerType type)
    {
      // write closing symbol and calculate new state
      int levelsToComplete = 0;

      if (_currentPosition.Type == type)
      {
        levelsToComplete = 1;
      }
      else
      {
        int top = Top - 2;
        for (int i = top; i >= 0; i--)
        {
          int currentLevel = top - i;

          if (_stack[currentLevel].Type == type)
          {
            levelsToComplete = i + 2;
            break;
          }
        }
      }

      if (levelsToComplete == 0)
        throw JsonWriterException.Create(this, "No token to close.", null);

      for (int i = 0; i < levelsToComplete; i++)
      {
        JsonToken token = GetCloseTokenForType(Pop());

        if (_currentState == State.Property)
          WriteNull();

        if (_formatting == Formatting.Indented)
        {
          if (_currentState != State.ObjectStart && _currentState != State.ArrayStart)
            WriteIndent();
        }

        WriteEnd(token);

        JsonContainerType currentLevelType = Peek();

        switch (currentLevelType)
        {
          case JsonContainerType.Object:
            _currentState = State.Object;
            break;
          case JsonContainerType.Array:
            _currentState = State.Array;
            break;
          case JsonContainerType.Constructor:
            _currentState = State.Array;
            break;
          case JsonContainerType.None:
            _currentState = State.Start;
            break;
          default:
            throw JsonWriterException.Create(this, "Unknown JsonType: " + currentLevelType, null);
        }
      }
    }

    /// <summary>
    /// Writes the specified end token.
    /// </summary>
    /// <param name="token">The end token to write.</param>
    protected virtual void WriteEnd(JsonToken token)
    {
    }

    /// <summary>
    /// Writes indent characters.
    /// </summary>
    protected virtual void WriteIndent()
    {
    }

    /// <summary>
    /// Writes the JSON value delimiter.
    /// </summary>
    protected virtual void WriteValueDelimiter()
    {
    }

    /// <summary>
    /// Writes an indent space.
    /// </summary>
    protected virtual void WriteIndentSpace()
    {
    }

    internal void AutoComplete(JsonToken tokenBeingWritten)
    {
      // gets new state based on the current state and what is being written
      State newState = StateArray[(int)tokenBeingWritten][(int)_currentState];

      if (newState == State.Error)
        throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()), null);

      if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
      {
        WriteValueDelimiter();
      }

      if (_formatting == Formatting.Indented)
      {
        if (_currentState == State.Property)
          WriteIndentSpace();

        // don't indent a property when it is the first token to be written (i.e. at the start)
        if ((_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.Constructor || _currentState == State.ConstructorStart)
          || (tokenBeingWritten == JsonToken.PropertyName && _currentState != State.Start))
          WriteIndent();
      }

      _currentState = newState;
    }

    #region WriteValue methods
    /// <summary>
    /// Writes a null value.
    /// </summary>
    public virtual void WriteNull()
    {
      InternalWriteNull();
    }

    internal void InternalWriteNull()
    {
      UpdateScopeWithFinishedValue();
      AutoComplete(JsonToken.Null);
    }

    /// <summary>
    /// Writes an undefined value.
    /// </summary>
    public virtual void WriteUndefined()
    {
      InternalWriteUndefined();
    }

    internal void InternalWriteUndefined()
    {
      UpdateScopeWithFinishedValue();
      AutoComplete(JsonToken.Undefined);
    }

    /// <summary>
    /// Writes raw JSON without changing the writer's state.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public virtual void WriteRaw(string json)
    {
      InternalWriteRaw();
    }

    internal void InternalWriteRaw()
    {
    }

    /// <summary>
    /// Writes raw JSON where a value is expected and updates the writer's state.
    /// </summary>
    /// <param name="json">The raw JSON to write.</param>
    public virtual void WriteRawValue(string json)
    {
      // hack. want writer to change state as if a value had been written
      UpdateScopeWithFinishedValue();
      AutoComplete(JsonToken.Undefined);
      WriteRaw(json);
    }

    /// <summary>
    /// Writes a <see cref="String"/> value.
    /// </summary>
    /// <param name="value">The <see cref="String"/> value to write.</param>
    public virtual void WriteValue(string value)
    {
      InternalWriteValue(JsonToken.String);
    }

    internal void InternalWriteValue(JsonToken token)
    {
      UpdateScopeWithFinishedValue();
      AutoComplete(token);
    }

    /// <summary>
    /// Writes a <see cref="Int32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int32"/> value to write.</param>
    public virtual void WriteValue(int value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt32"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt32"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(uint value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Int64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int64"/> value to write.</param>
    public virtual void WriteValue(long value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt64"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt64"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(ulong value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Single"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Single"/> value to write.</param>
    public virtual void WriteValue(float value)
    {
      InternalWriteValue(JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Double"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Double"/> value to write.</param>
    public virtual void WriteValue(double value)
    {
      InternalWriteValue(JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="Boolean"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Boolean"/> value to write.</param>
    public virtual void WriteValue(bool value)
    {
      InternalWriteValue(JsonToken.Boolean);
    }

    /// <summary>
    /// Writes a <see cref="Int16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Int16"/> value to write.</param>
    public virtual void WriteValue(short value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="UInt16"/> value.
    /// </summary>
    /// <param name="value">The <see cref="UInt16"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(ushort value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Char"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Char"/> value to write.</param>
    public virtual void WriteValue(char value)
    {
      InternalWriteValue(JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Byte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Byte"/> value to write.</param>
    public virtual void WriteValue(byte value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="SByte"/> value.
    /// </summary>
    /// <param name="value">The <see cref="SByte"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(sbyte value)
    {
      InternalWriteValue(JsonToken.Integer);
    }

    /// <summary>
    /// Writes a <see cref="Decimal"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Decimal"/> value to write.</param>
    public virtual void WriteValue(decimal value)
    {
      InternalWriteValue(JsonToken.Float);
    }

    /// <summary>
    /// Writes a <see cref="DateTime"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTime"/> value to write.</param>
    public virtual void WriteValue(DateTime value)
    {
      InternalWriteValue(JsonToken.Date);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Writes a <see cref="DateTimeOffset"/> value.
    /// </summary>
    /// <param name="value">The <see cref="DateTimeOffset"/> value to write.</param>
    public virtual void WriteValue(DateTimeOffset value)
    {
      InternalWriteValue(JsonToken.Date);
    }
#endif

    /// <summary>
    /// Writes a <see cref="Guid"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Guid"/> value to write.</param>
    public virtual void WriteValue(Guid value)
    {
      InternalWriteValue(JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="TimeSpan"/> value.
    /// </summary>
    /// <param name="value">The <see cref="TimeSpan"/> value to write.</param>
    public virtual void WriteValue(TimeSpan value)
    {
      InternalWriteValue(JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Int32}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Int32}"/> value to write.</param>
    public virtual void WriteValue(int? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{UInt32}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{UInt32}"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(uint? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Int64}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Int64}"/> value to write.</param>
    public virtual void WriteValue(long? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{UInt64}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{UInt64}"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(ulong? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Single}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Single}"/> value to write.</param>
    public virtual void WriteValue(float? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Double}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Double}"/> value to write.</param>
    public virtual void WriteValue(double? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Boolean}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Boolean}"/> value to write.</param>
    public virtual void WriteValue(bool? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Int16}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Int16}"/> value to write.</param>
    public virtual void WriteValue(short? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{UInt16}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{UInt16}"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(ushort? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Char}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Char}"/> value to write.</param>
    public virtual void WriteValue(char? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Byte}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Byte}"/> value to write.</param>
    public virtual void WriteValue(byte? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{SByte}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{SByte}"/> value to write.</param>
    [CLSCompliant(false)]
    public virtual void WriteValue(sbyte? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{Decimal}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Decimal}"/> value to write.</param>
    public virtual void WriteValue(decimal? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{DateTime}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{DateTime}"/> value to write.</param>
    public virtual void WriteValue(DateTime? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

#if !PocketPC && !NET20
    /// <summary>
    /// Writes a <see cref="Nullable{DateTimeOffset}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{DateTimeOffset}"/> value to write.</param>
    public virtual void WriteValue(DateTimeOffset? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }
#endif

    /// <summary>
    /// Writes a <see cref="Nullable{Guid}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{Guid}"/> value to write.</param>
    public virtual void WriteValue(Guid? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="Nullable{TimeSpan}"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Nullable{TimeSpan}"/> value to write.</param>
    public virtual void WriteValue(TimeSpan? value)
    {
      if (value == null)
        WriteNull();
      else
        WriteValue(value.Value);
    }

    /// <summary>
    /// Writes a <see cref="T:Byte[]"/> value.
    /// </summary>
    /// <param name="value">The <see cref="T:Byte[]"/> value to write.</param>
    public virtual void WriteValue(byte[] value)
    {
      if (value == null)
        WriteNull();
      else
        InternalWriteValue(JsonToken.Bytes);
    }

    /// <summary>
    /// Writes a <see cref="Uri"/> value.
    /// </summary>
    /// <param name="value">The <see cref="Uri"/> value to write.</param>
    public virtual void WriteValue(Uri value)
    {
      if (value == null)
        WriteNull();
      else
        InternalWriteValue(JsonToken.String);
    }

    /// <summary>
    /// Writes a <see cref="Object"/> value.
    /// An error will raised if the value cannot be written as a single JSON token.
    /// </summary>
    /// <param name="value">The <see cref="Object"/> value to write.</param>
    public virtual void WriteValue(object value)
    {
      if (value == null)
      {
        WriteNull();
        return;
      }
      else if (ConvertUtils.IsConvertible(value))
      {
        IConvertible convertible = ConvertUtils.ToConvertible(value);

        switch (convertible.GetTypeCode())
        {
          case TypeCode.String:
            WriteValue(convertible.ToString(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Char:
            WriteValue(convertible.ToChar(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Boolean:
            WriteValue(convertible.ToBoolean(CultureInfo.InvariantCulture));
            return;
          case TypeCode.SByte:
            WriteValue(convertible.ToSByte(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Int16:
            WriteValue(convertible.ToInt16(CultureInfo.InvariantCulture));
            return;
          case TypeCode.UInt16:
            WriteValue(convertible.ToUInt16(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Int32:
            WriteValue(convertible.ToInt32(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Byte:
            WriteValue(convertible.ToByte(CultureInfo.InvariantCulture));
            return;
          case TypeCode.UInt32:
            WriteValue(convertible.ToUInt32(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Int64:
            WriteValue(convertible.ToInt64(CultureInfo.InvariantCulture));
            return;
          case TypeCode.UInt64:
            WriteValue(convertible.ToUInt64(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Single:
            WriteValue(convertible.ToSingle(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Double:
            WriteValue(convertible.ToDouble(CultureInfo.InvariantCulture));
            return;
          case TypeCode.DateTime:
            WriteValue(convertible.ToDateTime(CultureInfo.InvariantCulture));
            return;
          case TypeCode.Decimal:
            WriteValue(convertible.ToDecimal(CultureInfo.InvariantCulture));
            return;
#if !(NETFX_CORE || PORTABLE)
          case TypeCode.DBNull:
            WriteNull();
            return;
#endif
        }
      }
#if !PocketPC && !NET20
      else if (value is DateTimeOffset)
      {
        WriteValue((DateTimeOffset)value);
        return;
      }
#endif
      else if (value is byte[])
      {
        WriteValue((byte[])value);
        return;
      }
      else if (value is Guid)
      {
        WriteValue((Guid)value);
        return;
      }
      else if (value is Uri)
      {
        WriteValue((Uri)value);
        return;
      }
      else if (value is TimeSpan)
      {
        WriteValue((TimeSpan)value);
        return;
      }

      throw JsonWriterException.Create(this, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
    }
    #endregion

    /// <summary>
    /// Writes out a comment <code>/*...*/</code> containing the specified text. 
    /// </summary>
    /// <param name="text">Text to place inside the comment.</param>
    public virtual void WriteComment(string text)
    {
      InternalWriteComment();
    }

    internal void InternalWriteComment()
    {
      AutoComplete(JsonToken.Comment);
    }

    /// <summary>
    /// Writes out the given white space.
    /// </summary>
    /// <param name="ws">The string of white space characters.</param>
    public virtual void WriteWhitespace(string ws)
    {
      InternalWriteWhitespace(ws);
    }

    internal void InternalWriteWhitespace(string ws)
    {
      if (ws != null)
      {
        if (!StringUtils.IsWhiteSpace(ws))
          throw JsonWriterException.Create(this, "Only white space characters should be used.", null);
      }
    }

    void IDisposable.Dispose()
    {
      Dispose(true);
    }

    private void Dispose(bool disposing)
    {
      if (_currentState != State.Closed)
        Close();
    }
  }
}
#endregion JsonWriter.cs

/// ********   File: \JsonWriterException.cs
#region JsonWriterException.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// The exception thrown when an error occurs while reading Json text.
  /// </summary>
#if !(SILVERLIGHT || WINDOWS_PHONE || NETFX_CORE || PORTABLE)
  [Serializable]
#endif
  public class JsonWriterException : JsonException
  {
    /// <summary>
    /// Gets the path to the JSON where the error occurred.
    /// </summary>
    /// <value>The path to the JSON where the error occurred.</value>
    public string Path { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonWriterException"/> class.
    /// </summary>
    public JsonWriterException()
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonWriterException"/> class
    /// with a specified error message.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    public JsonWriterException(string message)
      : base(message)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonWriterException"/> class
    /// with a specified error message and a reference to the inner exception that is the cause of this exception.
    /// </summary>
    /// <param name="message">The error message that explains the reason for the exception.</param>
    /// <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    public JsonWriterException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

#if !(WINDOWS_PHONE || SILVERLIGHT || NETFX_CORE || PORTABLE)
    /// <summary>
    /// Initializes a new instance of the <see cref="JsonWriterException"/> class.
    /// </summary>
    /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
    /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is null. </exception>
    /// <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0). </exception>
    public JsonWriterException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
    }
#endif

    internal JsonWriterException(string message, Exception innerException, string path)
      : base(message, innerException)
    {
      Path = path;
    }

    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex)
    {
      return Create(writer.ContainerPath, message, ex);
    }

    internal static JsonWriterException Create(string path, string message, Exception ex)
    {
      message = JsonPosition.FormatMessage(null, path, message);

      return new JsonWriterException(message, ex, path);
    }
  }
}
#endregion JsonWriterException.cs

/// ********   File: \MemberSerialization.cs
#region MemberSerialization.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies the member serialization options for the <see cref="JsonSerializer"/>.
  /// </summary>
  public enum MemberSerialization
  {
    /// <summary>
    /// All public members are serialized by default. Members can be excluded using <see cref="JsonIgnoreAttribute"/> or <see cref="NonSerializedAttribute"/>.
    /// This is the default member serialization mode.
    /// </summary>
    OptOut,
    /// <summary>
    /// Only members must be marked with <see cref="JsonPropertyAttribute"/> or <see cref="DataMemberAttribute"/> are serialized.
    /// This member serialization mode can also be set by marking the class with <see cref="DataContractAttribute"/>.
    /// </summary>
    OptIn,
    /// <summary>
    /// All public and private fields are serialized. Members can be excluded using <see cref="JsonIgnoreAttribute"/> or <see cref="NonSerializedAttribute"/>.
    /// This member serialization mode can also be set by marking the class with <see cref="SerializableAttribute"/>
    /// and setting IgnoreSerializableAttribute on <see cref="DefaultContractResolver"/> to false.
    /// </summary>
    Fields
  }
}
#endregion MemberSerialization.cs

/// ********   File: \MissingMemberHandling.cs
#region MissingMemberHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies missing member handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  public enum MissingMemberHandling
  {
    /// <summary>
    /// Ignore a missing member and do not attempt to deserialize it.
    /// </summary>
    Ignore = 0,
    /// <summary>
    /// Throw a <see cref="JsonSerializationException"/> when a missing member is encountered during deserialization.
    /// </summary>
    Error = 1
  }
}

#endregion MissingMemberHandling.cs

/// ********   File: \NullValueHandling.cs
#region NullValueHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies null value handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingObject" title="NullValueHandling Class" />
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingExample" title="NullValueHandling Ignore Example" />
  /// </example>
  public enum NullValueHandling
  {
    /// <summary>
    /// Include null values when serializing and deserializing objects.
    /// </summary>
    Include = 0,
    /// <summary>
    /// Ignore null values when serializing and deserializing objects.
    /// </summary>
    Ignore = 1
  }
}
#endregion NullValueHandling.cs

/// ********   File: \ObjectCreationHandling.cs
#region ObjectCreationHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how object creation is handled by the <see cref="JsonSerializer"/>.
  /// </summary>
  public enum ObjectCreationHandling
  {
    /// <summary>
    /// Reuse existing objects, create new objects when needed.
    /// </summary>
    Auto = 0,
    /// <summary>
    /// Only reuse existing objects.
    /// </summary>
    Reuse = 1,
    /// <summary>
    /// Always create new objects.
    /// </summary>
    Replace = 2
  }
}
#endregion ObjectCreationHandling.cs

/// ********   File: \PreserveReferencesHandling.cs
#region PreserveReferencesHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies reference handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  /// <example>
  ///   <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="PreservingObjectReferencesOn" title="Preserve Object References" />       
  /// </example>
  [Flags]
  public enum PreserveReferencesHandling
  {
    /// <summary>
    /// Do not preserve references when serializing types.
    /// </summary>
    None = 0,
    /// <summary>
    /// Preserve references when serializing into a JSON object structure.
    /// </summary>
    Objects = 1,
    /// <summary>
    /// Preserve references when serializing into a JSON array structure.
    /// </summary>
    Arrays = 2,
    /// <summary>
    /// Preserve references when serializing.
    /// </summary>
    All = Objects | Arrays
  }
}

#endregion PreserveReferencesHandling.cs

/// ********   File: \ReferenceLoopHandling.cs
#region ReferenceLoopHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies reference loop handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  public enum ReferenceLoopHandling
  {
    /// <summary>
    /// Throw a <see cref="JsonSerializationException"/> when a loop is encountered.
    /// </summary>
    Error = 0,
    /// <summary>
    /// Ignore loop references and do not serialize.
    /// </summary>
    Ignore = 1,
    /// <summary>
    /// Serialize loop references.
    /// </summary>
    Serialize = 2
  }
}

#endregion ReferenceLoopHandling.cs

/// ********   File: \Required.cs
#region Required.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Indicating whether a property is required.
  /// </summary>
  public enum Required
  {
    /// <summary>
    /// The property is not required. The default state.
    /// </summary>
    Default,
    /// <summary>
    /// The property must be defined in JSON but can be a null value.
    /// </summary>
    AllowNull,
    /// <summary>
    /// The property must be defined in JSON and cannot be a null value.
    /// </summary>
    Always
  }
}
#endregion Required.cs

/// ********   File: \SerializationBinder.cs
#region SerializationBinder.cs
#if SILVERLIGHT || PocketPC || NETFX_CORE || PORTABLE

namespace Newtonsoft.Json
{
  /// <summary>
  /// Allows users to control class loading and mandate what class to load.
  /// </summary>
  public abstract class SerializationBinder
  {
    /// <summary>
    /// When overridden in a derived class, controls the binding of a serialized object to a type.
    /// </summary>
    /// <param name="assemblyName">Specifies the <see cref="Assembly"/> name of the serialized object.</param>
    /// <param name="typeName">Specifies the <see cref="Type"/> name of the serialized object</param>
    /// <returns>The type of the object the formatter creates a new instance of.</returns>
    public abstract Type BindToType(string assemblyName, string typeName);

    /// <summary>
    /// When overridden in a derived class, controls the binding of a serialized object to a type.
    /// </summary>
    /// <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
    /// <param name="assemblyName">Specifies the <see cref="Assembly"/> name of the serialized object.</param>
    /// <param name="typeName">Specifies the <see cref="Type"/> name of the serialized object.</param>
    public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName)
    {
      assemblyName = null;
      typeName = null;
    }
  }
}
#endif
#endregion SerializationBinder.cs

/// ********   File: \StreamingContext.cs
#region StreamingContext.cs
#if PocketPC
#pragma warning disable 1591

// This class is... borrowed from .NET and Microsoft for a short time.
// Hopefully Microsoft will add DateTimeOffset to the compact framework
// or I will rewrite a striped down version of this file myself

namespace System.Runtime.Serialization
{
  public enum StreamingContextStates
  {
    All = 255,
    Clone = 64,
    CrossAppDomain = 128,
    CrossMachine = 2,
    CrossProcess = 1,
    File = 4,
    Other = 32,
    Persistence = 8,
    Remoting = 16
  }

  public struct StreamingContext
  {
    internal object m_additionalContext;
    internal StreamingContextStates m_state;
    public StreamingContext(StreamingContextStates state)
      : this(state, null)
    {
    }

    public StreamingContext(StreamingContextStates state, object additional)
    {
      this.m_state = state;
      this.m_additionalContext = additional;
    }

    public object Context
    {
      get
      {
        return this.m_additionalContext;
      }
    }
    public override bool Equals(object obj)
    {
      return ((obj is StreamingContext) && ((((StreamingContext)obj).m_additionalContext == this.m_additionalContext) && (((StreamingContext)obj).m_state == this.m_state)));
    }

    public override int GetHashCode()
    {
      return (int)this.m_state;
    }

    public StreamingContextStates State
    {
      get
      {
        return this.m_state;
      }
    }
  }
}
#endif
#endregion StreamingContext.cs

/// ********   File: \StringEscapeHandling.cs
#region StringEscapeHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies how strings are escaped when writing JSON text.
  /// </summary>
  public enum StringEscapeHandling
  {
    /// <summary>
    /// Only control characters (e.g. newline) are escaped.
    /// </summary>
    Default,
    /// <summary>
    /// All non-ASCII and control characters (e.g. newline) are escaped.
    /// </summary>
    EscapeNonAscii,
    /// <summary>
    /// HTML (&lt;, &gt;, &amp;, &apos;, &quot;) and control characters (e.g. newline) are escaped.
    /// </summary>
    EscapeHtml
  }
}
#endregion StringEscapeHandling.cs

/// ********   File: \TraceLevel.cs
#region TraceLevel.cs
#if (NETFX_CORE || SILVERLIGHT || PORTABLE)

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies what messages to output for the <see cref="ITraceWriter"/> class.
  /// </summary>
  public enum TraceLevel
  {
    /// <summary>
    /// Output no tracing and debugging messages.
    /// </summary>
    Off,
    /// <summary>
    /// Output error-handling messages.
    /// </summary>
    Error,
    /// <summary>
    /// Output warnings and error-handling messages.
    /// </summary>
    Warning,
    /// <summary>
    /// Output informational messages, warnings, and error-handling messages.
    /// </summary>
    Info,
    /// <summary>
    /// Output all debugging and tracing messages.
    /// </summary>
    Verbose
  }
}
#endif
#endregion TraceLevel.cs

/// ********   File: \TypeNameHandling.cs
#region TypeNameHandling.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies type name handling options for the <see cref="JsonSerializer"/>.
  /// </summary>
  [Flags]
  public enum TypeNameHandling
  {
    /// <summary>
    /// Do not include the .NET type name when serializing types.
    /// </summary>
    None = 0,
    /// <summary>
    /// Include the .NET type name when serializing into a JSON object structure.
    /// </summary>
    Objects = 1,
    /// <summary>
    /// Include the .NET type name when serializing into a JSON array structure.
    /// </summary>
    Arrays = 2,
    /// <summary>
    /// Always include the .NET type name when serializing.
    /// </summary>
    All = Objects | Arrays,
    /// <summary>
    /// Include the .NET type name when the type of the object being serialized is not the same as its declared type.
    /// </summary>
    Auto = 4
  }
}
#endregion TypeNameHandling.cs

/// ********   File: \WriteState.cs
#region WriteState.cs

namespace Newtonsoft.Json
{
  /// <summary>
  /// Specifies the state of the <see cref="JsonWriter"/>.
  /// </summary>
  public enum WriteState
  {
    /// <summary>
    /// An exception has been thrown, which has left the <see cref="JsonWriter"/> in an invalid state.
    /// You may call the <see cref="JsonWriter.Close"/> method to put the <see cref="JsonWriter"/> in the <c>Closed</c> state.
    /// Any other <see cref="JsonWriter"/> method calls results in an <see cref="InvalidOperationException"/> being thrown. 
    /// </summary>
    Error,
    /// <summary>
    /// The <see cref="JsonWriter.Close"/> method has been called. 
    /// </summary>
    Closed,
    /// <summary>
    /// An object is being written. 
    /// </summary>
    Object,
    /// <summary>
    /// A array is being written.
    /// </summary>
    Array,
    /// <summary>
    /// A constructor is being written.
    /// </summary>
    Constructor,
    /// <summary>
    /// A property is being written.
    /// </summary>
    Property,
    /// <summary>
    /// A write method has not been called.
    /// </summary>
    Start
  }
}
#endregion WriteState.cs



