using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Reflection;
using System.Text;

using LEADBase;

namespace LEAD_Log
{
	/// <summary>
	/// Class Name: LogTrans
	/// Generated by GenClasses v.4.0.0 on 08/04/2017 08:45 PM
	/// </summary>
	#region LogTrans Class
	[Serializable]
	public partial class LogTrans : LEAD_Log_BaseObject, 
		IClassGenLogXML, IClassGenCopyWithNewID, IClassGenPropertyChanging, INotifyPropertyChanging
	{
		#region Private Properties
		private string _logGUID = string.Empty;
		private string _action = string.Empty;
		private string _actionType = string.Empty;
		private string _objectName = null;
		private DateTime _dtLogged = DateTime.MinValue;
		private string _desc = null;
		private string _userName = null;
		private string _sourceIP = null;
		private string _appVersion = null;
		private string _objectXML = null;
		private string _objectGUID = null;

		private LogTrans _originalValues = null;

		private bool _disposed = false;
		#endregion Private Properties

		#region Constructors

		/// <summary>
		/// Creates a new LogTrans.
		/// </summary>
		public LogTrans()
		{
			SetBaseRules();				// Set the base rules
			SetAdditionalRules();		// Set any additional rules
		}

		/// <summary>
		/// Builds a LogTransbased on a certain record from the database.
		/// </summary>
		/// <param name="logGUID">A primary key used to select the record.</param>
		public LogTrans(string logGUID)
		{
			if (logGUID != null && 
				!String.IsNullOrEmpty(logGUID))
			{
				this.Get(logGUID);
			}

			SetBaseRules();				// Set the base rules
			SetAdditionalRules();		// Set any additional rules
		}
		#endregion Constructors

		#region Disposal
		/// <summary>
		/// Override of the disposal method
		/// </summary>
		/// <param name="disposing">True if the object is being disposed, otherwise false</param>
		protected override void Dispose(bool disposing)
		{
			if (!this._isDisposable) { return; }

			if (!this._disposed)
			{
				try
				{
					// Set the disposed on this object to true
					this._disposed = true;

					if (disposing)
					{
						// Release the managed resources you added in
						// this derived class here.

						// Dispose of the original values object
						if (_originalValues != null && _originalValues.IsDisposable) { _originalValues.Dispose(); _originalValues = null; }
					}

					// Release the native unmanaged resources you added
					// in this derived class here.
					// <No Unmanaged Resources in this block>
				}
				finally
				{
					// Call Dispose on your base class.
					if (this.IsDisposable) { base.Dispose(disposing); }
				}
			}
		}
		#endregion Disposal
		
		#region Public Properties
		/// <summary>
		/// Property generated from the sLogGUID field.
		/// </summary>
		public string LogGUID
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _logGUID;
			}
			set 
			{
				if (_logGUID != value)
				{
					bool cancelled = NotifyPropertyChanging("LogGUID", _logGUID, value);
					if (!cancelled)
					{
						_logGUID = value;
						SetModifiedStatus("LogGUID");
						NotifyPropertyChanged("LogGUID", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sAction field.
		/// </summary>
		public string Action
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _action;
			}
			set 
			{
				if (_action != value)
				{
					bool cancelled = NotifyPropertyChanging("Action", _action, value);
					if (!cancelled)
					{
						_action = value;
						SetModifiedStatus("Action");
						NotifyPropertyChanged("Action", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sActionType field.
		/// </summary>
		public string ActionType
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _actionType;
			}
			set 
			{
				if (_actionType != value)
				{
					bool cancelled = NotifyPropertyChanging("ActionType", _actionType, value);
					if (!cancelled)
					{
						_actionType = value;
						SetModifiedStatus("ActionType");
						NotifyPropertyChanged("ActionType", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sObjectName field.
		/// </summary>
		public string ObjectName
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _objectName;
			}
			set 
			{
				if (_objectName != value)
				{
					bool cancelled = NotifyPropertyChanging("ObjectName", _objectName, value);
					if (!cancelled)
					{
						_objectName = value;
						SetModifiedStatus("ObjectName");
						NotifyPropertyChanged("ObjectName", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the dtLogged field.
		/// </summary>
		public DateTime DateLogged
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _dtLogged;
			}
			set 
			{
				if (_dtLogged != value)
				{
					bool cancelled = NotifyPropertyChanging("DateLogged", _dtLogged, value);
					if (!cancelled)
					{
						_dtLogged = value;
						SetModifiedStatus("DateLogged");
						NotifyPropertyChanged("DateLogged", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sDesc field.
		/// </summary>
		public string Desc
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _desc;
			}
			set 
			{
				if (_desc != value)
				{
					bool cancelled = NotifyPropertyChanging("Desc", _desc, value);
					if (!cancelled)
					{
						_desc = value;
						SetModifiedStatus("Desc");
						NotifyPropertyChanged("Desc", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sUserName field.
		/// </summary>
		public string UserName
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _userName;
			}
			set 
			{
				if (_userName != value)
				{
					bool cancelled = NotifyPropertyChanging("UserName", _userName, value);
					if (!cancelled)
					{
						_userName = value;
						SetModifiedStatus("UserName");
						NotifyPropertyChanged("UserName", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sSourceIP field.
		/// </summary>
		public string SourceIP
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _sourceIP;
			}
			set 
			{
				if (_sourceIP != value)
				{
					bool cancelled = NotifyPropertyChanging("SourceIP", _sourceIP, value);
					if (!cancelled)
					{
						_sourceIP = value;
						SetModifiedStatus("SourceIP");
						NotifyPropertyChanged("SourceIP", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sAppVersion field.
		/// </summary>
		public string AppVersion
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _appVersion;
			}
			set 
			{
				if (_appVersion != value)
				{
					bool cancelled = NotifyPropertyChanging("AppVersion", _appVersion, value);
					if (!cancelled)
					{
						_appVersion = value;
						SetModifiedStatus("AppVersion");
						NotifyPropertyChanged("AppVersion", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sObjectXML field.
		/// </summary>
		public string ObjectXML
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _objectXML;
			}
			set 
			{
				if (_objectXML != value)
				{
					bool cancelled = NotifyPropertyChanging("ObjectXML", _objectXML, value);
					if (!cancelled)
					{
						_objectXML = value;
						SetModifiedStatus("ObjectXML");
						NotifyPropertyChanged("ObjectXML", value);
					}
				}
			}
		}

		/// <summary>
		/// Property generated from the sObjectGUID field.
		/// </summary>
		public string ObjectGUID
		{
			get 
			{
				if (RefreshRate != RefreshFrequency.ByDeveloperOnly) { RefreshObject(); }
				return _objectGUID;
			}
			set 
			{
				if (_objectGUID != value)
				{
					bool cancelled = NotifyPropertyChanging("ObjectGUID", _objectGUID, value);
					if (!cancelled)
					{
						_objectGUID = value;
						SetModifiedStatus("ObjectGUID");
						NotifyPropertyChanged("ObjectGUID", value);
					}
				}
			}
		}

		/// <summary>
		/// A LogTrans with all of this object's original values.
		/// </summary>
		[Newtonsoft.Json.JsonIgnore]
		public LogTrans OriginalValues
		{
			get { return _originalValues; }
			set { _originalValues = value; }
		}
		#endregion Public Properties

		#region Public Methods
		/// <summary>
		/// Set the Base Rules on the class.
		/// </summary>
		public void SetBaseRules()
		{
			// Property Required Rules
			this.Rules.Add(new PropertyRequiredCustomRule("LogGUID", "The \"Log GUID\" field is required in the LogTrans record.", RecordStatus.Modified));
			this.Rules.Add(new PropertyRequiredCustomRule("Action", "The \"Action\" field is required in the LogTrans record."));
			this.Rules.Add(new PropertyRequiredCustomRule("ActionType", "The \"Action Type\" field is required in the LogTrans record."));
			this.Rules.Add(new PropertyRequiredCustomRule("DateLogged", "The \"Date Logged\" field is required in the LogTrans record."));

			// Max Length Rules
			this.Rules.Add(new MaxLengthCustomRule("Action", 100, "The maximum length for the \"Action\" field is 100 characters."));
			this.Rules.Add(new MaxLengthCustomRule("ActionType", 50, "The maximum length for the \"ActionType\" field is 50 characters."));
			this.Rules.Add(new MaxLengthCustomRule("ObjectName", 100, "The maximum length for the \"ObjectName\" field is 100 characters."));
			this.Rules.Add(new MaxLengthCustomRule("Desc", 500, "The maximum length for the \"Desc\" field is 500 characters."));
			this.Rules.Add(new MaxLengthCustomRule("UserName", 50, "The maximum length for the \"UserName\" field is 50 characters."));
			this.Rules.Add(new MaxLengthCustomRule("SourceIP", 100, "The maximum length for the \"SourceIP\" field is 100 characters."));
			this.Rules.Add(new MaxLengthCustomRule("AppVersion", 50, "The maximum length for the \"AppVersion\" field is 50 characters."));

			// Date Range Rules
			this.Rules.Add(new MinValueCustomRule<DateTime>("DateLogged", DateTime.Parse("1/1/1900"), "The date value entered must be after 1/1/1900 for the \"DateLogged\" field."));
			this.Rules.Add(new MaxValueCustomRule<DateTime>("DateLogged", DateTime.Parse("12/31/2299"), "The date value entered must be before 12/31/2299 for the \"DateLogged\" field."));
		}

		/// <summary>
		/// Clone the object as a new instance and pass it back.
		/// </summary>
		/// <returns>A copy of the object.</returns>
		public LogTrans Clone()
		{
			LogTrans item = base.CloneObjectWithIL<LogTrans>(this);
			item.OriginalValues = this.OriginalValues;

			return item;
		}

		/// <summary>
		/// Copy the object - then change the ID field to a new value.
		/// </summary>
		/// <returns>A copy of the object with a new ID.</returns>
		public object CopyWithNewID()
		{
			// Make the copy of the object
			LogTrans item = this.Clone();
			
			// Change the ID field
			item.LogGUID = System.Guid.NewGuid().ToString();

			// Reset the record status to new
			item.RecordStatus = RecordStatus.New;

			return item;
		}

		
		/// <summary>
		/// Refresh the object based on the threshhold of set minutes on the object.
		/// </summary>
		/// <param name="threshHoldInMinutes">The threshhold in minutes that is allowed before a record is marked as "old".</param>
		/// <returns>A collection of any exceptions that were raised in the method.</returns>
		public ClassGenExceptionCollection RefreshObject(int threshHoldInMinutes)
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			// Find out how far back you need to go based on the passed threshhold
			if (_dateTimeObjectPopulated == null) { return errors; }
			DateTime currentTime = DAL.GetSQLServerDateTime();
			if (((TimeSpan)currentTime.Subtract(_dateTimeObjectPopulated.Value)).TotalMinutes > threshHoldInMinutes)
			{
				// Force a refresh on the object
				errors.AddRange(this.Get(_logGUID));
			}

			return errors;		// Return the collection
		}

		/// <summary>
		/// Refresh the object based on the currently set Refresh on the project.
		/// </summary>
		/// <returns>A collection of any exceptions that were raised in the method.</returns>
		public ClassGenExceptionCollection RefreshObject()
		{
			return RefreshObject((int)RefreshRate);
		}

		/// <summary>
		/// Force a Refresh on the object based on the held Primary Key GUID.
		/// </summary>
		/// <returns>A collection of any exceptions that were raised in the method.</returns>
		public ClassGenExceptionCollection RefreshForce()
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			if (!String.IsNullOrEmpty(this._logGUID))
			{
				errors.AddRange(this.Get(_logGUID));	// Just do a get on the object
			}
			else
			{
				ClassGenException ex = new ClassGenException("You can't force a refresh on an object where the key field is not set.", ClassGenExceptionIconType.Critical);
			}

			return errors;		// Return the collection
		}

		/// <summary>
		/// Undo any changes that might be done on the object.
		/// </summary>
		public override void UndoChanges()
		{
			// Enumerate the properties
			_logGUID = _originalValues.LogGUID;
			_action = _originalValues.Action;
			_actionType = _originalValues.ActionType;
			_objectName = _originalValues.ObjectName;
			_dtLogged = _originalValues.DateLogged;
			_desc = _originalValues.Desc;
			_userName = _originalValues.UserName;
			_sourceIP = _originalValues.SourceIP;
			_appVersion = _originalValues.AppVersion;
			_objectXML = _originalValues.ObjectXML;
			_objectGUID = _originalValues.ObjectGUID;
			
			_changedProps.Clear();		// Clear the changed properties

			this.RecordStatus = _originalValues.RecordStatus;
		}

		/// <summary>
		/// Default AddUpdate Method
		/// </summary>
		public ClassGenExceptionCollection AddUpdate()
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			SqlConnection oConn = null;
			SqlTransaction transaction = null;

			try
			{
				oConn = DAL.OpenConnection();

				// Start a new transaction
				transaction = oConn.BeginTransaction();

				errors.AddRange(AddUpdate(oConn, transaction));

				// Attempt to close the connection
				if (transaction != null)
				{
					try
					{
						transaction.Commit();		// Commit the transaction
						transaction.Dispose();		// Dispose of the transaction
						transaction = null;
					}
					catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
					catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
				}
				DAL.CloseConnection(oConn);
				oConn = null;
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
			finally
			{
				if (transaction != null)
				{
					try { transaction.Rollback(); }
					catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
					catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
				}
			}

			return errors;		// Return the errors collection
		}

		/// <summary>
		/// Default AddUpdate Method
		/// </summary>
		public ClassGenExceptionCollection AddUpdate(SqlConnection oConn, SqlTransaction oTrans)
		{
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			// Check to see if the record is already current - if so, don't do anything.
			if (_recordStatus == RecordStatus.Current) { return errors; }
			
			// Set the key value fields in the local object if they don't have values
			if (String.IsNullOrEmpty(_logGUID)) { _logGUID = System.Guid.NewGuid().ToString(); }

			// Check to see if the record is a delete - if so, delete it from the db.
			if (_recordStatus == RecordStatus.Deleted)
			{
				try
				{
					// Delete the record and all its children
					errors.AddRange(LEAD_Log_BaseObject.DeleteImmediate("tLogTrans", "sLogGUID", _logGUID, true));
				}
				catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
				catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

				return errors;
			}
			
			// Next, check to see if the record is new.  If so, add it to the system
			if (_recordStatus == RecordStatus.New || _recordStatus == RecordStatus.Modified)
			{
				// Check the Broken Rules collection
				errors.AddRange(BrokenRules);

				// If the error collection is not clear, dump out of the function
				if (errors.Count > 0) { return errors; }

				try
				{
					// Do the Exist/Insert check first
					sql = "IF NOT EXISTS (SELECT sLogGUID FROM tLogTrans WHERE sLogGUID = @psLogGUID) " + 
						"INSERT INTO tLogTrans (sLogGUID, sAction, sActionType, sObjectName, dtLogged, sDesc, sUserName, sSourceIP, sAppVersion, sObjectXML, sObjectGUID) " + 
						"SELECT @psLogGUID, @psAction, @psActionType, @psObjectName, @pdtLogged, @psDesc, @psUserName, @psSourceIP, @psAppVersion, @psObjectXML, @psObjectGUID " + 
						"ELSE " + 
						"UPDATE tLogTrans SET " + 
						"sLogGUID = @psLogGUID" + 
						",sAction = @psAction" + 
						",sActionType = @psActionType" + 
						",dtLogged = @pdtLogged" + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("ObjectName")) ? ",sObjectName = @psObjectName" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("Desc")) ? ",sDesc = @psDesc" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("UserName")) ? ",sUserName = @psUserName" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("SourceIP")) ? ",sSourceIP = @psSourceIP" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("AppVersion")) ? ",sAppVersion = @psAppVersion" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("ObjectXML")) ? ",sObjectXML = @psObjectXML" : "") + 
						(_recordStatus == RecordStatus.New || (_recordStatus == RecordStatus.Modified && _changedProps.Contains("ObjectGUID")) ? ",sObjectGUID = @psObjectGUID" : "") + 
						" WHERE sLogGUID = @psLogGUID;  SELECT @psLogGUID AS ret_val FROM tLogTrans WHERE sLogGUID = @psLogGUID";
					cmd = new SqlCommand(sql);

					cmd.Parameters.Add("@psLogGUID", SqlDbType.UniqueIdentifier).Value = new System.Guid(_logGUID);
					cmd.Parameters.Add("@psAction", SqlDbType.VarChar, 100).Value = _action;
					cmd.Parameters.Add("@psActionType", SqlDbType.VarChar, 50).Value = _actionType;
					cmd.Parameters.Add("@psObjectName", SqlDbType.VarChar, 100).Value = (_objectName == null ? (object)DBNull.Value : (object)_objectName);
					cmd.Parameters.Add("@pdtLogged", SqlDbType.DateTime).Value = _dtLogged;
					cmd.Parameters.Add("@psDesc", SqlDbType.VarChar, 500).Value = (_desc == null ? (object)DBNull.Value : (object)_desc);
					cmd.Parameters.Add("@psUserName", SqlDbType.VarChar, 50).Value = (_userName == null ? (object)DBNull.Value : (object)_userName);
					cmd.Parameters.Add("@psSourceIP", SqlDbType.VarChar, 100).Value = (_sourceIP == null ? (object)DBNull.Value : (object)_sourceIP);
					cmd.Parameters.Add("@psAppVersion", SqlDbType.VarChar, 50).Value = (_appVersion == null ? (object)DBNull.Value : (object)_appVersion);
					cmd.Parameters.Add("@psObjectXML", SqlDbType.Text).Value = (_objectXML == null ? (object)DBNull.Value : (object)_objectXML);
					cmd.Parameters.Add("@psObjectGUID", SqlDbType.UniqueIdentifier).Value = (_objectGUID == null || String.IsNullOrEmpty(_objectGUID) ? (object)DBNull.Value :  (object)new System.Guid(_objectGUID));

					cmd.Transaction = oTrans;		// Set the transaction on the command

					dt = DAL.SQLExecDataTable(cmd, oConn);
					foreach (DataRow row in dt.Rows)
					{
						// Get the old key field value to figure out if we need to update it
						string oldRecID = _logGUID;

						_logGUID = row["ret_val"].ToString();
					}
					dt.Dispose();		// Kill off the datatable
				}
				catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
				catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

				if (errors.CriticalExceptionCount == 0)
				{
					_recordStatus = RecordStatus.Current;		// Set the record status to current after a successful update
				}
			}

			return errors;		// Return the errors collection
		}

		/// <summary>
		/// Get the record specified on the Key Fields in the table.
		/// </summary>
		/// <param name="logGUID">A key field used to find the correct record.</param>
		/// <param name="includeParentPopulation">Whether or not to include values derived from a parent table.</param>
		public ClassGenExceptionCollection Get(string logGUID, bool includeParentPopulation)
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			SqlCommand cmd = null;
			string sql = string.Empty;
			DataTable dt = null;
			
			try
			{
				sql = "SELECT [LT].*, GETDATE() AS dateTimeObjectPopulated " + 
					"FROM tLogTrans [LT] " + 
					"WHERE [LT].[sLogGUID] = @psLogGUID " + 
					"";
				cmd = new SqlCommand(sql);
				cmd.Parameters.Add("@psLogGUID", SqlDbType.UniqueIdentifier).Value = new System.Guid(logGUID);
				dt = DAL.SQLExecDataTable(cmd);

				foreach (DataRow row in dt.Rows)
				{
					// Call the get from data row method
					errors.AddRange(this.Get(row, includeParentPopulation));
				}

				dt.Dispose();		// Dispose of the datatable
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return errors;		// Return the error collection
		}

		/// <summary>
		/// Get the record specified based on the Key Fields in the table
		/// </summary>
		/// <param name="logGUID">A key field used to find the correct record.</param>
		/// <returns>A collection of exceptions that occurred while trying to perform the Get.</returns>
		public ClassGenExceptionCollection Get(string logGUID)
		{
			return Get(logGUID, false);		// Get the item
		}

		/// <summary>
		/// Populate the object using the datarow passed in...
		/// </summary>
		/// <param name="row">The DataRow to populate the object from.</param>
		/// <param name="includeParentPopulation">Whether to include data generated from parent tables.</param>
		/// <returns>A collection of exceptions that occurred while trying to perform the Get.</returns>
		public ClassGenExceptionCollection Get(DataRow row, bool includeParentPopulation)
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				// Enumerate through the fields and set up the object
				_recordStatus = RecordStatus.Current;
				_isLoaded = false;
				if (row.Table.Columns.Contains("dateTimeObjectPopulated"))
				{
					_dateTimeObjectPopulated = (DateTime)row["dateTimeObjectPopulated"];
				}
				else
				{
					_dateTimeObjectPopulated = DateTime.Now;
				}
				DAL.EvalNumSecondsLocalMachineBehindServer(_dateTimeObjectPopulated.Value);
				
				_logGUID = (row["sLogGUID"] != DBNull.Value ? row["sLogGUID"].ToString().ToLower() : string.Empty);
				_action = (row["sAction"] != DBNull.Value ? row["sAction"].ToString() : string.Empty);
				_actionType = (row["sActionType"] != DBNull.Value ? row["sActionType"].ToString() : string.Empty);
				_objectName = (row["sObjectName"] != DBNull.Value ? _objectName = row["sObjectName"].ToString() : null);
				_dtLogged = (row["dtLogged"] != DBNull.Value ? (DateTime)row["dtLogged"] : new DateTime(1900, 1, 1));
				
				_desc = (row["sDesc"] != DBNull.Value ? _desc = row["sDesc"].ToString() : null);
				_userName = (row["sUserName"] != DBNull.Value ? _userName = row["sUserName"].ToString() : null);
				_sourceIP = (row["sSourceIP"] != DBNull.Value ? _sourceIP = row["sSourceIP"].ToString() : null);
				_appVersion = (row["sAppVersion"] != DBNull.Value ? _appVersion = row["sAppVersion"].ToString() : null);
				_objectXML = (row["sObjectXML"] != DBNull.Value ? _objectXML = row["sObjectXML"].ToString() : null);
				
				_objectGUID = (row["sObjectGUID"] != DBNull.Value ? _objectGUID = row["sObjectGUID"].ToString().ToLower() : null);

				_isLoaded = true;

				// Make a copy of the object with original values
				_originalValues = this.Clone();
			}
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return errors;		// Return the error collection
		}

		/// <summary>
		/// Get the record specified from the passed datarow.
		/// </summary>
		/// <param name="row">The DataRow used to determine the correct record.</param>
		/// <returns>A collection of exceptions that occurred while trying to perform the Get.</returns>
		public ClassGenExceptionCollection Get(DataRow row)
		{
			return Get(row, false);		// Get the item
		}


		/// <summary>
		/// Converts the object to a datatable. 
		/// </summary>
		/// <param name="dt">The datatable to use as a template.</param>
		/// <returns>A new datarow.</returns>
		public DataRow ToDataRow(DataTable dt)
		{
			// Generate and return a data row
			return ToDataRowWithIL<LogTrans>(this, dt);
		}

		#endregion Public Methods

		#region Public Static Values

		// Main Class - LogTrans

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_LogGUID = "LogGUID";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_Action = "Action";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_ActionType = "ActionType";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_ObjectName = "ObjectName";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_DateLogged = "DateLogged";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_Desc = "Desc";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_UserName = "UserName";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_SourceIP = "SourceIP";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_AppVersion = "AppVersion";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_ObjectXML = "ObjectXML";

		/// <summary>
		/// The property's name as a static value.
		/// </summary>
		public static readonly string FN_ObjectGUID = "ObjectGUID";

		#endregion Public Static Values

		#region Public Static Methods
		/// <summary>
		/// Get a DB Field name from the field that's passed in.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>A list of values from the collection (sorted by value).</returns>
		public static string GetDBFieldName(LogTransField field)
		{
			string fldName = string.Empty;

			// Add the elements
			switch (field)
			{
				case LogTransField.LogGUID: fldName = "sLogGUID"; break;
				case LogTransField.Action: fldName = "sAction"; break;
				case LogTransField.ActionType: fldName = "sActionType"; break;
				case LogTransField.ObjectName: fldName = "sObjectName"; break;
				case LogTransField.DateLogged: fldName = "dtLogged"; break;
				case LogTransField.Desc: fldName = "sDesc"; break;
				case LogTransField.UserName: fldName = "sUserName"; break;
				case LogTransField.SourceIP: fldName = "sSourceIP"; break;
				case LogTransField.AppVersion: fldName = "sAppVersion"; break;
				case LogTransField.ObjectXML: fldName = "sObjectXML"; break;
				case LogTransField.ObjectGUID: fldName = "sObjectGUID"; break;
			}

			// Return the field name
			return fldName;
		}

		/// <summary>
		/// Get a field from the DB Field that's passed in.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>A list of values from the collection (sorted by value).</returns>
		public static string GetDBFieldName(string field)
		{
			string fldName = null;

			// Add the elements
			if (field.ToLower() == "slogguid") { fldName = LogTransField.LogGUID.ToString(); }
			else if (field.ToLower() == "saction") { fldName = LogTransField.Action.ToString(); }
			else if (field.ToLower() == "sactiontype") { fldName = LogTransField.ActionType.ToString(); }
			else if (field.ToLower() == "sobjectname") { fldName = LogTransField.ObjectName.ToString(); }
			else if (field.ToLower() == "dtlogged") { fldName = LogTransField.DateLogged.ToString(); }
			else if (field.ToLower() == "sdesc") { fldName = LogTransField.Desc.ToString(); }
			else if (field.ToLower() == "susername") { fldName = LogTransField.UserName.ToString(); }
			else if (field.ToLower() == "ssourceip") { fldName = LogTransField.SourceIP.ToString(); }
			else if (field.ToLower() == "sappversion") { fldName = LogTransField.AppVersion.ToString(); }
			else if (field.ToLower() == "sobjectxml") { fldName = LogTransField.ObjectXML.ToString(); }
			else if (field.ToLower() == "sobjectguid") { fldName = LogTransField.ObjectGUID.ToString(); }

			// Return the field name
			return fldName;
		}

		/// <summary>
		/// The database table name.
		/// </summary>
		public static readonly string DB_TableName = "tLogTrans"; 

		/// <summary>
		/// Get a distinct list of values based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>A list of values from the collection (sorted by value).</returns>
		public static List<string> GetDistinctFromDB(LogTransField field)
		{
			return GetDistinctFromDB(field, string.Empty);
		}

		/// <summary>
		/// Get a distinct list of values based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>A list of values from the collection (sorted by value).</returns>
		public static List<string> GetDistinctFromDB(LogTransField field, string whereClause)
		{
			string fldName = GetDBFieldName(field);

			if (String.IsNullOrEmpty(fldName)) { return new List<string>(); }

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			List<string> rtv = new List<string>();

			try
			{
				sql = "SELECT DISTINCT LTRIM(RTRIM([" + fldName + "])) " +
						"FROM [tLogTrans] " +
						"WHERE [" + fldName + "] IS NOT NULL AND LTRIM(RTRIM([" + fldName + "])) <> '' " + 
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") + 
						"ORDER BY LTRIM(RTRIM([" + fldName + "]))";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (fldName.ToLower().EndsWith("guid"))
				{
					foreach (DataRow row in dt.Rows)
					{
						rtv.Add(row[0].ToString().ToLower());
					}
				}
				else
				{
					foreach (DataRow row in dt.Rows)
					{
						rtv.Add(row[0].ToString());
					}
				}
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return rtv;
		}

		/// <summary>
		/// Get a distinct list of values based on the elements in a database table.
		/// </summary>
		/// <param name="fields">The fields to get.</param>
		/// <param name="fieldAliases">The field aliases.</param>
		/// <param name="sortedFields">The sorted fields.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>A datatable of values from the collection (sorted by value).</returns>
		public static DataTable GetDistinctFromDBAsDataTable(LogTransField[] fields, 
			string[] fieldAliases,
			LogTransField[] sortedFields, 
			string whereClause)
		{
			Dictionary<LogTransField, string> fieldNames = new Dictionary<LogTransField, string>();
			StringBuilder sbFields = new StringBuilder();
			StringBuilder sbWhereClause = new StringBuilder();
			int fieldCount = 0;
			foreach (LogTransField fld in fields)
			{
				if (!fieldNames.ContainsKey(fld))
				{
					fieldNames.Add(fld, GetDBFieldName(fld));
					sbWhereClause.Append((sbWhereClause.ToString().Trim().Length > 0 ? " AND " : " WHERE ") +
						fieldNames[fld] + " IS NOT NULL AND LTRIM(RTRIM(" + fieldNames[fld] + ")) <> '' ");
				}
				if (String.IsNullOrEmpty(fieldNames[fld])) { return null; }
				sbFields.Append((sbFields.ToString().Trim().Length > 0 ? "," : "") + "[" + fieldNames[fld] + "]" + 
					(fieldAliases.Length > fieldCount ? " AS [" + fieldAliases[fieldCount] + "] " : ""));
				fieldCount++;
			}

			Dictionary<LogTransField, string> sortedFieldNames = new Dictionary<LogTransField, string>();
			StringBuilder sbSortedFields = new StringBuilder();
			foreach (LogTransField fld in sortedFields)
			{
				if (!sortedFieldNames.ContainsKey(fld))
				{
					sortedFieldNames.Add(fld, GetDBFieldName(fld));
				}
				if (String.IsNullOrEmpty(sortedFieldNames[fld])) { return null; }
				sbSortedFields.Append((sbSortedFields.ToString().Trim().Length > 0 ? "," : "") + sortedFieldNames[fld]);
			}

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT DISTINCT " + sbFields.ToString() + " " +
						"FROM tLogTrans " +
						sbWhereClause.ToString() + " " +
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") +
						(!String.IsNullOrEmpty(sbSortedFields.ToString()) ? " ORDER BY " + sbSortedFields.ToString() + "" : "");
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return dt;
		}

		/// <summary>
		/// Get the minimum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>The single earliest DateTime from the collection.</returns>
		public static DateTime? GetMinDateFromDB(LogTransMinMaxDateField field)
		{
			return GetMinDateFromDB(field, string.Empty);
		}

		/// <summary>
		/// Get the minimum based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>The single earliest DateTime from the collection.</returns>
		public static DateTime? GetMinDateFromDB(LogTransMinMaxDateField field, string whereClause)
		{
			LogTransField fld = (LogTransField)Enum.Parse(typeof(LogTransField),
				field.ToString(), true);
			string fldName = GetDBFieldName(fld);

			if (String.IsNullOrEmpty(fldName)) { return null; }

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT MIN([" + fldName + "]) " +
						"FROM [tLogTrans] " +
						"WHERE [" + fldName + "] IS NOT NULL " +
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") +
						"";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (dt.Rows.Count == 0) { return null; }
				return (DateTime)dt.Rows[0][0];		// Return the value
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return null;
		}

		/// <summary>
		/// Get the maximum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>The single latest DateTime from the collection.</returns>
		public static DateTime? GetMaxDateFromDB(LogTransMinMaxDateField field)
		{
			return GetMaxDateFromDB(field, string.Empty);
		}

		/// <summary>
		/// Get the maximum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>The single latest DateTime from the collection.</returns>
		public static DateTime? GetMaxDateFromDB(LogTransMinMaxDateField field, string whereClause)
		{
			LogTransField fld = (LogTransField)Enum.Parse(typeof(LogTransField),
				field.ToString(), true);
			string fldName = GetDBFieldName(fld);

			if (String.IsNullOrEmpty(fldName)) { return null; }

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT MAX([" + fldName + "]) " +
						"FROM [tLogTrans] " +
						"WHERE [" + fldName + "] IS NOT NULL " +
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") +
						"";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (dt.Rows.Count == 0) { return null; }
				return (DateTime)dt.Rows[0][0];		// Return the value
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return null;
		}

		/// <summary>
		/// Get the minimum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>The single least value from the collection.</returns>
		public static decimal? GetMinNumberFromDB(LogTransMinMaxNumberField field)
		{
			return GetMinNumberFromDB(field, string.Empty);
		}

		/// <summary>
		/// Get the minimum based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>The single least value from the collection.</returns>
		public static decimal? GetMinNumberFromDB(LogTransMinMaxNumberField field, string whereClause)
		{
			LogTransField fld = (LogTransField)Enum.Parse(typeof(LogTransField),
				field.ToString(), true);
			string fldName = GetDBFieldName(fld);

			if (String.IsNullOrEmpty(fldName)) { return null; }

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT MIN([" + fldName + "]) " +
						"FROM [tLogTrans] " +
						"WHERE [" + fldName + "] IS NOT NULL " +
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") +
						"";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (dt.Rows.Count == 0) { return null; }
				return (decimal)dt.Rows[0][0];		// Return the value
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return null;
		}

		/// <summary>
		/// Get the maximum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>The single greatest value from the collection.</returns>
		public static decimal? GetMaxNumberFromDB(LogTransMinMaxNumberField field)
		{
			return GetMaxNumberFromDB(field, string.Empty);
		}

		/// <summary>
		/// Get the maximum value based on the elements in a database table.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <param name="whereClause">The where clause to fire against the database.</param>
		/// <returns>The single greatest value from the collection.</returns>
		public static decimal? GetMaxNumberFromDB(LogTransMinMaxNumberField field, string whereClause)
		{
			LogTransField fld = (LogTransField)Enum.Parse(typeof(LogTransField),
				field.ToString(), true);
			string fldName = GetDBFieldName(fld);

			if (String.IsNullOrEmpty(fldName)) { return null; }

			// Get the datatable
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT MAX([" + fldName + "]) " +
						"FROM [tLogTrans] " +
						"WHERE [" + fldName + "] IS NOT NULL " +
						(!String.IsNullOrEmpty(whereClause) ? "AND (" + whereClause + ") " : "") +
						"";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (dt.Rows.Count == 0) { return null; }
				return (decimal)dt.Rows[0][0];		// Return the value
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return null;
		}

		/// <summary>
		/// Copy the object - then change the id field to a new value
		/// </summary>
		/// <param name="source">The object to copy.</param>
		/// <returns>A copy of the object, with a new ID.</returns>
		public static LogTrans CopyFrom(LogTrans source)
		{
			// Make the copy of the object
			LogTrans item = source.Clone();
			
			// Change the ID field
			item.LogGUID = System.Guid.NewGuid().ToString();

			// Reset the record status to new
			item.RecordStatus = RecordStatus.New;

			return item;
		}

		/// <summary>
		/// Convert the passed string into a db friendly string (one that 
		/// doesn't include the names in the object, but rather the names 
		/// from the fields from the database).
		/// </summary>
		/// <param name="dbString">The string to process.</param>
		/// <returns>The converted string.</returns>
		public static string ToDBFriendly(string dbString)
		{
			string rtv = dbString;

			rtv = rtv.Replace("[LogGUID]", "[sLogGUID]");
			rtv = rtv.Replace("[Action]", "[sAction]");
			rtv = rtv.Replace("[ActionType]", "[sActionType]");
			rtv = rtv.Replace("[ObjectName]", "[sObjectName]");
			rtv = rtv.Replace("[DateLogged]", "[dtLogged]");
			rtv = rtv.Replace("[Desc]", "[sDesc]");
			rtv = rtv.Replace("[UserName]", "[sUserName]");
			rtv = rtv.Replace("[SourceIP]", "[sSourceIP]");
			rtv = rtv.Replace("[AppVersion]", "[sAppVersion]");
			rtv = rtv.Replace("[ObjectXML]", "[sObjectXML]");
			rtv = rtv.Replace("[ObjectGUID]", "[sObjectGUID]");

			return rtv;
		}

		#region Json.NET Serialization
		/// <summary>
		/// Attempt to serialize the LogTrans object to the server
		/// </summary>
		/// <param name="obj">The LogTrans object to serialize</param>
		/// <returns>A string containing the return from the method</returns>
		public static string SerializeObject(LogTrans obj)
		{
			string rtv = string.Empty;

			try
			{
				rtv = Newtonsoft.Json.JsonConvert.SerializeObject(obj);
			}
			catch (Exception ex)
			{
				rtv = "Error: " + ex.Message;
			}

			return rtv;         // Return the result
		}

		/// <summary>
		/// Attempt to Deserialize the LogTrans object from the server
		/// </summary>
		/// <param name="obj">The LogTrans object to deserialize</param>
		/// <param name="errors">The errors collection</param>
		/// <returns>A LogTrans object containing the return from the method</returns>
		public static LogTrans DeserializeObject(string obj, ref ClassGenExceptionCollection errors)
		{
			LogTrans rtv = null;

			try
			{
				rtv = Newtonsoft.Json.JsonConvert.DeserializeObject<LogTrans>(obj);
			}
			catch (Exception ex)
			{
				errors.Add(new ClassGenException("Error: " + ex.Message, ClassGenExceptionIconType.Critical));
			}

			return rtv;         // Return the result
		}
		#endregion Json.NET Serialization

		#endregion Public Static Methods

		#region IClassGenPropertyChanging Implementation

		/// <summary>
		/// Occurs when a property is about to change.
		/// </summary>
		public event PropertyChangingEventHandler PropertyChanging;
		/// <summary>
		/// Occurs when a ClassGen property is about to change.
		/// </summary>
		public event ClassGenPropertyChangingEventHandler ClassGenPropertyChanging;
		private bool NotifyPropertyChanging(string info, object oldValue, object newValue)
		{
			bool cancel = false;
			if (ClassGenPropertyChanging != null)
			{
				ClassGenPropertyChangingEventArgs e = new ClassGenPropertyChangingEventArgs(info, oldValue, newValue);
				ClassGenPropertyChanging(this, e);
				cancel = e.Cancel; 
			}
			if (!cancel && PropertyChanging != null)
			{
				PropertyChangingEventArgs e = new PropertyChangingEventArgs(info);
				PropertyChanging(this, e);
			}
			return cancel;
		}

		#endregion IClassGenPropertyChanging Implementation
		
		#region IClassGenLogXML Implementation
		/// <summary>
		/// Gets the current object as an XML object stream.
		/// </summary>
		/// <param name="includeBaseProperties">True to include the base properties 
		///		created as model base objects (GridCustom0-9, etc.).</param>
		/// <returns>The object as an XML string.</returns>
		public string GetAsXML(bool includeBaseProperties)
		{
			StringBuilder sb = new StringBuilder();

			sb.Append("<LogGUID>" + System.Security.SecurityElement.Escape(LogGUID) + "</LogGUID>" + Environment.NewLine);
			sb.Append("<Action>" + System.Security.SecurityElement.Escape(Action) + "</Action>" + Environment.NewLine);
			sb.Append("<ActionType>" + System.Security.SecurityElement.Escape(ActionType) + "</ActionType>" + Environment.NewLine);
			sb.Append("<ObjectName>" + System.Security.SecurityElement.Escape(ObjectName) + "</ObjectName>" + Environment.NewLine);
			sb.Append("<DateLogged>" + DateLogged.ToString("MM/dd/yyyy hh:mm:ss.ffffff tt") + "</DateLogged>" + Environment.NewLine);
			sb.Append("<Desc>" + System.Security.SecurityElement.Escape(Desc) + "</Desc>" + Environment.NewLine);
			sb.Append("<UserName>" + System.Security.SecurityElement.Escape(UserName) + "</UserName>" + Environment.NewLine);
			sb.Append("<SourceIP>" + System.Security.SecurityElement.Escape(SourceIP) + "</SourceIP>" + Environment.NewLine);
			sb.Append("<AppVersion>" + System.Security.SecurityElement.Escape(AppVersion) + "</AppVersion>" + Environment.NewLine);
			sb.Append("<ObjectXML>" + System.Security.SecurityElement.Escape(ObjectXML) + "</ObjectXML>" + Environment.NewLine);
			sb.Append("<ObjectGUID>" + System.Security.SecurityElement.Escape(ObjectGUID) + "</ObjectGUID>" + Environment.NewLine);

			if (includeBaseProperties)
			{
				sb.Append("<RecordStatus>" + this.RecordStatus.ToString() + "</RecordStatus>" + Environment.NewLine);
				sb.Append("<CheckedInGrid>" + this.CheckedInGrid.ToString() + "</CheckedInGrid>" + Environment.NewLine);
				sb.Append("<IsDisposable>" + this.IsDisposable.ToString() + "</IsDisposable>" + Environment.NewLine);

				sb.Append("<GridCustom_0>" + System.Security.SecurityElement.Escape(this.GridCustom_0) + "</GridCustom_0>" + Environment.NewLine);
				sb.Append("<GridCustom_1>" + System.Security.SecurityElement.Escape(this.GridCustom_1) + "</GridCustom_1>" + Environment.NewLine);
				sb.Append("<GridCustom_2>" + System.Security.SecurityElement.Escape(this.GridCustom_2) + "</GridCustom_2>" + Environment.NewLine);
				sb.Append("<GridCustom_3>" + System.Security.SecurityElement.Escape(this.GridCustom_3) + "</GridCustom_3>" + Environment.NewLine);
				sb.Append("<GridCustom_4>" + System.Security.SecurityElement.Escape(this.GridCustom_4) + "</GridCustom_4>" + Environment.NewLine);
				sb.Append("<GridCustom_5>" + System.Security.SecurityElement.Escape(this.GridCustom_5) + "</GridCustom_5>" + Environment.NewLine);
				sb.Append("<GridCustom_6>" + System.Security.SecurityElement.Escape(this.GridCustom_6) + "</GridCustom_6>" + Environment.NewLine);
				sb.Append("<GridCustom_7>" + System.Security.SecurityElement.Escape(this.GridCustom_7) + "</GridCustom_7>" + Environment.NewLine);
				sb.Append("<GridCustom_8>" + System.Security.SecurityElement.Escape(this.GridCustom_8) + "</GridCustom_8>" + Environment.NewLine);
				sb.Append("<GridCustom_9>" + System.Security.SecurityElement.Escape(this.GridCustom_9) + "</GridCustom_9>" + Environment.NewLine);
			}

			if (!String.IsNullOrEmpty(sb.ToString()))
			{
				sb.Insert(0, "<LogTrans>" + Environment.NewLine);
				sb.Append("</LogTrans>" + Environment.NewLine);
			}

			return sb.ToString();
		}

		/// <summary>
		/// Get the current object as an XML object stream with all base properties included.
		/// </summary>
		/// <returns>The object as an XML string with all base properties included.</returns>
		public string GetAsXML()
		{
			return GetAsXML(true);
		}

		/// <summary>
		/// Get the changed elements as an XML list of strings.
		/// Strings are broken at 6000 characters.
		/// </summary>
		/// <returns>A string value containing the XML list.</returns>
		public string GetChangedElementsAsXML()
		{
			StringBuilder sb = new StringBuilder();

			// Get the original values in relation to the new ones
			if (_originalValues.LogGUID != LogGUID)
			{
				sb.Append("\t<LogGUID>");
				sb.Append("<OldValue>" + _originalValues.LogGUID + "</OldValue>");
				sb.Append("<NewValue>" + LogGUID + "</NewValue>");
				sb.Append("</LogGUID>" + Environment.NewLine);
			}
			if (_originalValues.Action != Action)
			{
				sb.Append("\t<Action>");
				sb.Append("<OldValue>" + _originalValues.Action + "</OldValue>");
				sb.Append("<NewValue>" + Action + "</NewValue>");
				sb.Append("</Action>" + Environment.NewLine);
			}
			if (_originalValues.ActionType != ActionType)
			{
				sb.Append("\t<ActionType>");
				sb.Append("<OldValue>" + _originalValues.ActionType + "</OldValue>");
				sb.Append("<NewValue>" + ActionType + "</NewValue>");
				sb.Append("</ActionType>" + Environment.NewLine);
			}
			if (_originalValues.ObjectName != ObjectName)
			{
				sb.Append("\t<ObjectName>");
				sb.Append("<OldValue>" + _originalValues.ObjectName + "</OldValue>");
				sb.Append("<NewValue>" + ObjectName + "</NewValue>");
				sb.Append("</ObjectName>" + Environment.NewLine);
			}
			if (_originalValues.DateLogged != DateLogged)
			{
				sb.Append("\t<DateLogged>");
				sb.Append("<OldValue>" + _originalValues.DateLogged.ToString() + "</OldValue>");
				sb.Append("<NewValue>" + DateLogged.ToString() + "</NewValue>");
				sb.Append("</DateLogged>" + Environment.NewLine);
			}
			if (_originalValues.Desc != Desc)
			{
				sb.Append("\t<Desc>");
				sb.Append("<OldValue>" + _originalValues.Desc + "</OldValue>");
				sb.Append("<NewValue>" + Desc + "</NewValue>");
				sb.Append("</Desc>" + Environment.NewLine);
			}
			if (_originalValues.UserName != UserName)
			{
				sb.Append("\t<UserName>");
				sb.Append("<OldValue>" + _originalValues.UserName + "</OldValue>");
				sb.Append("<NewValue>" + UserName + "</NewValue>");
				sb.Append("</UserName>" + Environment.NewLine);
			}
			if (_originalValues.SourceIP != SourceIP)
			{
				sb.Append("\t<SourceIP>");
				sb.Append("<OldValue>" + _originalValues.SourceIP + "</OldValue>");
				sb.Append("<NewValue>" + SourceIP + "</NewValue>");
				sb.Append("</SourceIP>" + Environment.NewLine);
			}
			if (_originalValues.AppVersion != AppVersion)
			{
				sb.Append("\t<AppVersion>");
				sb.Append("<OldValue>" + _originalValues.AppVersion + "</OldValue>");
				sb.Append("<NewValue>" + AppVersion + "</NewValue>");
				sb.Append("</AppVersion>" + Environment.NewLine);
			}
			if (_originalValues.ObjectXML != ObjectXML)
			{
				sb.Append("\t<ObjectXML>");
				sb.Append("<OldValue>" + _originalValues.ObjectXML + "</OldValue>");
				sb.Append("<NewValue>" + ObjectXML + "</NewValue>");
				sb.Append("</ObjectXML>" + Environment.NewLine);
			}
			if (_originalValues.ObjectGUID != ObjectGUID)
			{
				sb.Append("\t<ObjectGUID>");
				sb.Append("<OldValue>" + _originalValues.ObjectGUID + "</OldValue>");
				sb.Append("<NewValue>" + ObjectGUID + "</NewValue>");
				sb.Append("</ObjectGUID>" + Environment.NewLine);
			}

			if (!String.IsNullOrEmpty(sb.ToString()))
			{
				sb.Insert(0, "<LogTrans>" + Environment.NewLine);
				sb.Append("</LogTrans>" + Environment.NewLine);
			}

			return sb.ToString();
		}

		/// <summary>
		/// Generates a new LogTrans object from an XML description.
		/// </summary>
		/// <param name="xml">The string of XML to load from.</param>
		/// <returns>A new LogTrans object.</returns>
		public static LogTrans LoadFromXML(string xml)
		{
			LogTrans item = new LogTrans();
			System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
			bool propSet = false;
			doc.LoadXml(xml);

			foreach (System.Xml.XmlNode child in doc.ChildNodes[0].ChildNodes)
			{
				if (!propSet) { propSet = true; }
				switch (child.Name)
				{
					case "LogGUID": item.LogGUID = child.InnerText; break;
					case "Action": item.Action = child.InnerText; break;
					case "ActionType": item.ActionType = child.InnerText; break;
					case "ObjectName": item.ObjectName = child.InnerText; break;
					case "DateLogged": item.DateLogged = DateTime.Parse(child.InnerText); break;

					case "Desc": item.Desc = child.InnerText; break;
					case "UserName": item.UserName = child.InnerText; break;
					case "SourceIP": item.SourceIP = child.InnerText; break;
					case "AppVersion": item.AppVersion = child.InnerText; break;
					case "ObjectXML": item.ObjectXML = child.InnerText; break;

					case "ObjectGUID": item.ObjectGUID = child.InnerText; break;
					case "RecordStatus": item.RecordStatus = (RecordStatus)Enum.Parse(typeof(RecordStatus), child.InnerText, true); break;
					case "CheckedInGrid": item.CheckedInGrid = bool.Parse(child.InnerText); break;
					case "IsDisposable": item.IsDisposable = bool.Parse(child.InnerText); break;
					case "GridCustom_0": item.GridCustom_0 = child.InnerText; break;

					case "GridCustom_1": item.GridCustom_1 = child.InnerText; break;
					case "GridCustom_2": item.GridCustom_2 = child.InnerText; break;
					case "GridCustom_3": item.GridCustom_3 = child.InnerText; break;
					case "GridCustom_4": item.GridCustom_4 = child.InnerText; break;
					case "GridCustom_5": item.GridCustom_5 = child.InnerText; break;

					case "GridCustom_6": item.GridCustom_6 = child.InnerText; break;
					case "GridCustom_7": item.GridCustom_7 = child.InnerText; break;
					case "GridCustom_8": item.GridCustom_8 = child.InnerText; break;
					case "GridCustom_9": item.GridCustom_9 = child.InnerText; break;
				}
			}
			return (propSet ? item : null);
		}
		#endregion IClassGenLogXML Implementation
	}
	#endregion LogTrans Class

	#region LogTransField Enum
	/// <summary>
	/// Enum for each field type in the element.
	/// </summary>
	public enum LogTransField
	{
		/// <summary>
		/// The LogGUID element.
		/// </summary>
		LogGUID,
		/// <summary>
		/// The Action element.
		/// </summary>
		Action,
		/// <summary>
		/// The ActionType element.
		/// </summary>
		ActionType,
		/// <summary>
		/// The ObjectName element.
		/// </summary>
		ObjectName,
		/// <summary>
		/// The DateLogged element.
		/// </summary>
		DateLogged,
		/// <summary>
		/// The Desc element.
		/// </summary>
		Desc,
		/// <summary>
		/// The UserName element.
		/// </summary>
		UserName,
		/// <summary>
		/// The SourceIP element.
		/// </summary>
		SourceIP,
		/// <summary>
		/// The AppVersion element.
		/// </summary>
		AppVersion,
		/// <summary>
		/// The ObjectXML element.
		/// </summary>
		ObjectXML,
		/// <summary>
		/// The ObjectGUID element.
		/// </summary>
		ObjectGUID,
	}
	#endregion LogTransField Enum

	#region LogTransMinMaxDateField Enum
	/// <summary>
	/// Enum for each DateTime field in the element that can have a minimum or maximum.
	/// </summary>
	public enum LogTransMinMaxDateField
	{
		/// <summary>
		/// The DateLogged element.
		/// </summary>
		DateLogged,
	}
	#endregion LogTransMinMaxDateField Enum

	#region LogTransMinMaxNumberField Enum
	/// <summary>
	/// Enum for each numerical field in the element that can have a minimum or maximum.
	/// </summary>
	public enum LogTransMinMaxNumberField
	{
	}
	#endregion LogTransMinMaxNumberField Enum

	#region LogTrans Collection
	/// <summary>
	/// A collection for LogTrans objects.
	/// </summary>
	/// <remarks>
	/// This collection class is the primary way to work with LogTrans objects.
	/// Most of the functionality is in this class, including the methods for creating LogTrans objects from a database.
	/// </remarks>
	[Serializable]
	public partial class LogTransCollection : ClassGenBindingList<LogTrans, string>, IDisposable, 
		IClassGenLogXMLCollection, IClassGenClassGenerated, IClassGenClassUpdatable
	{
		#region Constructors
		/// <summary>
		/// Create an empty collection.
		/// </summary>
		public LogTransCollection() 
		{
			// The Key Field Name for the collection
			this.KeyFieldName = "LogGUID";


			// Additional field names that have no foreign key relation, but are GUID's just the same
			this.ForeignKeyFields.Add("ObjectGUID");

			_rules = new ClassGenRules(this);			// Set the base collection
		}

		/// <summary>
		/// Create a collection and populate it with information based on the where clause.
		/// </summary>
		/// <param name="whereClause">The SQL where clause to use to populate the collection.</param>
		public LogTransCollection(string whereClause) 
		{
			// The Key Field Name for the collection
			this.KeyFieldName = "LogGUID";


			// Additional field names that have no foreign key relation, but are GUID's just the same
			this.ForeignKeyFields.Add("ObjectGUID");

			_rules = new ClassGenRules(this);			// Set the base collection
			this.GetFromDB(whereClause);			// Populate the collection
		}

		/// <summary>
		/// Create a collection and populate it with information based on the where clause.
		/// </summary>
		/// <param name="whereClause">The SQL where clause to use to populate the collection.</param>
		/// <param name="getChildren">True if the collection should populate all child collections as well.</param>
		public LogTransCollection(string whereClause, bool getChildren) 
		{
			// The Key Field Name for the collection
			this.KeyFieldName = "LogGUID";


			// Additional field names that have no foreign key relation, but are GUID's just the same
			this.ForeignKeyFields.Add("ObjectGUID");

			_rules = new ClassGenRules(this);				// Set the base collection
			this.GetFromDB(whereClause, getChildren);		// Populate the collection
		}
		#endregion Constructors

		#region Public Properties
		/// <summary>
		/// Get a single record from the collection (not from the DB) that matches the ID.
		/// </summary>
		/// <param name="logGUID">A key field used to find the correct record.</param>
		/// <returns>The LogTrans object that matches the given value.</returns>
		public LogTrans Get(string logGUID)
		{
			LogTrans val = null;
			if (KeyedCollection.ContainsKey(logGUID.ToLower())) { val = KeyedCollection[logGUID.ToLower()]; }
			return val;
		}

		// Override the methods needed to do the collection thing
		#region Common Methods Override

		#endregion Common Methods Override


		/// <summary>
		/// A collection of all the active records from the collection (the ones without a status of "Deleted").
		/// </summary>
		public new LogTransCollection ActiveRecords
		{
			get
			{
				return (LogTransCollection)base.ActiveRecords;
			}
		}

		/// <summary>
		/// A collection of all the deleted records from the collection (the ones with a status of "Deleted").
		/// </summary>
		public LogTransCollection DeletedRecords
		{
			get
			{
				return (LogTransCollection)GetRecordsBasedOnStatus(RecordStatus.Deleted);
			}
		}

		/// <summary>
		/// A collection of all the modified records from the collection (the ones with a status of "Modified").
		/// </summary>
		public LogTransCollection ModifiedRecords
		{
			get
			{
				return (LogTransCollection)GetRecordsBasedOnStatus(RecordStatus.Modified);
			}
		}

		/// <summary>
		/// A collection of all the new records from the collection (the ones with a status of "New").
		/// </summary>
		public LogTransCollection NewRecords
		{
			get
			{
				return (LogTransCollection)GetRecordsBasedOnStatus(RecordStatus.New);
			}
		}

		#endregion Public Properties

		#region Collection Get Methods
		/// <summary>
		/// Populate the collection with items, using the SQL Where clause included.
		/// </summary>
		/// <param name="dbCount">A long variable (passed by reference) where this method can record the count of total records retrieved.</param>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB(ref long dbCount)
		{
			dbCount = LogTransCollection.GetCountFromDB();
			return GetFromDB();
		}

		/// <summary>
		/// Populate the collection with items, using the SQL Where clause included.
		/// </summary>
		/// <param name="whereClause">An SQL Where clause to apply to the get.  Do not include the keyword WHERE - this method will add it for you.</param>
		/// <param name="dbCount">A long variable (passed by reference) where this method can record the count of total records retrieved.</param>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB(string whereClause, ref long dbCount)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.GetChildren = false;
			this.GetCollectionConfig.IncludeUpdateDateInWhereClause = false;
			dbCount = LogTransCollection.GetCountFromDB(whereClause);
			return GetFromDB();
		}

		/// <summary>
		/// Populate the collection with items, using the where clause included.
		/// </summary>
		/// <param name="whereClause">An SQL Where clause to apply to the get.  Do not include the keyword WHERE - this method will add it for you.</param>
		/// <param name="getChildren">True if the developer wants all children collections returned as well.</param>
		/// <param name="dbCount">A long variable (passed by reference) where this method can record the count of total records retrieved.</param>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB(string whereClause, bool getChildren, ref long dbCount)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.GetChildren = getChildren;
			this.GetCollectionConfig.IncludeUpdateDateInWhereClause = false;
			dbCount = LogTransCollection.GetCountFromDB(whereClause);
			return GetFromDB();
		}

		/// <summary>
		/// Get all items from the database.
		/// Gets and populates all children objects as well.
		/// </summary>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDBWithChildren()
		{
			this.GetCollectionConfig.WhereClause = string.Empty;
			this.GetCollectionConfig.GetChildren = true;
			return GetFromDB();
		}

		/// <summary>
		/// Populate the collection with items, using the Where clause included.
		/// </summary>
		/// <param name="whereClause">An SQL Where clause to apply to the get.  Do not include the keyword WHERE - this method will add it for you.</param>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB(string whereClause)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.GetChildren = false;
			this.GetCollectionConfig.IncludeUpdateDateInWhereClause = false;
			return GetFromDB();
		}

		/// <summary>
		/// Populate the collection with items, using the Where clause included.
		/// </summary>
		/// <param name="whereClause">An SQL Where clause to apply to the get.  Do not include the keyword WHERE - this method will add it for you.</param>
		/// <param name="getChildren">True if the developer wants all children collections returned as well.</param>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB(string whereClause, bool getChildren)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.GetChildren = getChildren;
			this.GetCollectionConfig.IncludeUpdateDateInWhereClause = false;
			return GetFromDB();
		}

		/// <summary>
		/// Populate the collection with items, using the Where clause included
		/// </summary>
		/// <returns>A collection of any exceptions this method raises.</returns>
		public ClassGenExceptionCollection GetFromDB() 
		{
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			SqlParameter param = null;
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			
			// Reset the IsLoaded Variable before we load the collection
			this._isLoaded = false;
			
			// See if we're supposed to get this thing paged
			if (this.GetCollectionConfig.PageRecords)
			{
				_backgroundWorker = new BackgroundWorker();
				_backgroundWorker.WorkerReportsProgress = true;
				_backgroundWorker.WorkerSupportsCancellation = true;
				_backgroundWorker.RunWorkerCompleted += new RunWorkerCompletedEventHandler(_backgroundWorker_RunWorkerCompleted);
				_backgroundWorker.ProgressChanged += new ProgressChangedEventHandler(_backgroundWorker_ProgressChanged);
				_backgroundWorker.DoWork += new DoWorkEventHandler(_backgroundWorker_DoWork);
				_backgroundWorker.RunWorkerAsync();
				return errors;
			}

			try
			{
				sql = "SELECT " + (this.GetCollectionConfig.TopRecords > -1 ? "TOP " + this.GetCollectionConfig.TopRecords.ToString() + " " : "") +
					" [LT].*, GETDATE() AS dateTimeObjectPopulated " + 
					"FROM tLogTrans [LT] " + 
					(!String.IsNullOrEmpty(this.GetCollectionConfig.WhereClause) ? "WHERE " + this.GetCollectionConfig.WhereClause : "") + 
					"";
				if (this.GetCollectionConfig.IncludeUpdateDateInWhereClause)
				{
					sql += (!String.IsNullOrEmpty(this.GetCollectionConfig.WhereClause) ? " AND" : " WHERE") +
						"  > @p";
					param = new SqlParameter("@p", SqlDbType.DateTime);
					param.Value = _dateTimeObjectPopulated;
				}
				if (this.GetCollectionConfig.TopRecords > -1 &&
					!String.IsNullOrEmpty(this.GetCollectionConfig.TopSort))
				{
					sql += " ORDER BY " + this.GetCollectionConfig.TopSort;
				}
				cmd = new SqlCommand(sql);
				if (this.GetCollectionConfig.IncludeUpdateDateInWhereClause) { cmd.Parameters.Add(param); }

				this.OnMasterPopulate("LogTrans", "Retrieving Full List Of LogTranses", string.Empty);
				dt = DAL.SQLExecDataTable(cmd);

				int count = 0;
				if (!this.GetCollectionConfig.IncludeUpdateDateInWhereClause) { this.Clear(); }
				foreach (DataRow row in dt.Rows)
				{
					// Enumerate through the fields and set up the object
					if (count == 0)
					{
						if (row.Table.Columns.Contains("dateTimeObjectPopulated"))
						{
							_dateTimeObjectPopulated = (DateTime)row["dateTimeObjectPopulated"];
						}
						else
						{
							_dateTimeObjectPopulated = DateTime.Now;
						}
						DAL.EvalNumSecondsLocalMachineBehindServer(_dateTimeObjectPopulated.Value);
					}

					this.OnDetailPopulate("LogTrans", 
						"Populating LogTrans: " + (++count).ToString("###,###,###,##0") + " of " + dt.Rows.Count.ToString("###,###,###,##0"), 
						string.Empty, 
						dt.Rows.Count, 
						count);

					#region Fields
					LogTrans item = new LogTrans();
					item.Get(row);

					// Check to make sure this collection doesn't already contain this item
					if (this.Contains(item.LogGUID)) { this.Remove(item.LogGUID); }

					this.Add(item);
					#endregion Fields
				}
				
				dt.Dispose();		// Dispose of the datatable

				this._isLoaded = true;				// Set the IsLoaded Property
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return errors;		// Return the errors collection
		}

		/// <summary>
		/// Get a count from the database of the total number of records.
		/// </summary>
		/// <param name="whereClause">The SQL Where clause to use to get the total count.</param>
		/// <returns>The count of records.</returns>
		public static long GetCountFromDB(string whereClause)
		{
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();
			int rtv = 0;
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			try
			{
				sql = "SELECT COUNT(*) " +
						"FROM tLogTrans " +
						(!String.IsNullOrEmpty(whereClause) ? "WHERE " + whereClause : "") +
						"";
				cmd = new SqlCommand(sql);
				dt = DAL.SQLExecDataTable(cmd);
				if (dt.Rows.Count > 0 &&
					dt.Rows[0][0] != DBNull.Value)
				{
					rtv = (int)dt.Rows[0][0];
				}
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return rtv;
		}

		/// <summary>
		/// Get a count from the database of the total number of records.
		/// </summary>
		/// <returns>The count of records.</returns>
		public static long GetCountFromDB()
		{
			return GetCountFromDB(string.Empty);		// Return the base method
		}
		#endregion Collection Get Methods

		#region Collection Put Methods
		/// <summary>
		/// Writes all records to the database that are dirty within the collection.
		/// </summary>
		public ClassGenExceptionCollection AddUpdateAll()
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			SqlConnection oConn = null;
			SqlTransaction transaction = null;

			try
			{
				oConn = DAL.OpenConnection();

				// Start a new transaction
				transaction = oConn.BeginTransaction();

				errors.AddRange(AddUpdateAll(oConn, transaction));

				// Attempt to close the connection
				if (transaction != null)
				{
					try
					{
						transaction.Commit();		// Commit the transaction
						transaction.Dispose();		// Dispose of the transaction
						transaction = null;
					}
					catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
					catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
				}
				DAL.CloseConnection(oConn);
				oConn = null;
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
			finally
			{
				if (transaction != null)
				{
					try { transaction.Rollback(); }
					catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
					catch (Exception ex) { errors.Add(new ClassGenException(ex)); }
				}
			}

			return errors;		// Return the errors collection
		}

		/// <summary>
		/// Writes all records to the database that are dirty within the collection.
		/// </summary>
		/// <param name="oConn">The connection object</param>
		/// <param name="oTrans">The transaction object</param>
		public ClassGenExceptionCollection AddUpdateAll(SqlConnection oConn, SqlTransaction oTrans)
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();
			if (this.Count == 0) { return errors; }

			ClassGenExceptionCollection itemErrors = new ClassGenExceptionCollection();
			int addUpdateAffected = 0, deleteAffected = 0;

			try
			{
				// Delete Method
				for (int i = this.Count - 1; i >= 0; i--)
				{
					this.OnDetailDelete("LogTrans",
						"Deleting LogTrans: " + (this.Count - i + 1).ToString("###,###,###,##0") +
						" of " + this.Count.ToString("###,###,###,##0"),
						string.Empty,
						this.Count,
						this.Count - i + 1);
					LogTrans item = this[i];
					if (item.RecordStatus == RecordStatus.Deleted)
					{
						itemErrors = item.AddUpdate(oConn, oTrans);
						if (itemErrors.Count == 0)
						{
							deleteAffected++;
							this.RemoveAt(i);		// Remove the item from the collection
						}
						else
						{
							foreach (ClassGenException err in itemErrors)
							{
								err.RecordIndex = i + 1;
								err.RecordKey = item.LogGUID;
							}
							errors.AddRange(itemErrors);
						}
					}
				}

				// Update Method
				int count = 0;
				foreach (LogTrans item in this)
				{
					this.OnDetailUpdate("LogTrans",
						"Updating LogTrans: " + (count + 1).ToString("###,###,###,##0") +
						" of " + this.Count.ToString("###,###,###,##0"),
						string.Empty,
						this.Count,
						count + 1);
					if (item.RecordStatus == RecordStatus.Modified ||
						item.RecordStatus == RecordStatus.New)
					{
						itemErrors = item.AddUpdate(oConn, oTrans);
						if (itemErrors.Count == 0) { addUpdateAffected++; }
						else
						{
							foreach (ClassGenException err in itemErrors)
							{
								err.RecordIndex = count + 1;
								err.RecordKey = item.LogGUID;
							}
							errors.AddRange(itemErrors);
						}
					}
					count++;
				}


				// Add how many records were affected by the update
				errors.Add(new ClassGenException(addUpdateAffected.ToString("###,##0") +
					" Records affected by the update.", ClassGenExceptionIconType.System, addUpdateAffected.ToString()));
				errors[errors.Count - 1].Number = addUpdateAffected;
				errors.Add(new ClassGenException(deleteAffected.ToString("###,##0") +
					" Records affected by the delete.", ClassGenExceptionIconType.System, deleteAffected.ToString()));
				errors[errors.Count - 1].Number = deleteAffected;
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return errors;		// Return the errors collection
		}
		#endregion Collection Put Methods

		#region Clone/Copy Methods
		/// <summary>
		/// Create an exact copy of all the elements in the collection.
		/// </summary>
		/// <returns>The cloned collection.</returns>
		public new LogTransCollection Clone()
		{
			LogTransCollection newColl = new LogTransCollection();
			newColl.AddRange(base.Clone());
			return newColl;
		}

		/// <summary>
		/// Copy the objects in the collection, creating a new ID for each one of them in the process.
		/// </summary>
		/// <returns>A new LogTransCollection.</returns>
		public new LogTransCollection CopyWithNewIDs()
		{
			return (LogTransCollection)base.CopyWithNewIDs();
		}
		#endregion Clone/Copy Methods

		#region GetDistinct Method(s)
		/// <summary>
		/// Get a distinct list of values based on the elements in the collection.
		/// </summary>
		/// <param name="field">The field type to get.</param>
		/// <returns>A list of values from the collection (sorted by value).</returns>
		public List<string> GetDistinctFromCollection(LEAD_Log.LogTransField field)
		{
			if (this.Count == 0) { return new List<string>(); }
			SortedList<string, string> vals = new SortedList<string, string>();

			// Add the elements
			switch (field)
			{
				case LEAD_Log.LogTransField.LogGUID:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.LogGUID) && 
							!vals.ContainsKey(item.LogGUID.Trim())) { vals.Add(item.LogGUID.Trim(), item.LogGUID.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.Action:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.Action) && 
							!vals.ContainsKey(item.Action.Trim())) { vals.Add(item.Action.Trim(), item.Action.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.ActionType:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.ActionType) && 
							!vals.ContainsKey(item.ActionType.Trim())) { vals.Add(item.ActionType.Trim(), item.ActionType.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.ObjectName:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.ObjectName) && 
							!vals.ContainsKey(item.ObjectName.Trim())) { vals.Add(item.ObjectName.Trim(), item.ObjectName.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.Desc:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.Desc) && 
							!vals.ContainsKey(item.Desc.Trim())) { vals.Add(item.Desc.Trim(), item.Desc.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.UserName:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.UserName) && 
							!vals.ContainsKey(item.UserName.Trim())) { vals.Add(item.UserName.Trim(), item.UserName.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.SourceIP:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.SourceIP) && 
							!vals.ContainsKey(item.SourceIP.Trim())) { vals.Add(item.SourceIP.Trim(), item.SourceIP.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.AppVersion:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.AppVersion) && 
							!vals.ContainsKey(item.AppVersion.Trim())) { vals.Add(item.AppVersion.Trim(), item.AppVersion.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.ObjectXML:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.ObjectXML) && 
							!vals.ContainsKey(item.ObjectXML.Trim())) { vals.Add(item.ObjectXML.Trim(), item.ObjectXML.Trim()); }
					}
					break;
				case LEAD_Log.LogTransField.ObjectGUID:
					foreach (LogTrans item in this)
					{
						if (!String.IsNullOrEmpty(item.ObjectGUID) && 
							!vals.ContainsKey(item.ObjectGUID.Trim())) { vals.Add(item.ObjectGUID.Trim(), item.ObjectGUID.Trim()); }
					}
					break;
			}

			List<string> rtv = new List<string>();
			rtv.AddRange(vals.Keys);
			return rtv;
		}
		#endregion GetDistinct Method(s)

		#region Random Methods
		#region GetLocalChildren Methods
		#endregion GetLocalChildren Methods

		/// <summary>
		/// A collection of all broken rules associated with the collection.
		/// (Includes all the child classes validation as well.)
		/// </summary>
		public ClassGenExceptionCollection BrokenRules
		{
			get 
			{
				ClassGenExceptionCollection exceptions = new ClassGenExceptionCollection();
				foreach (LogTrans item in this.ActiveRecords)
				{
					ClassGenExceptionCollection exCollection = item.BrokenRules;
					if (exCollection.Count > 0)
					{
						foreach (ClassGenException ex in exCollection)
						{
							ex.RecordIndex = (this.IndexOf(item)) + 1;
							ex.RecordKey = item.LogGUID;
						}
						exceptions.AddRange(exCollection);
					}
				}

				exceptions.AddRange(_rules.BrokenRules);

				return exceptions;
			}
		}

		/// <summary>
		/// Gets all the records that don't have a deleted status in the collection
		/// </summary>
		/// <returns>A LogTransCollection of current records.</returns>
		public LogTransCollection GetCurrent()
		{
			return this.ActiveRecords;
		}

		/// <summary>
		/// Checks to see if the element exists in the collection.
		/// </summary>
		/// <param name="logGUID">A key field used to find the correct record.</param>
		/// <returns>A boolean indicating whether the element exists in the collection.</returns>
		public bool Exists(string logGUID)
		{
			return (this.Exists(new Predicate<LogTrans>(delegate (LogTrans obj) 
				{ return obj.LogGUID.ToLower() == logGUID.ToLower(); })));
		}

		/// <summary>
		/// Removes the element from the collection based on the argument passed.
		/// </summary>
		/// <param name="logGUID">A key field used to find the correct record.</param>
		public void Remove(string logGUID)
		{
			for (int i = this.Count - 1; i >= 0; i--)
			{
				if (this[i].LogGUID.ToLower() == logGUID.ToLower())
				{
					this.RemoveAt(i);
				}
			}
		}
		
		#region Refresh Collection Methods
		/// <summary>
		/// Refresh the object based on the threshhold of set minutes on the object.
		/// </summary>
		/// <param name="threshHoldInMinutes">The threshhold in minutes that is allowed before a record is marked as "old".</param>
		public ClassGenExceptionCollection RefreshCollection(int threshHoldInMinutes)
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			// Find out how far back you need to go based on the passed threshhold
			if (_dateTimeObjectPopulated == null) { return errors; }
			DateTime currentTime = DAL.GetSQLServerDateTime();
			if (((TimeSpan)currentTime.Subtract(_dateTimeObjectPopulated.Value)).TotalMinutes > threshHoldInMinutes)
			{
				// Force a refresh on the object
				this.GetCollectionConfig.IncludeUpdateDateInWhereClause = true;
				errors.AddRange(this.GetFromDB());
			}

			return errors;		// Return the collection
		}

		/// <summary>
		/// Refresh the object based on the currently set Refresh on the project.
		/// </summary>
		/// <returns>A collection of any exceptions created by refreshing the object.</returns>
		public ClassGenExceptionCollection RefreshCollection()
		{
			return RefreshCollection((int)_refreshRate);
		}

		/// <summary>
		/// Force a Refresh on the object based on the held Primary Key GUID
		/// </summary>
		/// <returns>A collection of any exceptions created by refreshing the object.</returns>
		public ClassGenExceptionCollection RefreshForce()
		{
			ClassGenExceptionCollection errors = new ClassGenExceptionCollection();

			if (_isLoaded)
			{
				this.GetCollectionConfig.IncludeUpdateDateInWhereClause = false;
				errors.AddRange(this.GetFromDB());	// Just do a get on the object
			}
			else
			{
				ClassGenException ex = new ClassGenException("You can't force a refresh on an object where the key field is not set.", ClassGenExceptionIconType.Critical);
			}

			return errors;		// Return the collection
		}
		#endregion Refresh Collection Methods
		#endregion Random Methods

		#region DataTable Methods
		/// <summary>
		/// Converts the object to a datatable. 
		/// Does not include deleted records. 
		/// </summary>
		/// <returns>The object as a DataTable.</returns>
		public DataTable ToDataTable()
		{
			return ToDataTable(false);
		}

		/// <summary>
		/// Converts the object to a datatable. 
		/// </summary>
		/// <param name="includeDeleted">Whether to include deleted records in the datatable.</param>
		/// <returns>The object as a DataTable.</returns>
		public DataTable ToDataTable(bool includeDeleted)
		{
			// Generate the datatable object first
			DataTable dt = this.ToEmptyDataTable();

			// Now, go through and build the data table with actual rows
			int count = 0;
			foreach (LogTrans item in this)
			{
				if (item.RecordStatus == RecordStatus.Current ||
					item.RecordStatus == RecordStatus.Modified ||
					item.RecordStatus == RecordStatus.New ||
					(item.RecordStatus == RecordStatus.Deleted && includeDeleted))
				{
					dt.Rows.Add(item.ToDataRow(dt));
					this.OnDataTablePopulate(string.Empty, string.Empty, string.Empty, this.Count, count + 1);
				}
				count++;
			}
			
			// Return the data table
			return dt;
		}

		/// <summary>
		/// Creates an empty datatable with the object's structure.
		/// </summary>
		/// <returns>An empty DataTable with the object's structure.</returns>
		public DataTable ToEmptyDataTable()
		{
			// Return the data table
			return EmptyDataTableWithIL<LogTrans>();
		}

		/// <summary>
		/// Event Handler to deal with populating the information
		/// </summary>
		public delegate void DataTablePopulateEventHandler(object sender, PopulateUpdateDelete_EventArgs e);
		/// <summary>
		/// Occurs when this class populates a DataTable with a row of its data.
		/// </summary>
		public event DataTablePopulateEventHandler DataTablePopulate;
		/// <summary>
		/// Calls the DataTable.Populate event.
		/// </summary>
		/// <param name="name">The name of the record in the DataRow.</param>
		/// <param name="description">A description of the record.</param>
		/// <param name="errors">The names of any exceptions that cropped up.</param>
		/// <param name="totalCount">The total number of rows in the DataTable.</param>
		/// <param name="currentIndex">The current Index the iterator has reached.</param>
		protected void OnDataTablePopulate(string name, string description, string errors, int totalCount, int currentIndex)
		{
			if (DataTablePopulate != null)
			{
				PopulateUpdateDelete_EventArgs e = new PopulateUpdateDelete_EventArgs(name, description, errors, totalCount, currentIndex);
				DataTablePopulate(this, e);
			}
		}
		#endregion DataTable Methods

		#region Static Methods
		/// <summary>
		/// Delete records from the table based on a given criteria.
		/// </summary>
		/// <remarks>
		/// The Where clause cannot be empty.
		/// To delete all the records from the table, use the LEAD_LogBaseObject.DeleteAll() method, instead.
		/// </remarks>
		/// <param name="whereClause">The SQL where clause to use on the system.</param>
		/// <param name="errors">A ClassGenExceptionCollection to add any exception reports to.</param>
		/// <returns>The number of records affected by the delete.</returns>
		public static int Delete(string whereClause, ref ClassGenExceptionCollection errors)
		{
			string sql = string.Empty;
			SqlCommand cmd = null;
			int recsAffected = 0;

			if (String.IsNullOrEmpty(whereClause))
			{
				errors.Add(new ClassGenException("The where clause cannot be empty.  " + 
					"If you want to delete all records in the table, please call " + 
					"the LEAD_LogBaseObject.DeleteAll() method.", ClassGenExceptionIconType.Critical));
				return -1;
			}

			try
			{
				sql = "DELETE FROM tLogTrans " +
					"WHERE " + whereClause.Trim();
				cmd = new SqlCommand(sql);
				recsAffected = DAL.SQLExecNonQuery(cmd);
			}
			catch (SqlException sqle) { errors.Add(new ClassGenException(sqle)); }
			catch (Exception ex) { errors.Add(new ClassGenException(ex)); }

			return recsAffected;
		}
		#endregion Static Methods

		#region Json.NET Serialization Methods
		/// <summary>
		/// Attempt to serialize the LogTransCollection object to the server
		/// </summary>
		/// <param name="obj">The LogTransCollection object to serialize</param>
		/// <returns>A string containing the return from the method</returns>
		public static string SerializeObject(LogTransCollection obj)
		{
			string rtv = string.Empty;

			try
			{
				rtv = Newtonsoft.Json.JsonConvert.SerializeObject(obj);
			}
			catch (Exception ex)
			{
				rtv = "Error: " + ex.Message;
			}

			return rtv;         // Return the result
		}

		/// <summary>
		/// Attempt to Deserialize the LogTransCollection object from the server
		/// </summary>
		/// <param name="obj">The LogTransCollection object to deserialize</param>
		/// <param name="errors">The errors collection</param>
		/// <returns>A LogTransCollection object containing the return from the method</returns>
		public static LogTransCollection DeserializeObject(string obj, ref ClassGenExceptionCollection errors)
		{
			LogTransCollection rtv = null;

			try
			{
				rtv = Newtonsoft.Json.JsonConvert.DeserializeObject<LogTransCollection>(obj);
			}
			catch (Exception ex)
			{
				errors.Add(new ClassGenException("Error: " + ex.Message, ClassGenExceptionIconType.Critical));
			}

			return rtv;         // Return the result
		}
		#endregion Json.NET Serialization Methods

		#region Threaded Get
		private void _backgroundWorker_DoWork(object sender, DoWorkEventArgs e)
		{
			_asyncConnection = DAL.OpenConnection();

			// Create the temp table on the connection
			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();

			sql = 
				"IF object_id('tempdb..#LogTrans') IS NOT NULL  DROP TABLE #LogTrans; " + 
					"CREATE TABLE #LogTrans (sLogGUID uniqueidentifier, iItemIndex INT IDENTITY(1,1) PRIMARY KEY CLUSTERED);  " + 
					"INSERT INTO #LogTrans (sLogGUID) SELECT sLogGUID FROM tLogTrans" + 
					(!String.IsNullOrEmpty(this.GetCollectionConfig.WhereClause) ? " WHERE " + this.GetCollectionConfig.WhereClause : "") + ";  " + 
					"SELECT COUNT(*) AS iCount FROM #LogTrans "; 
			cmd = new SqlCommand(sql);
			dt = DAL.SQLExecDataTable(cmd, _asyncConnection);

			int totalCount = int.Parse(dt.Rows[0][0].ToString());		// Get the count of records in the table

			BackgroundWorker worker = sender as BackgroundWorker;
			GetAsync(worker, e, _asyncConnection, totalCount, this.GetCollectionConfig.PageSize);		// Start the work
		}

		private void _backgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
		{
			if (e.UserState != null)
			{
				LogTransCollection_GetAsyncObject obj = (LogTransCollection_GetAsyncObject)e.UserState;
				this.OnGetThreadedProgress(obj.CurrentIndex, obj.TotalCount, obj.LogTransCollection);
			}
		}

		private void _backgroundWorker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
		{
			DAL.CloseConnection(_asyncConnection);		// Close the connection
			this.OnGetThreadedCompleted();
			this.IsLoaded = true;		// Set the IsLoaded flag
		}

		/// <summary>
		/// The method that actually does the async Get
		/// </summary>
		private void GetAsync(BackgroundWorker worker, 
			DoWorkEventArgs e, 
			SqlConnection oConn, 
			int totalCount,
			int pageSize)
		{
			int currentIndex = 0, pageStart = 0, pageEnd = 0;
			decimal totalMilleseconds = 0;

			DateTime lastGetStart = DateTime.Now;

			string sql = string.Empty;
			SqlCommand cmd = null;
			DataTable dt = new DataTable();

			LogTransCollection coll = new LogTransCollection();
			LogTrans item = new LogTrans();

			if (worker.CancellationPending) { e.Cancel = true; }		// Cancel the worker if need be

			// Run the method as long as we have records
			while (currentIndex < totalCount)
			{
				sql = string.Empty;  cmd = null;  dt = new DataTable();

				pageStart = currentIndex + 1;
				pageEnd = pageStart - 1 + pageSize;

				sql = "SELECT [LT].*, GETDATE() AS dateTimeObjectPopulated " + 
					"FROM tLogTrans [LT] " + 
					"INNER JOIN #LogTrans TEMP ON [LT].[sLogGUID] = [TEMP].[sLogGUID] " +
					"WHERE TEMP.iItemIndex BETWEEN @piStart AND @piEnd " +
					"";
				cmd = new SqlCommand(sql);
				cmd.Parameters.Add("@piStart", SqlDbType.Int).Value = pageStart;
				cmd.Parameters.Add("@piEnd", SqlDbType.Int).Value = pageEnd;
				lastGetStart = DateTime.Now;
				dt = DAL.SQLExecDataTable(cmd, oConn);

				// Populate the local LogTrans collection
				coll = new LogTransCollection();
				foreach (DataRow row in dt.Rows)
				{
					item = new LogTrans();
					item.Get(row);
					coll.Add(item);
				}

				currentIndex += dt.Rows.Count;		// The current Index count of where we are in the set

				// Report the progress
				LogTransCollection_GetAsyncObject obj = new LogTransCollection_GetAsyncObject(currentIndex,
					totalCount, 
					coll);
				worker.ReportProgress((int)(currentIndex / totalCount), obj);

				// Reset the page size based on the number of records pulled back
				totalMilleseconds = (decimal)((TimeSpan)DateTime.Now.Subtract(lastGetStart)).TotalMilliseconds;
				if ((totalMilleseconds < 300 ||
					totalMilleseconds > 700) &&
					totalMilleseconds > 0)
				{
					// Redo the math on the page size to get it within 500 milleseconds
					pageSize = ((500 * pageSize) / (int)totalMilleseconds);
				}

				if (worker.CancellationPending) { e.Cancel = true; }		// Cancel the worker if need be
			}
		}

		// Events to raise as part of population thread
		/// <summary>
		/// The delegate for the GetThreadedProgress event.
		/// </summary>
		public delegate void GetThreadedProgressEventHandler(object sender, LogTrans_GetCollection_EventArgs e);
		/// <summary>
		/// Occurs when the main thread calls an asynchronous thread to check on its progress getting data from a database.
		/// </summary>
		public event GetThreadedProgressEventHandler GetThreadedProgress;
		/// <summary>
		/// Calls the GetThreadedProgress event.
		/// </summary>
		public void OnGetThreadedProgress(int currentIndex, int totalCount, LogTransCollection coll)
		{
			if (GetThreadedProgress != null)
			{
				// Add the items found in the collection to the current set
				foreach (LogTrans a in coll)
				{
					this.Add(a);		// Add the LogTrans
				}

				LogTrans_GetCollection_EventArgs e = new LogTrans_GetCollection_EventArgs(currentIndex, totalCount, coll);
				GetThreadedProgress(this, e);
			}
		}

		/// <summary>
		/// The delegate for the GetThreadedCompleted event.
		/// </summary>
		public delegate void GetThreadedCompletedEventHandler(object sender, EventArgs e);
		/// <summary>
		/// Occurs when an asynchronous thread finishes getting data from a database.
		/// </summary>
		public event GetThreadedCompletedEventHandler GetThreadedCompleted;
		/// <summary>
		/// Calls the GetThreadedCompleted event.
		/// </summary>
		public void OnGetThreadedCompleted()
		{
			if (GetThreadedCompleted != null)
			{
				EventArgs e = new EventArgs();
				GetThreadedCompleted(this, e);
			}
		}

		/// <summary>
		/// Start the Get All Method in a threaded fashion
		/// </summary>
		/// <param name="pageSize">The number of records to a page.</param>
		/// <param name="whereClause">An SQL Where clause determining which records to get.</param>
		public void GetFromDBThreaded(int pageSize, string whereClause)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.PageSize = pageSize;
			this.GetCollectionConfig.PageRecords = true;
			GetFromDB();
		}

		/// <summary>
		/// Start the Get All Method in a threaded fashion
		/// </summary>
		/// <param name="whereClause">An SQL Where clause determining which records to get.</param>
		public void GetFromDBThreaded(string whereClause)
		{
			this.GetCollectionConfig.WhereClause = whereClause;
			this.GetCollectionConfig.PageRecords = true;
			GetFromDB();
		}

		/// <summary>
		/// Start the Get All Method in a threaded fashion
		/// </summary>
		/// <param name="pageSize">The number of records to a page.</param>
		public void GetFromDBThreaded(int pageSize)
		{
			this.GetCollectionConfig.PageSize = pageSize;
			this.GetCollectionConfig.PageRecords = true;
			GetFromDB();
		}

		/// <summary>
		/// Start the Get All Method in a threaded fashion
		/// </summary>
		public void GetFromDBThreaded()
		{
			this.GetCollectionConfig.PageRecords = true;
			GetFromDB();
		}

		/// <summary>
		/// Stop the Background worker from getting anymore
		/// </summary>
		public void GetFromDBThreadedStop()
		{
			_backgroundWorker.CancelAsync();
		}
		#endregion Threaded Get

		#region IClassGenLogXMLCollection Implementation
		/// <summary>
		/// Get the collection as an XML Stream with all base model properties included.
		/// </summary>
		/// <returns>The XML Stream.</returns>
		public string GetAsXML()
		{
			return GetAsXML(true);
		}

		/// <summary>
		/// Get the collection as an XML Stream.
		/// </summary>
		/// <param name="includeBaseProperties">True to include the base model properties.</param>
		/// <returns>The XML Stream.</returns>
		public string GetAsXML(bool includeBaseProperties)
		{
			StringBuilder sb = new StringBuilder();
			foreach (LogTrans item in this)
			{
				sb.Append(item.GetAsXML(includeBaseProperties));
			}

			// Include the header/footer for the stream
			sb.Insert(0, "<LogTransCollection>" + Environment.NewLine);
			sb.Append("</LogTransCollection>" + Environment.NewLine);

			return sb.ToString();
		}

		/// <summary>
		/// Get the read elements as an XML list of strings.
		/// Strings are broken at 6000 characters.
		/// </summary>
		/// <param name="newElements">A List&lt;&gt; of strings (passed by reference) into which the method can insert elements marked as "new".</param>
		/// <param name="readElements">A List&lt;&gt; of strings (passed by reference) into which the method can insert elements marked as "read".</param>
		/// <param name="changedElements">A List&lt;&gt; of strings (passed by reference) into which the method can insert elements marked as "changed".</param>
		/// <param name="deletedElements">A List&lt;&gt; of strings (passed by reference) into which the method can insert elements marked as "deleted".</param>
		public void GetXMLChanges(ref List<string> newElements,
			ref List<string> readElements,
			ref List<string> changedElements,
			ref List<string> deletedElements)
		{
			StringBuilder sbNew = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
			StringBuilder sbRead = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
			StringBuilder sbChanged = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
			StringBuilder sbDeleted = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);

			// Clear out the collections
			newElements = new List<string>();
			readElements = new List<string>();
			changedElements = new List<string>();
			deletedElements = new List<string>();

			// Go through the records and take care of them
			foreach (LogTrans item in this)
			{
				switch (item.RecordStatus)
				{
					case RecordStatus.Current:
						// Don't forget the to string
						sbRead.Append("<LogTrans>" + Environment.NewLine);
						sbRead.Append("\t<LogGUID>" + item.LogGUID + "</LogGUID>" + Environment.NewLine);
						sbRead.Append("\t<Action>" + item.Action + "</Action>" + Environment.NewLine);
						sbRead.Append("\t<ActionType>" + item.ActionType + "</ActionType>" + Environment.NewLine);
						sbRead.Append("\t<ObjectName>" + (item.ObjectName != null ? item.ObjectName : "NULL") + "</ObjectName>" + Environment.NewLine);
						sbRead.Append("\t<DateLogged>" + item.DateLogged.ToString() + "</DateLogged>" + Environment.NewLine);
						sbRead.Append("</LogTrans>" + Environment.NewLine);

						if (sbRead.ToString().Trim().Length > LEAD_Log_BaseObject.SplitOnXMLCharactersForLogging) 
						{ 
							readElements.Add(sbRead.ToString());
							sbRead = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader); 
						}
						break;

					case RecordStatus.Deleted:
						sbDeleted.Append("<LogTrans>" + Environment.NewLine);
						sbDeleted.Append("\t<LogGUID>" + item.LogGUID + "</LogGUID>" + Environment.NewLine);
						sbDeleted.Append("\t<Action>" + item.Action + "</Action>" + Environment.NewLine);
						sbDeleted.Append("\t<ActionType>" + item.ActionType + "</ActionType>" + Environment.NewLine);
						sbDeleted.Append("\t<ObjectName>" + (item.ObjectName != null ? item.ObjectName : "NULL") + "</ObjectName>" + Environment.NewLine);
						sbDeleted.Append("\t<DateLogged>" + item.DateLogged.ToString() + "</DateLogged>" + Environment.NewLine);
						sbDeleted.Append("</LogTrans>" + Environment.NewLine);

						if (sbDeleted.ToString().Trim().Length > LEAD_Log_BaseObject.SplitOnXMLCharactersForLogging)
						{
							deletedElements.Add(sbDeleted.ToString());
							sbDeleted = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
						}
						break;

					case RecordStatus.New:
						sbNew.Append("<LogTrans>" + Environment.NewLine);
						sbNew.Append("\t<LogGUID>" + item.LogGUID + "</LogGUID>" + Environment.NewLine);
						sbNew.Append("\t<Action>" + item.Action + "</Action>" + Environment.NewLine);
						sbNew.Append("\t<ActionType>" + item.ActionType + "</ActionType>" + Environment.NewLine);
						sbNew.Append("\t<ObjectName>" + (item.ObjectName != null ? item.ObjectName : "NULL") + "</ObjectName>" + Environment.NewLine);
						sbNew.Append("\t<DateLogged>" + item.DateLogged.ToString() + "</DateLogged>" + Environment.NewLine);
						sbNew.Append("</LogTrans>" + Environment.NewLine);

						if (sbNew.ToString().Trim().Length > LEAD_Log_BaseObject.SplitOnXMLCharactersForLogging)
						{
							newElements.Add(sbNew.ToString());
							sbNew = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
						}
						break;

					case RecordStatus.Modified:
						sbChanged.Append(item.GetChangedElementsAsXML() + Environment.NewLine);

						if (sbChanged.ToString().Trim().Length > LEAD_Log_BaseObject.SplitOnXMLCharactersForLogging)
						{
							changedElements.Add(sbChanged.ToString());
							sbChanged = new StringBuilder(LEAD_Log_BaseObject.SplitOnXMLHeader);
						}
						break;

				}
			}

			// Add the final strings to the list
			newElements.Add(sbNew.ToString());
			readElements.Add(sbRead.ToString());
			deletedElements.Add(sbDeleted.ToString());
			changedElements.Add(sbChanged.ToString());
		}

		/// <summary>
		/// Load the XML into a collection based on what's passed in.
		/// </summary>
		/// <param name="xml">The XML to process.</param>
		/// <returns>The completed LogTransCollection object.</returns>
		public static LogTransCollection LoadFromXML(string xml)
		{
			LogTransCollection coll = new LogTransCollection();
			System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
			doc.LoadXml(xml);
			// <LogTransCollection>
			foreach (System.Xml.XmlNode nodeMain in doc.ChildNodes)
			{
				// <LogTrans>
				foreach (System.Xml.XmlNode node in nodeMain.ChildNodes)
				{
					// These are the elements <DetailGUID>, <UserName>, etc.
					LogTrans item = LogTrans.LoadFromXML(node.OuterXml);
					if (item != null) { coll.Add(item); }
				}
			}
			return coll;
		}
		#endregion IClassGenLogXMLCollection Implementation
		
		#region Mathematical Functions

		/// <summary>
		/// The earliest DateLogged present in the collection.
		/// </summary>
		public DateTime? MinOfDateLogged
		{
			get
			{
				DateTime? rtv = null;
				if (this.Count > 0) { rtv = this[0].DateLogged; }
				else { return null; }
		
				foreach (LogTrans item in this)
				{
					if (item.DateLogged < rtv) { rtv = item.DateLogged; }
				}
				return rtv;
			}
		}
		
		/// <summary>
		/// The latest DateLogged present in the collection.
		/// </summary>
		public DateTime? MaxOfDateLogged
		{
			get
			{
				DateTime? rtv = null;
				if (this.Count > 0) { rtv = this[0].DateLogged; }
				else { return null; }
		
				foreach (LogTrans item in this)
				{
					if (item.DateLogged > rtv) { rtv = item.DateLogged; }
				}
				return rtv;
			}
		}
		#endregion Mathematical Functions

		#region Collection Disposal
		/// <summary>
		/// Implement IDisposable.
		/// Do not make this method virtual.
		/// A derived class should not be able to override this method.
		/// </summary>
		public void Dispose()
		{
			if (!this.IsDisposable) { return; }

			Dispose(true);

			// Take yourself off the Finalization queue 
			// to prevent finalization code for this object
			// from executing a second time.
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose(bool disposing) executes in two distinct scenarios.
		/// If disposing equals true, the method has been called directly
		/// or indirectly by a user's code. Managed and unmanaged resources
		/// can be disposed.
		/// If disposing equals false, the method has been called by the 
		/// runtime from inside the finalizer and you should not reference 
		/// other objects. Only unmanaged resources can be disposed.
		/// </summary>
		protected virtual void Dispose(bool disposing)
		{
			if (!this.IsDisposable) { return; }

			// Check to see if Dispose has already been called.
			if (!this._disposed)
			{
				// Set the disposed on this object to true
				this._disposed = true;

				// If disposing equals true, dispose all managed 
				// and unmanaged resources.
				if (disposing)
				{
					// Dispose managed resources.
					if (_backgroundWorker != null) { _backgroundWorker.Dispose(); _backgroundWorker = null; } 
					GetCollectionConfig = null;
					if (_rules != null) { _rules.Clear(); _rules = null; }
					if (_asyncConnection != null) { _asyncConnection.Dispose(); _asyncConnection = null; }

					// Go through and properly dispose of each object
					foreach (LogTrans item in this)
					{
						if (item.IsDisposable) { item.Dispose(); }
					}

					// Deal with the keyed collections
					KeyedCollection = new Dictionary<string, LogTrans>();

					// Clear out the collection
					this.Clear();
				}
				// Release unmanaged resources. If disposing is false, 
				// only the following code is executed.
				// <Enter Disposal here> 
				// Note that this is not thread safe.
				// Another thread could start disposing the object
				// after the managed resources are disposed,
				// but before the disposed flag is set to true.
				// If thread safety is necessary, it must be
				// implemented by the client.
			}
		}

		/// <summary>
		/// Use C# destructor syntax for finalization code.
		/// This destructor will run only if the Dispose method 
		/// does not get called.
		/// It gives your base class the opportunity to finalize.
		/// Do not provide destructors in types derived from this class.
		/// </summary>
		~LogTransCollection()
		{
			if (!this.IsDisposable) { return; }

			// Do not re-create Dispose clean-up code here.
			// Calling Dispose(false) is optimal in terms of
			// readability and maintainability.
			Dispose(false);
		}
		#endregion Collection Disposal
	}
	#endregion LogTrans Collection

	#region Event Handler for Async Object
	/// <summary>
	/// Custom class for LogTrans event args such as population
	/// </summary>
	[Serializable]
	public class LogTrans_GetCollection_EventArgs : EventArgs
	{
		private int _totalCount = 0;
		private int _currentIndex = 0;
		private LogTransCollection _coll = new LogTransCollection();

		/// <summary>
		/// Creates a new LogTrans_GetCollection_EventArgs with the specified properties.
		/// </summary>
		/// <param name="currentIndex">The index of the current record being populated.</param>
		/// <param name="totalCount">The total number of records to be collected.</param>
		/// <param name="coll">The collection holding the records.</param>
		public LogTrans_GetCollection_EventArgs(int currentIndex, int totalCount, LogTransCollection coll)
		{
			_totalCount = totalCount;
			_currentIndex = currentIndex;
			_coll = coll;
		}

		/// <summary>
		/// Creates a new empty LogTrans_GetCollection_EventArgs.
		/// </summary>
		public LogTrans_GetCollection_EventArgs()
		{
		}

		/// <summary>
		/// The total number of records to be collected.
		/// </summary>
		public int TotalCount
		{
			get { return _totalCount; }
		}

		/// <summary>
		/// The index of the current record being populated.
		/// </summary>
		public int CurrentIndex
		{
			get { return _currentIndex; }
		}

		/// <summary>
		/// The collection holding the records.
		/// </summary>
		public LogTransCollection LogTransCollection
		{
			get { return _coll; }
		}
	}
	#endregion Event Handler for Async Object

	#region Async Object for the Threaded Get
	/// <summary>
	/// An object to populate a LogTransCollection asynchronously.
	/// </summary>
	public class LogTransCollection_GetAsyncObject
	{
		private int _currentIndex = 0;
		private int _totalCount = 0;
		private LogTransCollection _coll = new LogTransCollection();

		/// <summary>
		/// Creates a new LogTrans_GetAsyncObject with the specified properties.
		/// </summary>
		/// <param name="currentIndex">The index of the current record to be populated.</param>
		/// <param name="totalCount">The total number of records to be collected.</param>
		/// <param name="coll">The collection holding the records.</param>
		public LogTransCollection_GetAsyncObject(int currentIndex, int totalCount, LogTransCollection coll)
		{
			_currentIndex = currentIndex;
			_totalCount = totalCount;
			_coll = coll;
		}

		/// <summary>
		/// The index of the current record being populated.
		/// </summary>
		public int CurrentIndex
		{
			get { return _currentIndex; }
		}

		/// <summary>
		/// The total number of records to be collected.
		/// </summary>
		public int TotalCount
		{
			get { return _totalCount; }
		}

		/// <summary>
		/// The collection holding the records.
		/// </summary>
		public LogTransCollection LogTransCollection
		{
			get { return _coll; }
		}
	}
	#endregion Async Object for the Threaded Get

}

